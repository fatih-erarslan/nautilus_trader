//! Formal verification tests for STDP generated by Wolfram
//!
//! These test vectors verify the mathematical correctness of
//! spike-timing dependent plasticity learning rules.
//!
//! Generated: 2025-12-06

use hyperphysics_stdp::{ClassicalStdp, ClassicalStdpParams, PlasticityRule};

const EPSILON: f32 = 1e-6;

/// Wolfram-verified STDP exponential decay
/// Formula: trace(t) = trace(0) * exp(-t/tau)
#[test]
fn test_exponential_decay_wolfram_verified() {
    // After one time constant (tau=20ms), trace should be 1/e ≈ 0.3679
    let tau = 20.0_f32;
    let expected_one_tau = (-1.0_f32).exp(); // e^(-1) = 0.36787944

    let computed = (-20.0_f32 / tau).exp();
    assert!(
        (computed - expected_one_tau).abs() < EPSILON,
        "Decay at tau: got {}, expected {}",
        computed,
        expected_one_tau
    );

    // After 5 tau, should be ~0.0067
    let expected_five_tau = (-5.0_f32).exp();
    let computed_five = (-100.0_f32 / tau).exp();
    assert!(
        (computed_five - expected_five_tau).abs() < EPSILON,
        "Decay at 5*tau: got {}, expected {}",
        computed_five,
        expected_five_tau
    );
}

/// Wolfram-verified STDP weight updates
/// LTP: Δw = A+ * exp(-Δt/τ+) for pre-before-post
/// LTD: Δw = -A- * exp(-Δt/τ-) for post-before-pre
#[test]
fn test_stdp_weight_updates_wolfram_verified() {
    let a_plus = 0.005_f32;
    let a_minus = 0.00525_f32;
    let tau = 20.0_f32;

    // Wolfram-computed expected values
    let test_cases = [
        // (dt_ms, expected_delta, is_ltp)
        (5.0, 0.003894003915357025_f32, true),   // LTP at dt=5ms
        (10.0, 0.003032653298563167_f32, true),  // LTP at dt=10ms
        (20.0, 0.001839397205857212_f32, true),  // LTP at dt=20ms (one tau)
    ];

    for (dt, expected, _is_ltp) in test_cases {
        let computed = a_plus * (-dt / tau).exp();
        assert!(
            (computed - expected).abs() < 1e-8,
            "LTP at dt={}ms: got {}, expected {}",
            dt,
            computed,
            expected
        );
    }

    // LTD case: dt=-10ms (post before pre)
    let ltd_expected = -0.003184285963491326_f32;
    let ltd_computed = -a_minus * (-10.0_f32 / tau).exp();
    assert!(
        (ltd_computed - ltd_expected).abs() < 1e-8,
        "LTD at dt=-10ms: got {}, expected {}",
        ltd_computed,
        ltd_expected
    );
}

/// Verify classical STDP produces correct sign of updates
#[test]
fn test_classical_stdp_causality() {
    let params = ClassicalStdpParams::balanced();
    let mut stdp = ClassicalStdp::new(10, params);
    stdp.set_synapse_mapping(0, 0);

    // Pre at t=0, Post at t=10 → LTP (causal)
    stdp.on_pre_spike(0, 0.0);
    stdp.on_post_spike(0, 10.0);

    let updates = stdp.get_weight_updates();
    assert!(!updates.is_empty(), "Should have updates after pre-post pair");
    assert!(
        updates[0].delta > 0.0,
        "Causal (pre-before-post) should produce LTP (positive), got {}",
        updates[0].delta
    );

    // Reset and test anti-causal
    stdp.reset();

    // Post at t=0, Pre at t=10 → LTD (anti-causal)
    stdp.on_post_spike(0, 0.0);
    stdp.on_pre_spike(0, 10.0);

    let updates = stdp.get_weight_updates();
    assert!(!updates.is_empty(), "Should have updates after post-pre pair");
    assert!(
        updates[0].delta < 0.0,
        "Anti-causal (post-before-pre) should produce LTD (negative), got {}",
        updates[0].delta
    );
}
