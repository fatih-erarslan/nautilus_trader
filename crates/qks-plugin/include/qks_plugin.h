#ifndef QKS_PLUGIN_H
#define QKS_PLUGIN_H

/* WARNING: This file is auto-generated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace qks {
#endif  // __cplusplus

// Onsager's exact critical temperature for 2D Ising model
// Tc = 2 / ln(1 + √2) ≈ 2.269185
#define ISING_CRITICAL_TEMP 2.269185314213022

// Boltzmann constant (normalized units)
#define BOLTZMANN_CONSTANT 1.0

// Default coupling strength J
#define DEFAULT_COUPLING 1.0

// Miller's Law: Working memory capacity
#define WORKING_MEMORY_CAPACITY 7

// Attention focus threshold (0-1)
#define ATTENTION_THRESHOLD 0.1

// Minimum precision value to avoid numerical issues
#define MIN_PRECISION 1e-8

// Default temperature for policy selection (lower = more deterministic)
#define POLICY_TEMPERATURE 1.0

// Golden ratio τ for Fibonacci STDP
#define FIBONACCI_TAU 1.618033988749895

// Default learning rate
#define DEFAULT_LEARNING_RATE 0.01

// STDP time window (ms)
#define STDP_WINDOW 20.0

// Potentiation amplitude
#define A_PLUS 0.1

// Depression amplitude
#define A_MINUS 0.105

// Minimum quorum size for consensus
#define MIN_QUORUM_SIZE 3

// Byzantine fault tolerance threshold (f < n/3)
#define BYZANTINE_THRESHOLD_RATIO (1.0 / 3.0)

// Consciousness threshold (Φ > 1.0)
#define PHI_THRESHOLD 1.0

// Minimum system size for consciousness (neurons)
#define MIN_CONSCIOUS_SIZE 100

// Global workspace broadcast timeout (ms)
#define BROADCAST_TIMEOUT 100.0

// Minimum confidence for high-certainty decisions
#define HIGH_CONFIDENCE_THRESHOLD 0.9

// Calibration tolerance
#define CALIBRATION_TOLERANCE 0.05

// Meta-learning adaptation rate
#define META_LEARNING_RATE 0.001

// Number of homeostatic variables
#define N_HOMEOSTATIC_VARS 6

// Default PID gains
#define DEFAULT_KP 1.0

#define DEFAULT_KI 0.1

#define DEFAULT_KD 0.05

// Cognitive cycle frequency (Hz)
#define COGNITIVE_CYCLE_FREQ 10.0

// Maximum iterations for convergence
#define MAX_ITERATIONS 100

// Default bond dimension for MPS tensor networks
#define DEFAULT_BOND_DIMENSION 64

// Default number of physical qubits (16-24 range)
#define DEFAULT_PHYSICAL_QUBITS 24

// Target compression ratio for quantum state compression
#define TARGET_COMPRESSION_RATIO 1000

// Target circuit depth reduction percentage
#define TARGET_DEPTH_REDUCTION 0.64

// Gamma oscillation frequency (Hz)
#define GAMMA_FREQUENCY_HZ 40.0

// Beta oscillation frequency (Hz)
#define BETA_FREQUENCY_HZ 20.0

// Theta oscillation frequency (Hz)
#define THETA_FREQUENCY_HZ 6.0

// Delta oscillation frequency (Hz)
#define DELTA_FREQUENCY_HZ 2.0

// Opaque handle to compressed quantum state manager
typedef struct CompressedQuantumStateManager CompressedQuantumStateManager;

// Opaque handle to dynamic circuit knitter
typedef struct DynamicCircuitKnitter DynamicCircuitKnitter;

// Opaque handle to temporal quantum reservoir
typedef struct TemporalQuantumReservoir TemporalQuantumReservoir;

// Opaque handle to tensor network quantum manager
typedef struct TensorNetworkQuantumManager TensorNetworkQuantumManager;

// Performance metrics for quantum system
typedef struct QuantumPerformanceMetrics {
    // Virtual qubits available
    uintptr_t virtual_qubits;
    // Context switch latency (μs)
    double context_switch_latency_us;
    // Compression ratio achieved
    double compression_ratio;
    // Circuit depth reduction (%)
    double depth_reduction_percent;
    // Total operations processed
    uint64_t total_operations;
} QuantumPerformanceMetrics;

// Opaque handle to QKS plugin instance
typedef struct QksHandle {
    // Internal pointer (opaque to C)
    void *inner;
    // Version tag for ABA problem prevention
    uint32_t version;
} QksHandle;

// Configuration parameters (C-compatible)
typedef struct QksConfigParams {
    // Consciousness threshold
    double phi_threshold;
    // Energy setpoint
    double energy_setpoint;
    // Enable meta-learning (0=false, 1=true)
    uint8_t enable_meta_learning;
    // Enable collective intelligence
    uint8_t enable_collective;
    // Enable GPU acceleration
    uint8_t enable_gpu;
    // Max iterations per cycle
    uint32_t max_iterations;
    // Energy budget per cycle
    double energy_budget;
    // Thread pool size (0=auto)
    uint32_t thread_pool_size;
    // PID gains
    double pid_kp;
    double pid_ki;
    double pid_kd;
} QksConfigParams;

// Plugin state snapshot (C-compatible)
typedef struct QksState {
    // Current Phi (consciousness) value
    double phi;
    // Current energy level (0.0 to 1.0)
    double energy;
    // Homeostasis stability (0.0 to 1.0)
    double stability;
    // Number of active layers
    uint8_t active_layers;
    // Total iterations executed
    uint64_t total_iterations;
    // Average iteration time (microseconds)
    double avg_iteration_us;
    // Plugin state (0=uninitialized, 1=ready, 2=active, 3=paused, 4=shutdown)
    uint8_t plugin_state;
    // Layer status bitmap (bit N = layer N initialized)
    uint8_t layer_status;
} QksState;

// Callback function type
//
// # Arguments
// - `context`: User-provided context pointer
// - `event_type`: Type of event (0=iteration, 1=state_change, 2=error, 3=emergence)
// - `data`: Event-specific data pointer
// - `data_len`: Size of data in bytes
typedef void (*QksCallback)(void *context,
                            uint32_t event_type,
                            const uint8_t *data,
                            uintptr_t data_len);

// Opaque handle for FFI (void* equivalent)
typedef struct OpaqueHandle {
    // Unique handle ID
    uint64_t id;
    // Version number for ABA problem prevention
    uint32_t version;
    // Handle type tag for runtime validation
    uint32_t type_tag;
} OpaqueHandle;

// Null handle constant
#define NULL_HANDLE (OpaqueHandle){ .id = 0, .version = 0, .type_tag = 0 }

// Success code
#define QKS_SUCCESS 0

// Error codes (negative values)
#define QKS_ERROR_GENERIC -1

#define QKS_ERROR_INVALID_HANDLE -2

#define QKS_ERROR_NULL_POINTER -3

#define QKS_ERROR_INVALID_CONFIG -4

#define QKS_ERROR_LAYER_NOT_INITIALIZED -5

#define QKS_ERROR_OUT_OF_MEMORY -7

#define QKS_ERROR_INTERNAL -8

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Create new tensor network quantum manager
//
// # Arguments
//
// * `num_physical_qubits` - Number of physical qubits (16-24)
// * `bond_dimension` - Maximum bond dimension χ (typically 32-64)
//
// # Returns
//
// Result containing the quantum manager handle
//
// # Example
// ```rust,ignore
// let manager = tensor_network_create(24, 64)?;
// println!("Created TN manager with 24 physical qubits");
// ```
struct TensorNetworkQuantumManager *tensor_network_create(uintptr_t num_physical_qubits,
                                                          uintptr_t bond_dimension);

// Get number of virtual qubits available
//
// # Arguments
//
// * `manager` - Tensor network manager handle
//
// # Returns
//
// Number of virtual qubits (typically 1000+)
//
// # Example
// ```rust,ignore
// let virtual_qubits = tensor_network_get_virtual_qubits(manager);
// println!("Virtual qubits: {}", virtual_qubits);
// ```
uintptr_t tensor_network_get_virtual_qubits(const struct TensorNetworkQuantumManager *manager);

// Apply single-qubit gate to virtual qubit
//
// # Arguments
//
// * `manager` - Tensor network manager handle
// * `qubit_index` - Virtual qubit index
// * `gate_type` - Gate type (0=X, 1=Y, 2=Z, 3=H, 4=S, 5=T)
//
// # Returns
//
// 0 on success, -1 on error
int32_t tensor_network_apply_single_qubit_gate(struct TensorNetworkQuantumManager *manager,
                                               uintptr_t qubit_index,
                                               uint32_t gate_type);

// Get bond dimension capacity
//
// # Arguments
//
// * `manager` - Tensor network manager handle
//
// # Returns
//
// Bond dimension χ
uintptr_t tensor_network_get_bond_dimension(const struct TensorNetworkQuantumManager *manager);

// Destroy tensor network manager
//
// # Arguments
//
// * `manager` - Tensor network manager handle
void tensor_network_destroy(struct TensorNetworkQuantumManager *manager);

// Create new temporal quantum reservoir
//
// # Arguments
//
// * `max_physical_qubits` - Maximum physical qubits to manage
// * `max_operations_per_band` - Operations per oscillatory band
//
// # Returns
//
// Result containing the reservoir handle
//
// # Example
// ```rust,ignore
// let reservoir = temporal_reservoir_create(24, 100)?;
// println!("Created temporal reservoir");
// ```
struct TemporalQuantumReservoir *temporal_reservoir_create(uintptr_t max_physical_qubits,
                                                           uintptr_t max_operations_per_band);

// Get oscillatory band frequency
//
// # Arguments
//
// * `band` - Band index (0=Gamma, 1=Beta, 2=Theta, 3=Delta)
//
// # Returns
//
// Frequency in Hz
double temporal_reservoir_get_band_frequency(uint32_t band);

// Schedule quantum operation in oscillatory band
//
// # Arguments
//
// * `reservoir` - Temporal reservoir handle
// * `band` - Band index (0=Gamma, 1=Beta, 2=Theta, 3=Delta)
// * `priority` - Operation priority (higher = more urgent)
//
// # Returns
//
// Operation ID on success, -1 on error
int64_t temporal_reservoir_schedule_operation(struct TemporalQuantumReservoir *reservoir,
                                              uint32_t band,
                                              uint32_t priority);

// Get context switch latency
//
// # Arguments
//
// * `reservoir` - Temporal reservoir handle
//
// # Returns
//
// Latency in microseconds
double temporal_reservoir_get_context_switch_latency(const struct TemporalQuantumReservoir *reservoir);

// Destroy temporal reservoir
//
// # Arguments
//
// * `reservoir` - Temporal reservoir handle
void temporal_reservoir_destroy(struct TemporalQuantumReservoir *reservoir);

// Create new compressed quantum state manager
//
// # Arguments
//
// * `num_qubits` - Number of qubits to manage
// * `target_fidelity` - Target fidelity (0.0-1.0, typically 0.999)
//
// # Returns
//
// Result containing the manager handle
//
// # Example
// ```rust,ignore
// let manager = compressed_state_create(7, 0.999)?;
// println!("Created compressed state manager");
// ```
struct CompressedQuantumStateManager *compressed_state_create(uintptr_t num_qubits,
                                                              double target_fidelity);

// Get compression ratio achieved
//
// # Arguments
//
// * `manager` - Compressed state manager handle
//
// # Returns
//
// Compression ratio (typically 1000:1)
double compressed_state_get_compression_ratio(const struct CompressedQuantumStateManager *manager);

// Get required measurements for target fidelity
//
// # Arguments
//
// * `num_qubits` - Number of qubits
// * `target_fidelity` - Target fidelity (0.0-1.0)
//
// # Returns
//
// Number of measurements required (K=127 for 7 qubits at 99.9%)
uintptr_t compressed_state_get_required_measurements(uintptr_t num_qubits, double target_fidelity);

// Compress quantum state using classical shadow tomography
//
// # Arguments
//
// * `manager` - Compressed state manager handle
//
// # Returns
//
// 0 on success, -1 on error
int32_t compressed_state_compress(struct CompressedQuantumStateManager *manager);

// Destroy compressed state manager
//
// # Arguments
//
// * `manager` - Compressed state manager handle
void compressed_state_destroy(struct CompressedQuantumStateManager *manager);

// Create new dynamic circuit knitter
//
// # Arguments
//
// * `max_qubits` - Maximum qubits per subcircuit
// * `strategy` - Knitting strategy (0=MinCut, 1=MaxParallelism, 2=Adaptive)
//
// # Returns
//
// Result containing the knitter handle
//
// # Example
// ```rust,ignore
// let knitter = circuit_knitter_create(16, 2)?;
// println!("Created circuit knitter");
// ```
struct DynamicCircuitKnitter *circuit_knitter_create(uintptr_t max_qubits, uint32_t strategy);

// Get achieved depth reduction
//
// # Arguments
//
// * `knitter` - Circuit knitter handle
//
// # Returns
//
// Depth reduction as percentage (0.0-1.0, typically 0.64-0.70)
double circuit_knitter_get_depth_reduction(const struct DynamicCircuitKnitter *knitter);

// Get number of wire cuts required
//
// # Arguments
//
// * `knitter` - Circuit knitter handle
//
// # Returns
//
// Number of wire cuts
uintptr_t circuit_knitter_get_wire_cuts(const struct DynamicCircuitKnitter *knitter);

// Decompose circuit into subcircuits
//
// # Arguments
//
// * `knitter` - Circuit knitter handle
//
// # Returns
//
// Number of subcircuits on success, -1 on error
int32_t circuit_knitter_decompose(struct DynamicCircuitKnitter *knitter);

// Destroy circuit knitter
//
// # Arguments
//
// * `knitter` - Circuit knitter handle
void circuit_knitter_destroy(struct DynamicCircuitKnitter *knitter);

// Initialize full quantum innovations system
//
// Creates all 4 quantum managers with default configurations
//
// # Returns
//
// 0 on success, -1 on error
//
// # Example
// ```rust,ignore
// if quantum_system_initialize() == 0 {
//     println!("Quantum system initialized successfully");
// }
// ```
int32_t quantum_system_initialize(void);

// Get quantum system status
//
// # Returns
//
// Status code (0=ready, 1=initializing, 2=error)
uint32_t quantum_system_get_status(void);

// Shutdown quantum innovations system
//
// Cleans up all quantum managers
//
// # Returns
//
// 0 on success, -1 on error
int32_t quantum_system_shutdown(void);

// Get performance metrics
//
// # Returns
//
// Performance metrics structure
struct QuantumPerformanceMetrics quantum_get_performance_metrics(void);

// Create a new QKS plugin instance with default configuration
//
// # Safety
// Returns a valid handle on success, NULL_HANDLE on failure
struct QksHandle qks_create(void);

// Create a new QKS plugin instance with custom configuration
//
// # Safety
// - `config` may be null (will use defaults)
// - Returns a valid handle on success, NULL_HANDLE on failure
struct QksHandle qks_create_with_config(const struct QksConfigParams *config);

// Destroy a QKS plugin instance
//
// # Safety
// - `handle` must be a valid handle from qks_create
// - After this call, the handle is invalid and must not be used
QksResult qks_destroy(struct QksHandle handle);

// Initialize the QKS plugin
//
// # Safety
// - `handle` must be a valid handle
QksResult qks_initialize(struct QksHandle handle);

// Start the QKS plugin
//
// # Safety
// - `handle` must be a valid, initialized handle
QksResult qks_start(struct QksHandle handle);

// Stop the QKS plugin
//
// # Safety
// - `handle` must be a valid handle
QksResult qks_stop(struct QksHandle handle);

// Process input data through the cognitive system
//
// # Safety
// - `handle` must be a valid, active handle
// - `input` must be a valid pointer to `input_len` bytes
// - `output` must be a valid pointer to buffer with `output_capacity` bytes
// - `output_len` will be set to actual output size
QksResult qks_process(struct QksHandle handle,
                      const uint8_t *input,
                      uintptr_t input_len,
                      uint8_t *output,
                      uintptr_t output_capacity,
                      uintptr_t *output_len);

// Get current Phi (consciousness) value
//
// # Safety
// - `handle` must be a valid handle
// - `phi` must be a valid pointer
QksResult qks_get_phi(struct QksHandle handle, double *phi);

// Get current plugin state
//
// # Safety
// - `handle` must be a valid handle
// - `state` must be a valid pointer
QksResult qks_get_state(struct QksHandle handle, struct QksState *state);

// Get last error message
//
// # Safety
// - Returns pointer to static string (do not free)
// - String is valid until next QKS call
const char *qks_get_error_message(void);

// Set a callback for a QKS plugin instance
//
// # Safety
// - `handle` must be a valid handle
// - `callback` must be a valid function pointer
// - `context` will be passed to callback (may be null)
QksResult qks_set_callback(struct QksHandle handle, QksCallback callback, void *context);

// Remove all callbacks for a handle
//
// # Safety
// - `handle` must be a valid handle
QksResult qks_clear_callbacks(struct QksHandle handle);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace qks
#endif  // __cplusplus

#endif  /* QKS_PLUGIN_H */
