//! # Leaky Integrate-and-Fire (LIF) Spiking Neuron Implementation
//!
//! This module implements biologically-inspired LIF spiking neurons with the following dynamics:
//! 
//! **Membrane Equation:**
//! τ_m dV/dt = -(V - V_rest) + R_m I(t)
//!
//! **Spike Generation:**
//! if V > V_threshold: spike generated, V reset to V_reset
//! 
//! **Refractory Period:**
//! After spike: neuron non-responsive for refractory_period_ms
//!
//! ## Energy Efficiency
//! 
//! - Target: ~45 pJ per spike
//! - Membrane time constant: 20ms (biologically realistic)
//! - Refractory period: 2ms
//! - Voltage thresholds: V_rest=-70mV, V_threshold=-55mV

use crate::neuromorphic::{NeuromorphicConfig, PerformanceMetrics};
use crate::{TengriError, Result};
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;
use std::time::{Duration, Instant};

/// Spike event generated by a neuron
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SpikeEvent {
    /// Neuron ID that generated the spike
    pub neuron_id: usize,
    
    /// Timestamp when spike occurred (in simulation time)
    pub timestamp_ms: f64,
    
    /// Membrane voltage at spike generation
    pub voltage_mv: f64,
    
    /// Energy consumed for this spike in picojoules
    pub energy_cost_pj: f64,
    
    /// Spike amplitude (typically 1.0)
    pub amplitude: f64,
}

impl SpikeEvent {
    /// Create a new spike event
    pub fn new(neuron_id: usize, timestamp_ms: f64, voltage_mv: f64, energy_cost_pj: f64) -> Self {
        Self {
            neuron_id,
            timestamp_ms,
            voltage_mv,
            energy_cost_pj,
            amplitude: 1.0,
        }
    }
}

/// Configuration parameters for a spiking neuron
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NeuronConfig {
    /// Membrane time constant in milliseconds (τ_m)
    pub tau_membrane_ms: f64,
    
    /// Membrane resistance in MΩ (R_m) 
    pub resistance_mohm: f64,
    
    /// Resting potential in mV (V_rest)
    pub v_rest_mv: f64,
    
    /// Spike threshold in mV (V_threshold)
    pub v_threshold_mv: f64,
    
    /// Reset potential in mV (V_reset) 
    pub v_reset_mv: f64,
    
    /// Absolute refractory period in ms
    pub refractory_period_ms: f64,
    
    /// Energy cost per spike in picojoules
    pub energy_per_spike_pj: f64,
    
    /// Membrane capacitance in pF (C_m)
    pub capacitance_pf: f64,
    
    /// Input current noise standard deviation in pA
    pub noise_std_pa: f64,
    
    /// Maximum input current in pA
    pub max_input_current_pa: f64,
}

impl Default for NeuronConfig {
    fn default() -> Self {
        Self {
            tau_membrane_ms: 20.0,      // 20ms membrane time constant
            resistance_mohm: 100.0,      // 100 MΩ membrane resistance  
            v_rest_mv: -70.0,           // -70mV resting potential
            v_threshold_mv: -55.0,      // -55mV spike threshold
            v_reset_mv: -70.0,          // -70mV reset potential
            refractory_period_ms: 2.0,  // 2ms refractory period
            energy_per_spike_pj: 45.0,  // 45pJ per spike target
            capacitance_pf: 200.0,      // 200pF membrane capacitance
            noise_std_pa: 5.0,          // 5pA current noise
            max_input_current_pa: 1000.0, // 1nA maximum input
        }
    }
}

impl NeuronConfig {
    /// Validate configuration parameters are biologically realistic
    pub fn validate(&self) -> Result<()> {
        if self.tau_membrane_ms <= 0.0 {
            return Err(TengriError::Config("Membrane time constant must be positive".to_string()));
        }
        
        if self.v_threshold_mv <= self.v_rest_mv {
            return Err(TengriError::Config("Threshold must be above resting potential".to_string()));
        }
        
        if self.v_reset_mv < self.v_rest_mv {
            return Err(TengriError::Config("Reset potential should not be below resting potential".to_string()));
        }
        
        if self.refractory_period_ms < 0.0 {
            return Err(TengriError::Config("Refractory period cannot be negative".to_string()));
        }
        
        if self.energy_per_spike_pj <= 0.0 {
            return Err(TengriError::Config("Energy per spike must be positive".to_string()));
        }
        
        Ok(())
    }
    
    /// Create configuration optimized for energy efficiency
    pub fn energy_optimized() -> Self {
        Self {
            energy_per_spike_pj: 30.0,  // Reduced energy target
            tau_membrane_ms: 15.0,      // Slightly faster membrane
            noise_std_pa: 2.0,          // Lower noise
            ..Default::default()
        }
    }
    
    /// Create configuration optimized for speed
    pub fn speed_optimized() -> Self {
        Self {
            tau_membrane_ms: 10.0,      // Faster membrane dynamics
            refractory_period_ms: 1.0,  // Shorter refractory period
            capacitance_pf: 100.0,      // Lower capacitance
            ..Default::default()
        }
    }
    
    /// Create configuration for high-frequency operation
    pub fn high_frequency() -> Self {
        Self {
            tau_membrane_ms: 5.0,       // Very fast membrane
            refractory_period_ms: 0.5,  // Very short refractory
            v_threshold_mv: -60.0,      // Lower threshold
            energy_per_spike_pj: 60.0,  // Higher energy for speed
            ..Default::default()
        }
    }
}

/// State of the spiking neuron
#[derive(Debug, Clone)]
pub struct NeuronState {
    /// Current membrane potential in mV
    pub voltage_mv: f64,
    
    /// Time since last spike in ms
    pub time_since_spike_ms: f64,
    
    /// Whether neuron is in refractory period
    pub is_refractory: bool,
    
    /// Total energy consumed in pJ
    pub total_energy_consumed_pj: f64,
    
    /// Number of spikes generated
    pub spike_count: u64,
    
    /// Current input current in pA
    pub input_current_pa: f64,
    
    /// Membrane conductance adaptation
    pub conductance_adaptation: f64,
}

impl Default for NeuronState {
    fn default() -> Self {
        Self {
            voltage_mv: -70.0,  // Start at resting potential
            time_since_spike_ms: 1000.0, // Well past refractory
            is_refractory: false,
            total_energy_consumed_pj: 0.0,
            spike_count: 0,
            input_current_pa: 0.0,
            conductance_adaptation: 1.0,
        }
    }
}

/// Leaky Integrate-and-Fire spiking neuron
#[derive(Debug, Clone)]
pub struct SpikingNeuron {
    /// Unique neuron identifier
    pub id: usize,
    
    /// Neuron configuration
    config: NeuronConfig,
    
    /// Current neuron state
    state: NeuronState,
    
    /// Spike history buffer
    spike_history: VecDeque<SpikeEvent>,
    
    /// Maximum spike history to keep
    max_history: usize,
    
    /// Random number generator for noise
    rng: fastrand::Rng,
    
    /// Performance tracking
    performance: PerformanceMetrics,
    
    /// Simulation timestep in ms
    dt_ms: f64,
}

impl SpikingNeuron {
    /// Create a new spiking neuron
    pub fn new(id: usize, config: NeuronConfig, dt_ms: f64) -> Result<Self> {
        config.validate()?;
        
        let mut state = NeuronState::default();
        state.voltage_mv = config.v_rest_mv;
        
        Ok(Self {
            id,
            config,
            state,
            spike_history: VecDeque::new(),
            max_history: 1000, // Keep last 1000 spikes
            rng: fastrand::Rng::new(),
            performance: PerformanceMetrics::default(),
            dt_ms,
        })
    }
    
    /// Create neuron with custom seed
    pub fn with_seed(id: usize, config: NeuronConfig, dt_ms: f64, seed: u64) -> Result<Self> {
        let mut neuron = Self::new(id, config, dt_ms)?;
        neuron.rng = fastrand::Rng::with_seed(seed);
        Ok(neuron)
    }
    
    /// Update neuron state for one timestep
    /// 
    /// Implements the LIF differential equation:
    /// τ_m dV/dt = -(V - V_rest) + R_m I(t)
    pub fn update(&mut self, input_current_pa: f64, current_time_ms: f64) -> Option<SpikeEvent> {
        let start_time = Instant::now();
        
        // Update input current with bounds checking
        self.state.input_current_pa = input_current_pa.clamp(-self.config.max_input_current_pa, 
                                                            self.config.max_input_current_pa);
        
        // Add noise to input current
        let noise = self.rng.f64() * self.config.noise_std_pa * 2.0 - self.config.noise_std_pa;
        let total_current = self.state.input_current_pa + noise;
        
        // Update time since last spike
        self.state.time_since_spike_ms += self.dt_ms;
        
        // Check if still in refractory period
        if self.state.time_since_spike_ms < self.config.refractory_period_ms {
            self.state.is_refractory = true;
            // During refractory period, voltage is clamped at reset
            self.state.voltage_mv = self.config.v_reset_mv;
            return None;
        } else {
            self.state.is_refractory = false;
        }
        
        // Calculate voltage derivative using LIF equation
        // dV/dt = -(V - V_rest) / τ_m + R_m * I / τ_m
        let voltage_diff = self.state.voltage_mv - self.config.v_rest_mv;
        let leak_term = -voltage_diff / self.config.tau_membrane_ms;
        let input_term = (self.config.resistance_mohm * total_current) / self.config.tau_membrane_ms;
        
        // Apply conductance adaptation
        let adapted_input = input_term * self.state.conductance_adaptation;
        
        let dv_dt = leak_term + adapted_input;
        
        // Integrate voltage using Euler method
        self.state.voltage_mv += dv_dt * self.dt_ms;
        
        // Check for spike generation
        if self.state.voltage_mv >= self.config.v_threshold_mv {
            let spike = self.generate_spike(current_time_ms);
            
            // Reset membrane potential
            self.state.voltage_mv = self.config.v_reset_mv;
            self.state.time_since_spike_ms = 0.0;
            self.state.spike_count += 1;
            
            // Update energy consumption
            self.state.total_energy_consumed_pj += self.config.energy_per_spike_pj;
            
            // Update conductance adaptation (simple spike-rate adaptation)
            self.state.conductance_adaptation *= 0.999; // Slight reduction after each spike
            
            // Track performance
            self.update_performance(start_time);
            
            Some(spike)
        } else {
            // Slowly recover conductance adaptation
            self.state.conductance_adaptation = (self.state.conductance_adaptation * 0.9995 + 1.0 * 0.0005)
                .clamp(0.1, 2.0);
            
            // Track performance for non-spike updates
            self.update_performance(start_time);
            
            None
        }
    }
    
    /// Generate a spike event
    fn generate_spike(&mut self, current_time_ms: f64) -> SpikeEvent {
        let spike = SpikeEvent::new(
            self.id,
            current_time_ms,
            self.state.voltage_mv,
            self.config.energy_per_spike_pj,
        );
        
        // Add to history
        self.spike_history.push_back(spike.clone());
        
        // Limit history size
        while self.spike_history.len() > self.max_history {
            self.spike_history.pop_front();
        }
        
        spike
    }
    
    /// Update performance metrics
    fn update_performance(&mut self, start_time: Instant) {
        let computation_time = start_time.elapsed();
        
        // Update latency tracking
        self.performance.inference_latency_us = computation_time.as_micros() as u64;
        
        // Update energy per spike
        if self.state.spike_count > 0 {
            self.performance.energy_per_spike_pj = 
                self.state.total_energy_consumed_pj / self.state.spike_count as f64;
        }
        
        // Update throughput (spikes per second)
        if computation_time.as_secs_f64() > 0.0 {
            let updates_per_second = 1.0 / computation_time.as_secs_f64();
            let spike_rate = if self.spike_history.len() >= 2 {
                self.calculate_firing_rate_hz()
            } else {
                0.0
            };
            self.performance.spike_throughput_sps = updates_per_second * spike_rate;
        }
        
        // Estimate memory usage
        let base_size = std::mem::size_of::<Self>();
        let history_size = self.spike_history.len() * std::mem::size_of::<SpikeEvent>();
        self.performance.memory_usage_bytes = base_size + history_size;
    }
    
    /// Calculate current firing rate in Hz
    pub fn calculate_firing_rate_hz(&self) -> f64 {
        if self.spike_history.len() < 2 {
            return 0.0;
        }
        
        let recent_spikes: Vec<_> = self.spike_history.iter()
            .rev()
            .take(10) // Look at last 10 spikes
            .collect();
        
        if recent_spikes.len() < 2 {
            return 0.0;
        }
        
        let time_window_s = (recent_spikes[0].timestamp_ms - 
                           recent_spikes[recent_spikes.len() - 1].timestamp_ms) / 1000.0;
        
        if time_window_s > 0.0 {
            (recent_spikes.len() - 1) as f64 / time_window_s
        } else {
            0.0
        }
    }
    
    /// Reset neuron to initial state
    pub fn reset(&mut self) {
        self.state = NeuronState::default();
        self.state.voltage_mv = self.config.v_rest_mv;
        self.spike_history.clear();
        self.performance = PerformanceMetrics::default();
    }
    
    /// Set input current directly
    pub fn set_input_current(&mut self, current_pa: f64) {
        self.state.input_current_pa = current_pa.clamp(-self.config.max_input_current_pa,
                                                       self.config.max_input_current_pa);
    }
    
    /// Get current neuron state
    pub fn state(&self) -> &NeuronState {
        &self.state
    }
    
    /// Get neuron configuration
    pub fn config(&self) -> &NeuronConfig {
        &self.config
    }
    
    /// Get spike history
    pub fn spike_history(&self) -> &VecDeque<SpikeEvent> {
        &self.spike_history
    }
    
    /// Get performance metrics
    pub fn performance(&self) -> &PerformanceMetrics {
        &self.performance
    }
    
    /// Check if neuron meets energy efficiency targets
    pub fn is_energy_efficient(&self) -> bool {
        self.performance.energy_per_spike_pj <= self.config.energy_per_spike_pj * 1.1
    }
    
    /// Get membrane time constant
    pub fn tau_membrane_ms(&self) -> f64 {
        self.config.tau_membrane_ms
    }
    
    /// Update configuration
    pub fn update_config(&mut self, config: NeuronConfig) -> Result<()> {
        config.validate()?;
        self.config = config;
        Ok(())
    }
    
    /// Calculate sub-threshold membrane dynamics
    pub fn sub_threshold_response(&self, input_current_pa: f64, duration_ms: f64) -> f64 {
        // Analytical solution for sub-threshold LIF response to constant current
        let steady_state = self.config.v_rest_mv + 
                          self.config.resistance_mohm * input_current_pa;
        
        let exponential_term = (-duration_ms / self.config.tau_membrane_ms).exp();
        let voltage_change = (steady_state - self.config.v_rest_mv) * (1.0 - exponential_term);
        
        self.config.v_rest_mv + voltage_change
    }
    
    /// Estimate recharge time to reach threshold
    pub fn time_to_threshold(&self, input_current_pa: f64) -> Option<f64> {
        if input_current_pa <= 0.0 {
            return None; // Won't reach threshold with non-positive current
        }
        
        let steady_state = self.config.v_rest_mv + 
                          self.config.resistance_mohm * input_current_pa;
        
        if steady_state <= self.config.v_threshold_mv {
            return None; // Steady state below threshold
        }
        
        // Time to reach threshold from current voltage
        let voltage_diff = self.config.v_threshold_mv - self.state.voltage_mv;
        let max_voltage_change = steady_state - self.state.voltage_mv;
        
        if max_voltage_change <= 0.0 {
            return None;
        }
        
        let ratio = voltage_diff / max_voltage_change;
        if ratio <= 0.0 || ratio >= 1.0 {
            return None;
        }
        
        Some(-self.config.tau_membrane_ms * (1.0 - ratio).ln())
    }
}

/// Neuron population for efficient batch processing
#[derive(Debug)]
pub struct NeuronPopulation {
    /// Vector of neurons
    neurons: Vec<SpikingNeuron>,
    
    /// Population-wide configuration
    config: NeuromorphicConfig,
    
    /// Simulation timestep
    dt_ms: f64,
    
    /// Current simulation time
    current_time_ms: f64,
}

impl NeuronPopulation {
    /// Create a new neuron population
    pub fn new(size: usize, neuron_config: NeuronConfig, 
               system_config: NeuromorphicConfig) -> Result<Self> {
        let mut neurons = Vec::with_capacity(size);
        let dt_ms = system_config.timestep_ms;
        
        for i in 0..size {
            let seed = system_config.seed.unwrap_or(0) + i as u64;
            neurons.push(SpikingNeuron::with_seed(i, neuron_config.clone(), dt_ms, seed)?);
        }
        
        Ok(Self {
            neurons,
            config: system_config,
            dt_ms,
            current_time_ms: 0.0,
        })
    }
    
    /// Update all neurons in parallel
    pub fn update_parallel(&mut self, input_currents: &[f64]) -> Vec<Option<SpikeEvent>> {
        assert_eq!(input_currents.len(), self.neurons.len());
        
        use rayon::prelude::*;
        
        let current_time = self.current_time_ms;
        let results: Vec<_> = self.neurons.par_iter_mut()
            .zip(input_currents.par_iter())
            .map(|(neuron, &current)| neuron.update(current, current_time))
            .collect();
        
        self.current_time_ms += self.dt_ms;
        results
    }
    
    /// Update all neurons sequentially
    pub fn update_sequential(&mut self, input_currents: &[f64]) -> Vec<Option<SpikeEvent>> {
        assert_eq!(input_currents.len(), self.neurons.len());
        
        let mut results = Vec::with_capacity(self.neurons.len());
        
        for (neuron, &current) in self.neurons.iter_mut().zip(input_currents.iter()) {
            results.push(neuron.update(current, self.current_time_ms));
        }
        
        self.current_time_ms += self.dt_ms;
        results
    }
    
    /// Get population firing rate
    pub fn population_firing_rate(&self) -> f64 {
        let total_rate: f64 = self.neurons.iter()
            .map(|n| n.calculate_firing_rate_hz())
            .sum();
        
        total_rate / self.neurons.len() as f64
    }
    
    /// Get population energy consumption
    pub fn total_energy_consumption(&self) -> f64 {
        self.neurons.iter()
            .map(|n| n.state.total_energy_consumed_pj)
            .sum()
    }
    
    /// Get neuron by ID
    pub fn get_neuron(&self, id: usize) -> Option<&SpikingNeuron> {
        self.neurons.get(id)
    }
    
    /// Get mutable neuron by ID
    pub fn get_neuron_mut(&mut self, id: usize) -> Option<&mut SpikingNeuron> {
        self.neurons.get_mut(id)
    }
    
    /// Get population size
    pub fn size(&self) -> usize {
        self.neurons.len()
    }
    
    /// Reset entire population
    pub fn reset(&mut self) {
        for neuron in &mut self.neurons {
            neuron.reset();
        }
        self.current_time_ms = 0.0;
    }
    
    /// Get current simulation time
    pub fn current_time_ms(&self) -> f64 {
        self.current_time_ms
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;
    
    #[test]
    fn test_neuron_config_validation() {
        let mut config = NeuronConfig::default();
        assert!(config.validate().is_ok());
        
        // Test invalid threshold
        config.v_threshold_mv = -80.0; // Below resting potential
        assert!(config.validate().is_err());
        
        // Test invalid time constant
        config = NeuronConfig::default();
        config.tau_membrane_ms = -1.0;
        assert!(config.validate().is_err());
    }
    
    #[test]
    fn test_spike_event_creation() {
        let spike = SpikeEvent::new(0, 10.0, -55.0, 45.0);
        assert_eq!(spike.neuron_id, 0);
        assert_eq!(spike.timestamp_ms, 10.0);
        assert_eq!(spike.voltage_mv, -55.0);
        assert_eq!(spike.energy_cost_pj, 45.0);
        assert_eq!(spike.amplitude, 1.0);
    }
    
    #[test]
    fn test_neuron_creation() {
        let config = NeuronConfig::default();
        let neuron = SpikingNeuron::new(0, config, 0.1).unwrap();
        
        assert_eq!(neuron.id, 0);
        assert_eq!(neuron.state.voltage_mv, -70.0); // Resting potential
        assert!(!neuron.state.is_refractory);
        assert_eq!(neuron.state.spike_count, 0);
    }
    
    #[test]
    fn test_neuron_update_no_spike() {
        let config = NeuronConfig::default();
        let mut neuron = SpikingNeuron::new(0, config, 0.1).unwrap();
        
        // Apply small current that shouldn't cause spike
        let spike = neuron.update(10.0, 0.1); // 10 pA current
        assert!(spike.is_none());
        
        // Voltage should increase slightly from resting
        assert!(neuron.state.voltage_mv > -70.0);
        assert!(neuron.state.voltage_mv < -55.0); // Below threshold
    }
    
    #[test]
    fn test_neuron_spike_generation() {
        let config = NeuronConfig::default();
        let mut neuron = SpikingNeuron::new(0, config, 0.1).unwrap();
        
        // Apply large current to force spike
        let mut spike_generated = false;
        for i in 0..1000 { // Run for up to 100ms
            let spike = neuron.update(1000.0, i as f64 * 0.1); // 1 nA current
            if spike.is_some() {
                spike_generated = true;
                let s = spike.unwrap();
                assert_eq!(s.neuron_id, 0);
                assert_eq!(s.energy_cost_pj, 45.0);
                assert!(s.timestamp_ms >= 0.0);
                break;
            }
        }
        
        assert!(spike_generated, "Neuron should have generated a spike with large input");
        assert_eq!(neuron.state.spike_count, 1);
        assert!(neuron.state.total_energy_consumed_pj > 0.0);
    }
    
    #[test]
    fn test_refractory_period() {
        let config = NeuronConfig::default();
        let mut neuron = SpikingNeuron::new(0, config, 0.1).unwrap();
        
        // Force a spike
        let mut first_spike_time = 0.0;
        for i in 0..1000 {
            let time = i as f64 * 0.1;
            if let Some(spike) = neuron.update(1000.0, time) {
                first_spike_time = spike.timestamp_ms;
                break;
            }
        }
        
        // During refractory period, no spikes should occur
        for i in 1..30 { // 3ms after first spike (> 2ms refractory)
            let time = first_spike_time + i as f64 * 0.1;
            let spike = neuron.update(1000.0, time);
            
            if time - first_spike_time < 2.0 {
                // Should be in refractory period
                assert!(spike.is_none(), "No spike during refractory period");
                assert!(neuron.state.is_refractory || 
                       neuron.state.time_since_spike_ms < 2.0);
            }
        }
    }
    
    #[test]
    fn test_sub_threshold_dynamics() {
        let config = NeuronConfig::default();
        let neuron = SpikingNeuron::new(0, config.clone(), 0.1).unwrap();
        
        // Test sub-threshold response
        let input_current = 50.0; // pA
        let duration = 10.0; // ms
        
        let final_voltage = neuron.sub_threshold_response(input_current, duration);
        
        // Should be between resting and steady-state
        let steady_state = config.v_rest_mv + config.resistance_mohm * input_current;
        assert!(final_voltage > config.v_rest_mv);
        assert!(final_voltage < steady_state);
    }
    
    #[test]  
    fn test_time_to_threshold() {
        let config = NeuronConfig::default();
        let neuron = SpikingNeuron::new(0, config.clone(), 0.1).unwrap();
        
        // Large current should give finite time to threshold
        let time_opt = neuron.time_to_threshold(500.0);
        assert!(time_opt.is_some());
        let time = time_opt.unwrap();
        assert!(time > 0.0);
        assert!(time < 100.0); // Should be reasonable
        
        // Small current shouldn't reach threshold
        let time_opt = neuron.time_to_threshold(1.0);
        assert!(time_opt.is_none());
    }
    
    #[test]
    fn test_energy_efficiency() {
        let config = NeuronConfig::energy_optimized();
        let mut neuron = SpikingNeuron::new(0, config, 0.1).unwrap();
        
        // Generate some spikes
        for i in 0..100 {
            neuron.update(200.0, i as f64 * 0.1);
        }
        
        if neuron.state.spike_count > 0 {
            assert!(neuron.is_energy_efficient());
            assert!(neuron.performance.energy_per_spike_pj <= 35.0); // Below 30pJ + margin
        }
    }
    
    #[test]
    fn test_neuron_population() {
        let neuron_config = NeuronConfig::default();
        let system_config = NeuromorphicConfig::default();
        
        let mut population = NeuronPopulation::new(10, neuron_config, system_config).unwrap();
        
        assert_eq!(population.size(), 10);
        assert_eq!(population.current_time_ms(), 0.0);
        
        // Test population update
        let inputs = vec![100.0; 10]; // 100 pA to each neuron
        let spikes = population.update_sequential(&inputs);
        assert_eq!(spikes.len(), 10);
        
        assert!(population.current_time_ms() > 0.0);
    }
    
    #[test]
    fn test_firing_rate_calculation() {
        let config = NeuronConfig::speed_optimized();
        let mut neuron = SpikingNeuron::new(0, config, 0.1).unwrap();
        
        // Generate multiple spikes
        for i in 0..500 {
            neuron.update(800.0, i as f64 * 0.1);
        }
        
        if neuron.spike_history.len() >= 2 {
            let firing_rate = neuron.calculate_firing_rate_hz();
            assert!(firing_rate >= 0.0);
            assert!(firing_rate < 1000.0); // Reasonable upper bound
        }
    }
    
    #[test]
    fn test_conductance_adaptation() {
        let config = NeuronConfig::default();
        let mut neuron = SpikingNeuron::new(0, config, 0.1).unwrap();
        
        let initial_adaptation = neuron.state.conductance_adaptation;
        
        // Generate spikes to trigger adaptation
        for i in 0..1000 {
            neuron.update(500.0, i as f64 * 0.1);
        }
        
        // Adaptation should change from initial value
        if neuron.state.spike_count > 10 {
            // With many spikes, adaptation should decrease
            assert!(neuron.state.conductance_adaptation < initial_adaptation);
        }
    }
    
    #[test]
    fn test_membrane_equation_integration() {
        let config = NeuronConfig::default();
        let mut neuron = SpikingNeuron::new(0, config.clone(), 0.01).unwrap(); // Small timestep
        
        // Apply constant current and check voltage evolution
        let current = 200.0; // pA
        let mut voltages = Vec::new();
        
        for i in 0..1000 {
            neuron.update(current, i as f64 * 0.01);
            voltages.push(neuron.state.voltage_mv);
            
            // Break if spike occurs
            if neuron.state.spike_count > 0 {
                break;
            }
        }
        
        // Voltage should increase monotonically toward steady state (if no spike)
        if voltages.len() > 10 && neuron.state.spike_count == 0 {
            let start_voltage = voltages[10];
            let end_voltage = voltages[voltages.len() - 1];
            assert!(end_voltage > start_voltage, "Voltage should increase with positive current");
            
            // Should approach steady state exponentially
            let steady_state = config.v_rest_mv + config.resistance_mohm * current;
            assert!(end_voltage < steady_state, "Should approach but not exceed steady state");
        }
    }
}