//! Formal verification tests generated by Wolfram
//!
//! These test vectors were computed using WolframScript to verify
//! the mathematical correctness of HyperPhysics geometry algorithms.
//!
//! Generated: 2025-12-06

use hyperphysics_geometry::poincare::PoincarePoint;
use nalgebra as na;

const EPSILON: f64 = 1e-10;

/// Wolfram-verified test vectors for Poincaré disk hyperbolic distance
/// Formula: d_H(p,q) = acosh(1 + 2||p-q||² / ((1-||p||²)(1-||q||²)))
#[test]
fn test_poincare_distance_wolfram_verified() {
    let test_cases = [
        // (p, q, expected_distance, expected_conformal_p)
        ([0.0, 0.0, 0.0], [0.5, 0.0, 0.0], 1.0986122886681096, 2.0),
        ([0.3, 0.2, 0.0], [-0.1, 0.4, 0.0], 1.0091848294205448, 2.2988505747126435),
        ([0.1, 0.1, 0.1], [0.2, -0.2, 0.3], 0.8115509695219986, 2.061855670103093),
        ([0.5, 0.5, 0.0], [-0.5, 0.5, 0.0], 2.887270950357621, 4.0),
        ([0.9, 0.0, 0.0], [0.8, 0.0, 0.0], 0.7472144018302214, 10.526315789473687),
    ];

    for (p_coords, q_coords, expected_dist, expected_conformal) in test_cases {
        let p = PoincarePoint::new(na::Vector3::new(p_coords[0], p_coords[1], p_coords[2])).unwrap();
        let q = PoincarePoint::new(na::Vector3::new(q_coords[0], q_coords[1], q_coords[2])).unwrap();

        let dist = p.hyperbolic_distance(&q);
        let conformal = p.conformal_factor();

        assert!(
            (dist - expected_dist).abs() < 1e-8,
            "Distance mismatch for p={:?}, q={:?}: got {}, expected {}",
            p_coords, q_coords, dist, expected_dist
        );

        assert!(
            (conformal - expected_conformal).abs() < 1e-8,
            "Conformal factor mismatch for p={:?}: got {}, expected {}",
            p_coords, conformal, expected_conformal
        );
    }
}

/// Verify Möbius addition properties (Wolfram-verified)
#[test]
fn test_mobius_addition_properties() {
    let p = PoincarePoint::new(na::Vector3::new(0.3, 0.2, 0.1)).unwrap();
    let q = PoincarePoint::new(na::Vector3::new(0.1, -0.2, 0.15)).unwrap();
    let zero = PoincarePoint::origin();

    // Property 1: p ⊕ 0 = p (identity)
    let result_identity = p.mobius_add(&zero).unwrap();
    assert!(
        (result_identity.coords() - p.coords()).norm() < EPSILON,
        "Möbius identity failed"
    );

    // Property 2: Result stays in disk
    let result = p.mobius_add(&q).unwrap();
    assert!(
        result.norm() < 1.0,
        "Möbius addition left disk: norm = {}",
        result.norm()
    );

    // Expected result from Wolfram: {0.40263687, 0.04362104, 0.23256384}
    let expected = na::Vector3::new(0.40263686712738317, 0.043621036122138905, 0.23256383865117872);
    assert!(
        (result.coords() - expected).norm() < 1e-8,
        "Möbius result mismatch: got {:?}, expected {:?}",
        result.coords(),
        expected
    );
}

/// Verify triangle inequality (fundamental metric property)
#[test]
fn test_triangle_inequality_wolfram_verified() {
    let points = [
        PoincarePoint::new(na::Vector3::new(0.2, 0.0, 0.0)).unwrap(),
        PoincarePoint::new(na::Vector3::new(0.0, 0.3, 0.0)).unwrap(),
        PoincarePoint::new(na::Vector3::new(0.0, 0.0, 0.4)).unwrap(),
    ];

    for i in 0..3 {
        for j in 0..3 {
            for k in 0..3 {
                if i != j && j != k && i != k {
                    let d_ij = points[i].hyperbolic_distance(&points[j]);
                    let d_jk = points[j].hyperbolic_distance(&points[k]);
                    let d_ik = points[i].hyperbolic_distance(&points[k]);

                    assert!(
                        d_ik <= d_ij + d_jk + EPSILON,
                        "Triangle inequality violated: d({},{}) = {} > d({},{}) + d({},{}) = {} + {}",
                        i, k, d_ik, i, j, j, k, d_ij, d_jk
                    );
                }
            }
        }
    }
}

/// Verify distance symmetry
#[test]
fn test_distance_symmetry() {
    let test_pairs = [
        ([0.3, 0.0, 0.0], [0.0, 0.5, 0.0]),
        ([0.1, 0.2, 0.3], [-0.2, 0.1, -0.1]),
        ([0.8, 0.0, 0.0], [0.7, 0.1, 0.0]),
    ];

    for (p_coords, q_coords) in test_pairs {
        let p = PoincarePoint::new(na::Vector3::new(p_coords[0], p_coords[1], p_coords[2])).unwrap();
        let q = PoincarePoint::new(na::Vector3::new(q_coords[0], q_coords[1], q_coords[2])).unwrap();

        let d_pq = p.hyperbolic_distance(&q);
        let d_qp = q.hyperbolic_distance(&p);

        assert!(
            (d_pq - d_qp).abs() < EPSILON,
            "Distance not symmetric: d(p,q)={}, d(q,p)={}",
            d_pq, d_qp
        );
    }
}
