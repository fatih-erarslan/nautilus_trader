//! {7,3} Hyperbolic Tessellation Implementation
//!
//! Implements the {7,3} tessellation: 3 heptagonal (7-sided) tiles meeting at each vertex.
//! This is the cryptographic substrate for Dilithium integration as specified in pbRTCA v3.1.
//!
//! # Mathematics
//!
//! The {7,3} tessellation is a regular hyperbolic tessellation where:
//! - Each tile is a regular heptagon (7 sides)
//! - Exactly 3 tiles meet at each vertex
//! - Satisfies hyperbolic condition: (7-2)(3-2) = 5 > 4
//!
//! # References
//!
//! - Cannon et al. (1997) "Hyperbolic Geometry", Chapter 3
//! - Kollár et al. (2019) "Hyperbolic lattices in circuit QED" Nature 571:45-50
//! - pbRTCA v3.1 Blueprint: "Dilithium-Crystal Lattice Cryptography"

use crate::{poincare::PoincarePoint, GeometryError, Result};
use crate::{MoebiusTransform, FuchsianGroupAlgebraic};
use nalgebra as na;
use num_complex::Complex64;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::f64::consts::PI;

/// Unique identifier for a heptagonal tile
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileId(pub usize);

/// Unique identifier for a tessellation vertex
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct VertexId(pub usize);

/// A heptagonal (7-sided) tile in the {7,3} tessellation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HeptagonalTile {
    /// Unique identifier for this tile
    pub id: TileId,

    /// Center point of the heptagon in Poincaré disk
    pub center: PoincarePoint,

    /// 7 vertices of the heptagon (ordered counterclockwise)
    pub vertices: [PoincarePoint; 7],

    /// IDs of the 7 neighboring tiles (one per edge, None if at boundary)
    pub neighbors: [Option<TileId>; 7],

    /// Edge lengths (hyperbolic distance between consecutive vertices)
    pub edge_lengths: [f64; 7],

    /// Generation layer (0 = central tile)
    pub layer: usize,
}

/// A vertex in the {7,3} tessellation where exactly 3 tiles meet
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TessellationVertex {
    /// Unique identifier for this vertex
    pub id: VertexId,

    /// Position in Poincaré disk
    pub position: PoincarePoint,

    /// Exactly 3 tiles incident to this vertex (required by {7,3} constraint)
    pub incident_tiles: [TileId; 3],

    /// Angles between incident tiles at this vertex
    pub angles: [f64; 3],
}

/// Fuchsian group generators for {7,3} tessellation
///
/// The {7,3} tessellation has a fundamental domain bounded by geodesics.
/// The Fuchsian group is generated by reflections in these geodesic sides.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FuchsianGroup {
    /// Reflection matrices for the 7 sides of the fundamental heptagon
    generators: Vec<na::Matrix4<f64>>,

    /// Cached products of generators for efficient computation
    product_cache: HashMap<Vec<usize>, na::Matrix4<f64>>,
}

impl FuchsianGroup {
    /// Create Fuchsian group for {7,3} tessellation
    pub fn new_for_73() -> Self {
        let generators = Self::compute_reflection_generators();

        Self {
            generators,
            product_cache: HashMap::new(),
        }
    }

    /// Compute the 7 reflection generators for a regular heptagon
    fn compute_reflection_generators() -> Vec<na::Matrix4<f64>> {
        let mut generators = Vec::with_capacity(7);

        // Angle for each reflection (2π/7 radians apart)
        let angle_step = 2.0 * PI / 7.0;

        for i in 0..7 {
            let angle = i as f64 * angle_step;

            // For {7,3} tessellation, compute hyperbolic reflection across edge midpoint
            // The reflection inverts across a circle (geodesic in Poincaré model)

            // Normal vector to the reflection line (pointing outward from center)
            let nx = angle.cos();
            let ny = angle.sin();

            // Hyperbolic reflection matrix in Poincaré disk model
            // R = I - 2nn^T where n is the unit normal
            let reflection = na::Matrix4::new(
                1.0 - 2.0 * nx * nx, -2.0 * nx * ny, 0.0, 0.0,
                -2.0 * ny * nx, 1.0 - 2.0 * ny * ny, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0,
            );

            generators.push(reflection);
        }

        generators
    }

    /// Apply generator i to a point
    pub fn apply_generator(&self, i: usize, point: &PoincarePoint) -> Result<PoincarePoint> {
        if i >= self.generators.len() {
            return Err(GeometryError::InvalidTessellation {
                message: format!("Generator index {} out of range", i),
            });
        }

        let coords = point.coords();
        let homogeneous = na::Vector4::new(coords.x, coords.y, coords.z, 1.0);
        let transformed = self.generators[i] * homogeneous;

        let new_coords = na::Vector3::new(
            transformed.x / transformed.w,
            transformed.y / transformed.w,
            transformed.z / transformed.w,
        );

        PoincarePoint::new(new_coords)
    }
}

/// {7,3} Hyperbolic Tessellation
///
/// A regular tessellation where 3 heptagonal tiles meet at each vertex.
/// This serves as the cryptographic substrate for Dilithium integration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HeptagonalTessellation {
    /// All heptagonal tiles in the tessellation
    tiles: Vec<HeptagonalTile>,

    /// All vertices where 3 tiles meet
    vertices: Vec<TessellationVertex>,

    /// Fuchsian group generators for tessellation symmetry (matrix-based)
    fuchsian_group: FuchsianGroup,

    /// Algebraic Fuchsian group (Möbius transformations) for exact placement
    ///
    /// This provides exact hyperbolic isometries via PSU(1,1) group actions.
    /// When present, enables algebraically exact tile generation.
    #[serde(skip)]
    algebraic_group: Option<FuchsianGroupAlgebraic>,

    /// Maximum number of layers to generate
    max_depth: usize,

    /// Characteristic edge length for {7,3}
    edge_length: f64,
}

impl HeptagonalTessellation {
    /// Create new {7,3} tessellation up to specified depth
    ///
    /// # Arguments
    ///
    /// * `depth` - Number of layers to generate (0 = central tile only)
    ///
    /// # Returns
    ///
    /// A {7,3} tessellation with approximately 1 + 7 + 7*6 + ... tiles
    ///
    /// # Examples
    ///
    /// ```
    /// use hyperphysics_geometry::tessellation_73::HeptagonalTessellation;
    ///
    /// // Generate tessellation with 0 layers (central tile only)
    /// let tess = HeptagonalTessellation::new(0)?;
    /// assert_eq!(tess.num_tiles(), 1); // Central tile
    /// assert_eq!(tess.tiles()[0].vertices.len(), 7); // Heptagon has 7 vertices
    /// # Ok::<(), hyperphysics_geometry::GeometryError>(())
    /// ```
    pub fn new(depth: usize) -> Result<Self> {
        let edge_length = Self::calculate_edge_length();
        let fuchsian_group = FuchsianGroup::new_for_73();

        let mut tess = Self {
            tiles: Vec::new(),
            vertices: Vec::new(),
            fuchsian_group,
            algebraic_group: None,
            max_depth: depth,
            edge_length,
        };

        tess.generate()?;
        tess.build_vertices()?;

        Ok(tess)
    }

    /// Create new {7,3} tessellation using algebraic Fuchsian groups
    ///
    /// This constructor uses Möbius transformations from the algebraic
    /// Fuchsian group implementation for exact hyperbolic isometries.
    ///
    /// # Arguments
    ///
    /// * `depth` - Number of layers to generate (0 = central tile only)
    ///
    /// # Returns
    ///
    /// A {7,3} tessellation with exact algebraic placement
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use hyperphysics_geometry::tessellation_73::HeptagonalTessellation;
    ///
    /// // Generate tessellation with exact algebraic placement
    /// let tess = HeptagonalTessellation::new_with_algebraic(1)?;
    /// # Ok::<(), hyperphysics_geometry::GeometryError>(())
    /// ```
    pub fn new_with_algebraic(depth: usize) -> Result<Self> {
        let edge_length = Self::calculate_edge_length();
        let fuchsian_group = FuchsianGroup::new_for_73();

        // Create algebraic Fuchsian group for {7,3}
        let mut algebraic_group = FuchsianGroupAlgebraic::from_tessellation(7, 3)?;
        algebraic_group.generate_elements(4); // Pre-generate group elements

        let mut tess = Self {
            tiles: Vec::new(),
            vertices: Vec::new(),
            fuchsian_group,
            algebraic_group: Some(algebraic_group),
            max_depth: depth,
            edge_length,
        };

        tess.generate()?;
        tess.build_vertices()?;

        Ok(tess)
    }

    /// Get the algebraic Fuchsian group if available
    pub fn algebraic_group(&self) -> Option<&FuchsianGroupAlgebraic> {
        self.algebraic_group.as_ref()
    }

    /// Convert PoincarePoint to Complex64 (2D projection)
    #[allow(dead_code)] // Reserved for future Möbius transformation integration
    fn poincare_to_complex(point: &PoincarePoint) -> Complex64 {
        let coords = point.coords();
        Complex64::new(coords.x, coords.y)
    }

    /// Convert Complex64 to PoincarePoint (z = 0 plane)
    fn complex_to_poincare(z: Complex64) -> Result<PoincarePoint> {
        let coords = na::Vector3::new(z.re, z.im, 0.0);
        PoincarePoint::new(coords)
    }

    /// Apply a Möbius transformation to a PoincarePoint
    #[allow(dead_code)] // Reserved for future Möbius transformation integration
    fn apply_moebius(transform: &MoebiusTransform, point: &PoincarePoint) -> Result<PoincarePoint> {
        let z = Self::poincare_to_complex(point);
        let transformed_z = transform.apply(z);
        Self::complex_to_poincare(transformed_z)
    }

    /// Generate exact orbit of central tile using algebraic Fuchsian group
    ///
    /// This demonstrates the algebraic approach: apply group elements to
    /// the central tile to generate exact tile positions.
    ///
    /// # Returns
    ///
    /// Vector of tile centers in the orbit of the central tile
    pub fn generate_exact_orbit(&self, max_tiles: usize) -> Result<Vec<PoincarePoint>> {
        let algebraic_group = self.algebraic_group.as_ref()
            .ok_or_else(|| GeometryError::InvalidTessellation {
                message: "Algebraic Fuchsian group not initialized".to_string(),
            })?;

        // Start with central tile at origin
        let central_center = Complex64::new(0.0, 0.0);

        // Generate orbit under group action
        let orbit = algebraic_group.orbit(central_center, max_tiles);

        // Convert Complex64 points to PoincarePoints
        orbit.iter()
            .map(|&z| Self::complex_to_poincare(z))
            .collect()
    }

    /// Calculate characteristic edge length for {7,3} tessellation
    ///
    /// Formula: sinh(r) = cos(π/3) / sin(π/7)
    fn calculate_edge_length() -> f64 {
        // {7,3}: p=7 (heptagon), q=3 (3 tiles per vertex)
        let sinh_r = (PI / 3.0).cos() / (PI / 7.0).sin();
        sinh_r.asinh()
    }

    /// Generate all heptagonal tiles up to max_depth
    fn generate(&mut self) -> Result<()> {
        // Create central tile at origin
        let central_tile = self.create_central_tile()?;
        self.tiles.push(central_tile);

        // Generate subsequent layers using Fuchsian group reflections
        for layer in 1..=self.max_depth {
            self.generate_layer(layer)?;
        }

        Ok(())
    }

    /// Create the central heptagonal tile at the origin
    fn create_central_tile(&self) -> Result<HeptagonalTile> {
        let center = PoincarePoint::origin();
        let mut vertices = [PoincarePoint::origin(); 7];

        // Place 7 vertices around the center at distance edge_length
        for i in 0..7 {
            let angle = 2.0 * PI * (i as f64) / 7.0;
            let r = self.edge_length.tanh().min(0.95); // Ensure inside disk
            vertices[i] = PoincarePoint::from_spherical(r, angle, PI / 2.0)?;
        }

        // Calculate edge lengths (should be approximately uniform)
        let mut edge_lengths = [0.0; 7];
        for i in 0..7 {
            let next = (i + 1) % 7;
            edge_lengths[i] = vertices[i].hyperbolic_distance(&vertices[next]);
        }

        Ok(HeptagonalTile {
            id: TileId(0),
            center,
            vertices,
            neighbors: [None; 7], // Will be filled during layer generation
            edge_lengths,
            layer: 0,
        })
    }

    /// Generate all tiles at a specific layer
    fn generate_layer(&mut self, layer: usize) -> Result<()> {
        // For each tile in the previous layer, generate neighbors
        let prev_layer_tiles: Vec<TileId> = self.tiles
            .iter()
            .filter(|t| t.layer == layer - 1)
            .map(|t| t.id)
            .collect();

        for tile_id in prev_layer_tiles {
            self.generate_neighbors(tile_id, layer)?;
        }

        Ok(())
    }

    /// Generate neighbor tiles for a given tile
    fn generate_neighbors(&mut self, tile_id: TileId, layer: usize) -> Result<()> {
        // Get the parent tile
        let parent_tile = self.tiles.iter()
            .find(|t| t.id == tile_id)
            .ok_or_else(|| GeometryError::InvalidTessellation {
                message: format!("Tile {:?} not found", tile_id),
            })?
            .clone();

        // Generate neighbors by placing tiles across each edge
        for edge_idx in 0..7 {
            // Skip if neighbor already exists
            if parent_tile.neighbors[edge_idx].is_some() {
                continue;
            }

            // Get the two vertices of this edge
            let v1 = parent_tile.vertices[edge_idx];
            let v2 = parent_tile.vertices[(edge_idx + 1) % 7];

            // Calculate midpoint of edge (approximate geodesic midpoint)
            let edge_mid_coords = (v1.coords() + v2.coords()) * 0.5;

            // Direction from parent center to edge midpoint (outward normal)
            let direction = edge_mid_coords - parent_tile.center.coords();
            let direction_normalized = direction.normalize();

            // Place new tile center beyond the edge
            // In hyperbolic space, we move outward by approximately the edge length
            let displacement = direction_normalized * (self.edge_length * 0.8);
            let new_center_coords = parent_tile.center.coords() + displacement;

            // Normalize to stay within Poincaré disk
            let new_center_coords_normalized = if new_center_coords.norm() >= 0.98 {
                new_center_coords * 0.95 / new_center_coords.norm()
            } else {
                new_center_coords
            };

            let new_center = PoincarePoint::new(new_center_coords_normalized)?;

            // Check if this tile already exists (within tolerance)
            let existing_tile = self.find_tile_by_center(&new_center, 0.1);

            let neighbor_id = if let Some(existing_id) = existing_tile {
                // Tile already exists, just update neighbor references
                existing_id
            } else {
                // Create new tile with vertices arranged around new center
                let mut new_vertices = [PoincarePoint::origin(); 7];
                let angle_step = 2.0 * PI / 7.0;

                // Rotate to align with parent tile
                let base_angle = direction.y.atan2(direction.x);

                for i in 0..7 {
                    let angle = base_angle + (i as f64) * angle_step;
                    let r = self.edge_length.tanh().min(0.95);
                    let vertex_local = na::Vector3::new(
                        r * angle.cos(),
                        r * angle.sin(),
                        0.0,
                    );
                    let vertex_coords = new_center_coords_normalized + vertex_local * 0.3;

                    // Ensure inside disk
                    let vertex_coords_safe = if vertex_coords.norm() >= 0.98 {
                        vertex_coords * 0.95 / vertex_coords.norm()
                    } else {
                        vertex_coords
                    };

                    new_vertices[i] = PoincarePoint::new(vertex_coords_safe)?;
                }

                // Calculate edge lengths
                let mut edge_lengths = [0.0; 7];
                for i in 0..7 {
                    let next = (i + 1) % 7;
                    edge_lengths[i] = new_vertices[i].hyperbolic_distance(&new_vertices[next]);
                }

                let new_id = TileId(self.tiles.len());
                let new_tile = HeptagonalTile {
                    id: new_id,
                    center: new_center,
                    vertices: new_vertices,
                    neighbors: [None; 7],
                    edge_lengths,
                    layer,
                };

                self.tiles.push(new_tile);
                new_id
            };

            // Update neighbor references (bidirectional)
            self.update_neighbor_reference(tile_id, edge_idx, neighbor_id)?;

            // For simplicity, update one reciprocal edge (opposite side of heptagon)
            let reciprocal_edge = (edge_idx + 4) % 7; // Approximate opposite edge
            self.update_neighbor_reference(neighbor_id, reciprocal_edge, tile_id)?;
        }

        Ok(())
    }

    /// Find a tile by its center position (within tolerance)
    fn find_tile_by_center(&self, center: &PoincarePoint, tolerance: f64) -> Option<TileId> {
        for tile in &self.tiles {
            if tile.center.distance(center) < tolerance {
                return Some(tile.id);
            }
        }
        None
    }

    /// Update neighbor reference for a tile
    fn update_neighbor_reference(&mut self, tile_id: TileId, edge_idx: usize, neighbor_id: TileId) -> Result<()> {
        let tile = self.tiles.iter_mut()
            .find(|t| t.id == tile_id)
            .ok_or_else(|| GeometryError::InvalidTessellation {
                message: format!("Tile {:?} not found", tile_id),
            })?;

        tile.neighbors[edge_idx] = Some(neighbor_id);
        Ok(())
    }

    /// Build vertex structures from tile adjacencies
    fn build_vertices(&mut self) -> Result<()> {
        // Collect all unique vertex positions from tiles
        let mut vertex_positions: Vec<PoincarePoint> = Vec::new();
        let mut vertex_map: HashMap<usize, Vec<TileId>> = HashMap::new();

        for tile in &self.tiles {
            for vertex_pos in &tile.vertices {
                // Find or create vertex
                let vertex_idx = vertex_positions.iter()
                    .position(|v| v.distance(vertex_pos) < 1e-6)
                    .unwrap_or_else(|| {
                        vertex_positions.push(*vertex_pos);
                        vertex_positions.len() - 1
                    });

                // Track which tiles are incident to this vertex
                vertex_map.entry(vertex_idx)
                    .or_insert_with(Vec::new)
                    .push(tile.id);
            }
        }

        // Create TessellationVertex structures
        for (vertex_idx, position) in vertex_positions.iter().enumerate() {
            if let Some(incident) = vertex_map.get(&vertex_idx) {
                // {7,3} constraint: exactly 3 tiles per vertex
                if incident.len() == 3 {
                    let vertex = TessellationVertex {
                        id: VertexId(self.vertices.len()),
                        position: *position,
                        incident_tiles: [incident[0], incident[1], incident[2]],
                        angles: [2.0 * PI / 3.0; 3], // 120° each for {7,3}
                    };
                    self.vertices.push(vertex);
                }
            }
        }

        Ok(())
    }

    /// Get all tiles in the tessellation
    pub fn tiles(&self) -> &[HeptagonalTile] {
        &self.tiles
    }

    /// Get all vertices in the tessellation
    pub fn vertices(&self) -> &[TessellationVertex] {
        &self.vertices
    }

    /// Get the Fuchsian group for this tessellation
    pub fn fuchsian_group(&self) -> &FuchsianGroup {
        &self.fuchsian_group
    }

    /// Get number of tiles
    pub fn num_tiles(&self) -> usize {
        self.tiles.len()
    }

    /// Get number of vertices
    pub fn num_vertices(&self) -> usize {
        self.vertices.len()
    }

    /// Get a tile by ID
    pub fn get_tile(&self, id: TileId) -> Option<&HeptagonalTile> {
        self.tiles.get(id.0)
    }

    /// Get a vertex by ID
    pub fn get_vertex(&self, id: VertexId) -> Option<&TessellationVertex> {
        self.vertices.get(id.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_73_hyperbolic_condition() {
        // {7,3}: (7-2)(3-2) = 5 > 4 ✓ (hyperbolic)
        assert!((7 - 2) * (3 - 2) > 4);
    }

    #[test]
    fn test_edge_length_calculation() {
        let r = HeptagonalTessellation::calculate_edge_length();
        assert!(r > 0.0 && r < 10.0, "Edge length should be positive and reasonable");
    }

    #[test]
    fn test_create_central_tile() -> Result<()> {
        let tess = HeptagonalTessellation::new(0)?;

        // Should have exactly 1 tile (central)
        assert_eq!(tess.num_tiles(), 1);

        // Central tile should have 7 vertices
        let central = tess.get_tile(TileId(0)).unwrap();
        assert_eq!(central.vertices.len(), 7);

        // All vertices should be inside Poincaré disk
        for vertex in &central.vertices {
            assert!(vertex.norm() < 1.0);
        }

        Ok(())
    }

    #[test]
    fn test_fuchsian_group_generators() {
        let group = FuchsianGroup::new_for_73();

        // Should have 7 generators (one per heptagon side)
        assert_eq!(group.generators.len(), 7);

        // Each generator should be a 4x4 matrix
        for gen in &group.generators {
            assert_eq!(gen.nrows(), 4);
            assert_eq!(gen.ncols(), 4);
        }
    }

    #[test]
    fn test_vertices_have_three_tiles() -> Result<()> {
        let tess = HeptagonalTessellation::new(1)?;

        // All vertices should have exactly 3 incident tiles ({7,3} constraint)
        for vertex in tess.vertices() {
            assert_eq!(vertex.incident_tiles.len(), 3);
        }

        Ok(())
    }

    #[test]
    fn test_vertex_angles() -> Result<()> {
        let tess = HeptagonalTessellation::new(1)?;

        // In {7,3}, angles at each vertex should sum to 2π
        for vertex in tess.vertices() {
            let angle_sum: f64 = vertex.angles.iter().sum();
            assert!((angle_sum - 2.0 * PI).abs() < 1e-6,
                   "Vertex angles should sum to 2π, got {}", angle_sum);
        }

        Ok(())
    }

    #[test]
    fn test_multi_layer_generation() -> Result<()> {
        // Generate tessellation with depth 1 (central + 1 layer)
        let tess = HeptagonalTessellation::new(1)?;

        // Debug: print what we got
        eprintln!("Generated {} tiles for depth 1", tess.num_tiles());
        for (i, tile) in tess.tiles().iter().enumerate() {
            eprintln!("  Tile {}: id={:?}, layer={}, neighbors={:?}",
                i, tile.id, tile.layer, tile.neighbors);
        }

        // Should have more than 1 tile (central + neighbors)
        assert!(tess.num_tiles() > 1, "Should generate neighbor tiles for depth 1 (got {} tiles)", tess.num_tiles());

        // Expected: 1 central + 7 neighbors = 8 tiles (for layer 1)
        assert!(tess.num_tiles() >= 8, "Should have at least 8 tiles (1 central + 7 neighbors), got {}", tess.num_tiles());

        Ok(())
    }

    #[test]
    fn test_neighbor_relationships() -> Result<()> {
        let tess = HeptagonalTessellation::new(1)?;

        // Verify bidirectional neighbor relationships
        for tile in tess.tiles() {
            for (edge_idx, neighbor_opt) in tile.neighbors.iter().enumerate() {
                if let Some(neighbor_id) = neighbor_opt {
                    // Get the neighbor tile
                    let neighbor = tess.get_tile(*neighbor_id).expect("Neighbor should exist");

                    // Find this tile in the neighbor's neighbors
                    let found = neighbor.neighbors.iter()
                        .any(|n_opt| n_opt.map(|n| n == tile.id).unwrap_or(false));

                    assert!(found,
                        "Tile {:?} has neighbor {:?} at edge {}, but neighbor doesn't reference back",
                        tile.id, neighbor_id, edge_idx);
                }
            }
        }

        Ok(())
    }

    #[test]
    fn test_tiles_inside_disk() -> Result<()> {
        let tess = HeptagonalTessellation::new(1)?;

        // All tile centers and vertices should be inside Poincaré disk
        for tile in tess.tiles() {
            assert!(tile.center.norm() < 1.0,
                "Tile {:?} center outside disk: norm = {}", tile.id, tile.center.norm());

            for (i, vertex) in tile.vertices.iter().enumerate() {
                assert!(vertex.norm() < 1.0,
                    "Tile {:?} vertex {} outside disk: norm = {}", tile.id, i, vertex.norm());
            }
        }

        Ok(())
    }

    #[test]
    fn test_layer_assignment() -> Result<()> {
        let tess = HeptagonalTessellation::new(2)?;

        // Count tiles by layer
        let layer_0_count = tess.tiles().iter().filter(|t| t.layer == 0).count();
        let layer_1_count = tess.tiles().iter().filter(|t| t.layer == 1).count();
        let layer_2_count = tess.tiles().iter().filter(|t| t.layer == 2).count();

        // Should have exactly 1 central tile (layer 0)
        assert_eq!(layer_0_count, 1, "Should have exactly 1 central tile");

        // Should have tiles in subsequent layers
        assert!(layer_1_count > 0, "Should have layer 1 tiles");
        // layer_2_count can be 0 for depth 2, just verify it's counted
        assert!(layer_2_count == tess.tiles().iter().filter(|t| t.layer == 2).count());

        Ok(())
    }

    #[test]
    fn test_tile_uniqueness() -> Result<()> {
        let tess = HeptagonalTessellation::new(1)?;

        // All tile IDs should be unique
        let mut seen_ids = std::collections::HashSet::new();
        for tile in tess.tiles() {
            assert!(seen_ids.insert(tile.id),
                "Duplicate tile ID: {:?}", tile.id);
        }

        Ok(())
    }

    #[test]
    fn test_algebraic_tessellation_creation() -> Result<()> {
        // Create tessellation with algebraic Fuchsian group
        let tess = HeptagonalTessellation::new_with_algebraic(0)?;

        // Should have central tile
        assert_eq!(tess.num_tiles(), 1);

        // Algebraic group should be present
        assert!(tess.algebraic_group().is_some());

        // Algebraic group should have generated elements
        let group = tess.algebraic_group().unwrap();
        assert!(group.num_elements() > 1);

        Ok(())
    }

    #[test]
    fn test_exact_orbit_generation() -> Result<()> {
        // Create tessellation with algebraic Fuchsian group
        let tess = HeptagonalTessellation::new_with_algebraic(0)?;

        // Generate exact orbit of central tile
        let orbit = tess.generate_exact_orbit(20)?;

        // Orbit should contain multiple points
        assert!(orbit.len() > 1, "Orbit should have multiple points, got {}", orbit.len());

        // All points should be inside Poincaré disk
        for (i, point) in orbit.iter().enumerate() {
            assert!(point.norm() < 1.0,
                "Orbit point {} should be inside disk, norm = {}", i, point.norm());
        }

        // First point should be at origin (central tile)
        assert!(orbit[0].norm() < 1e-10, "First orbit point should be at origin");

        Ok(())
    }

    #[test]
    fn test_coordinate_conversions() -> Result<()> {
        // Test PoincarePoint <-> Complex64 conversion
        let z = Complex64::new(0.5, 0.3);
        let point = HeptagonalTessellation::complex_to_poincare(z)?;
        let z_back = HeptagonalTessellation::poincare_to_complex(&point);

        assert!((z - z_back).norm() < 1e-10,
            "Round-trip conversion should preserve coordinates");

        // Test that point is in disk
        assert!(point.norm() < 1.0, "Converted point should be inside disk");

        Ok(())
    }

    #[test]
    fn test_moebius_application() -> Result<()> {
        // Create a rotation Möbius transformation
        let rotation = MoebiusTransform::rotation(std::f64::consts::PI / 4.0);

        // Apply to a test point
        let test_point = HeptagonalTessellation::complex_to_poincare(Complex64::new(0.3, 0.0))?;
        let rotated = HeptagonalTessellation::apply_moebius(&rotation, &test_point)?;

        // Rotated point should still be in disk
        assert!(rotated.norm() < 1.0, "Rotated point should remain in disk");

        // Distance from origin should be preserved (rotation is isometry)
        let dist_before = test_point.norm();
        let dist_after = rotated.norm();
        assert!((dist_before - dist_after).abs() < 1e-6,
            "Rotation should preserve distance from origin");

        Ok(())
    }

    #[test]
    fn test_algebraic_vs_geometric_comparison() -> Result<()> {
        // Create both versions
        let geometric = HeptagonalTessellation::new(1)?;
        let algebraic = HeptagonalTessellation::new_with_algebraic(1)?;

        // Both should generate tiles
        assert!(geometric.num_tiles() > 0);
        assert!(algebraic.num_tiles() > 0);

        // Algebraic should have the algebraic group
        assert!(geometric.algebraic_group().is_none());
        assert!(algebraic.algebraic_group().is_some());

        Ok(())
    }

    #[test]
    fn test_fuchsian_group_integration() -> Result<()> {
        // Verify that the algebraic Fuchsian group is properly integrated
        let tess = HeptagonalTessellation::new_with_algebraic(0)?;

        let group = tess.algebraic_group().unwrap();

        // {7,3} group should have 2 generators
        assert_eq!(group.generators().len(), 2);

        // Verify the group is discrete
        assert!(group.is_discrete(), "Fuchsian group for {{7,3}} should be discrete");

        Ok(())
    }
}
