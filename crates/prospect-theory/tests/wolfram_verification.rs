//! Formal verification tests for Prospect Theory generated by Wolfram
//!
//! These test vectors verify the mathematical correctness of
//! Kahneman-Tversky prospect theory implementation.
//!
//! Generated: 2025-12-06
//! Reference: Tversky & Kahneman (1992) "Advances in Prospect Theory"

use prospect_theory_rs::{ValueFunction, ProbabilityWeighting, WeightingParams};

const EPSILON: f64 = 1e-10;

/// Wolfram-verified value function for gains and losses
/// V(x) = x^α for x ≥ 0
/// V(x) = -λ|x|^β for x < 0
#[test]
fn test_value_function_wolfram_verified() {
    let vf = ValueFunction::default_kt();

    // Wolfram-computed expected values (α=0.88, β=0.88, λ=2.25)
    let test_cases = [
        // (outcome, expected_value)
        (-100.0, -129.47398590086033),
        (-50.0, -70.35194713433611),
        (-10.0, -17.067995438156636),
        (0.0, 0.0),
        (10.0, 7.5857757502918375),
        (50.0, 31.267532059704937),
        (100.0, 57.543993733715695),
    ];

    for (outcome, expected) in test_cases {
        let value = vf.value(outcome).unwrap();
        assert!(
            (value - expected).abs() < 1e-6,
            "Value({}) = {}, expected {}",
            outcome,
            value,
            expected
        );
    }
}

/// Verify loss aversion: |V(-x)| > V(x) for same magnitude
#[test]
fn test_loss_aversion_property() {
    let vf = ValueFunction::default_kt();

    let magnitudes = [10.0, 50.0, 100.0, 500.0];

    for mag in magnitudes {
        let gain_value = vf.value(mag).unwrap();
        let loss_value = vf.value(-mag).unwrap();

        assert!(
            loss_value.abs() > gain_value,
            "Loss aversion violated at {}: |V(-{})| = {} should be > V({}) = {}",
            mag,
            mag,
            loss_value.abs(),
            mag,
            gain_value
        );
    }
}

/// Verify diminishing sensitivity: marginal value decreases with distance from reference
#[test]
fn test_diminishing_sensitivity() {
    let vf = ValueFunction::default_kt();

    // For gains: V(x2) - V(x1) < V(x1) - V(0) when x2 - x1 = x1
    let v0 = vf.value(0.0).unwrap();
    let v50 = vf.value(50.0).unwrap();
    let v100 = vf.value(100.0).unwrap();

    let first_50 = v50 - v0;
    let second_50 = v100 - v50;

    assert!(
        second_50 < first_50,
        "Diminishing sensitivity violated: second 50 gain ({}) should be < first 50 gain ({})",
        second_50,
        first_50
    );
}

/// Wolfram-verified Tversky-Kahneman probability weighting
/// w(p) = p^γ / (p^γ + (1-p)^γ)
#[test]
fn test_probability_weighting_wolfram_verified() {
    let pw = ProbabilityWeighting::default_tk();

    // Wolfram-computed expected values (γ_gains=0.61, γ_losses=0.69)
    let test_cases = [
        // (probability, w_gains, w_losses)
        (0.0, 0.0, 0.0),
        (0.1, 0.207459578341875, 0.18003875283189974),
        (0.25, 0.33846247130721335, 0.3190714159614775),
        (0.5, 0.5, 0.5),
        (0.75, 0.6615375286927866, 0.6809285840385226),
        (0.9, 0.792540421658125, 0.8199612471681003),
        (1.0, 1.0, 1.0),
    ];

    for (p, expected_gains, expected_losses) in test_cases {
        let w_gains = pw.weight_gains(p).unwrap();
        let w_losses = pw.weight_losses(p).unwrap();

        assert!(
            (w_gains - expected_gains).abs() < 1e-6,
            "w_gains({}) = {}, expected {}",
            p,
            w_gains,
            expected_gains
        );
        assert!(
            (w_losses - expected_losses).abs() < 1e-6,
            "w_losses({}) = {}, expected {}",
            p,
            w_losses,
            expected_losses
        );
    }
}

/// Verify inverse-S curve property: overweight small, underweight large probabilities
#[test]
fn test_inverse_s_curve_property() {
    let pw = ProbabilityWeighting::default_tk();

    // Small probabilities should be overweighted
    let p_small = 0.1;
    let w_small = pw.weight_gains(p_small).unwrap();
    assert!(
        w_small > p_small,
        "Small prob {} should be overweighted, got {}",
        p_small,
        w_small
    );

    // Large probabilities should be underweighted
    let p_large = 0.9;
    let w_large = pw.weight_gains(p_large).unwrap();
    assert!(
        w_large < p_large,
        "Large prob {} should be underweighted, got {}",
        p_large,
        w_large
    );

    // p=0.5 is approximately fixed point
    let w_half = pw.weight_gains(0.5).unwrap();
    assert!(
        (w_half - 0.5).abs() < 0.01,
        "w(0.5) = {} should be ≈ 0.5",
        w_half
    );
}

/// Verify boundary conditions
#[test]
fn test_weighting_boundaries() {
    let pw = ProbabilityWeighting::default_tk();

    // w(0) = 0
    assert!((pw.weight_gains(0.0).unwrap() - 0.0).abs() < EPSILON);
    assert!((pw.weight_losses(0.0).unwrap() - 0.0).abs() < EPSILON);

    // w(1) = 1
    assert!((pw.weight_gains(1.0).unwrap() - 1.0).abs() < EPSILON);
    assert!((pw.weight_losses(1.0).unwrap() - 1.0).abs() < EPSILON);
}
