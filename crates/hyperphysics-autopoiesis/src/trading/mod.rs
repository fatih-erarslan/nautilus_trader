//! Trading system integration with autopoietic principles
//!
//! This module bridges autopoietic systems theory with the HyperPhysics trading
//! ecosystem, enabling biologically-inspired trading strategies that maintain
//! operational closure and adapt to market dynamics.
//!
//! ## Theoretical Foundation
//!
//! Autopoietic trading systems exhibit:
//! - **Self-maintenance**: Strategies that preserve capital through market cycles
//! - **Structural coupling**: Adaptation to market environment without losing identity
//! - **Operational closure**: All trading decisions emerge from internal dynamics
//!
//! ## References
//! - Maturana & Varela (1980) "Autopoiesis and Cognition"
//! - Kauffman (1993) "The Origins of Order"
//! - Arthur (2014) "Complexity and the Economy"

use std::collections::VecDeque;
use serde::{Deserialize, Serialize};

use crate::adapters::SyncAdapter;
use crate::bridges::{AutopoieticBridge, DissipativeBridge, SyntergicBridge};
use crate::dynamics::DynamicsConfig;
use crate::emergence::{EmergenceAnalyzer, EmergentPattern};
use crate::error::{AutopoiesisError, Result};

/// Configuration for autopoietic trading system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AutopoieticTradingConfig {
    /// Minimum health threshold for trading
    pub min_health: f64,
    /// Maximum entropy for stability
    pub max_entropy: f64,
    /// Coherence threshold for signal generation
    pub coherence_threshold: f64,
    /// Risk scaling factor
    pub risk_scale: f64,
    /// Adaptation rate (how fast system learns)
    pub adaptation_rate: f64,
    /// Lookback window for pattern detection
    pub lookback_window: usize,
    /// Enable bifurcation-based regime detection
    pub detect_bifurcations: bool,
    /// Enable emergence-based signals
    pub emergence_signals: bool,
    /// Synchronization coupling strength
    pub sync_coupling: f64,
}

impl Default for AutopoieticTradingConfig {
    fn default() -> Self {
        Self {
            min_health: 0.7,
            max_entropy: 2.0,
            coherence_threshold: 0.6,
            risk_scale: 1.0,
            adaptation_rate: 0.1,
            lookback_window: 100,
            detect_bifurcations: true,
            emergence_signals: true,
            sync_coupling: 0.5,
        }
    }
}

/// Trading signals generated by autopoietic system
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum AutopoieticSignal {
    /// Strong buy signal from emergent coherence
    StrongBuy,
    /// Buy signal
    Buy,
    /// Hold / no action
    Hold,
    /// Sell signal
    Sell,
    /// Strong sell from coherence breakdown
    StrongSell,
    /// Reduce exposure due to instability
    ReduceRisk,
    /// System unhealthy, exit positions
    EmergencyExit,
}

impl AutopoieticSignal {
    /// Convert signal to position multiplier (-1 to 1)
    pub fn to_position(&self) -> f64 {
        match self {
            Self::StrongBuy => 1.0,
            Self::Buy => 0.5,
            Self::Hold => 0.0,
            Self::Sell => -0.5,
            Self::StrongSell => -1.0,
            Self::ReduceRisk => 0.0,
            Self::EmergencyExit => 0.0,
        }
    }

    /// Check if signal requires position exit
    pub fn requires_exit(&self) -> bool {
        matches!(self, Self::ReduceRisk | Self::EmergencyExit)
    }
}

/// Result from a trading cycle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingResult {
    /// Generated signal
    pub signal: AutopoieticSignal,
    /// System health at signal generation
    pub health: f64,
    /// Coherence level
    pub coherence: f64,
    /// Entropy production
    pub entropy: f64,
    /// Detected patterns
    pub patterns: Vec<String>,
    /// Confidence in signal (0-1)
    pub confidence: f64,
    /// Position size recommendation (0-1)
    pub position_size: f64,
    /// Risk assessment
    pub risk_score: f64,
    /// Timestamp
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

/// Market data input for autopoietic analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketData {
    /// Price series
    pub prices: Vec<f64>,
    /// Volume series
    pub volumes: Vec<f64>,
    /// Bid-ask spreads
    pub spreads: Vec<f64>,
    /// Timestamp
    pub timestamp: chrono::DateTime<chrono::Utc>,
    /// Additional features
    pub features: Vec<f64>,
}

impl MarketData {
    /// Create new market data point
    pub fn new(prices: Vec<f64>, volumes: Vec<f64>) -> Self {
        Self {
            prices,
            volumes,
            spreads: Vec::new(),
            timestamp: chrono::Utc::now(),
            features: Vec::new(),
        }
    }

    /// Get returns from prices
    pub fn returns(&self) -> Vec<f64> {
        if self.prices.len() < 2 {
            return Vec::new();
        }

        self.prices
            .windows(2)
            .map(|w| (w[1] - w[0]) / w[0])
            .collect()
    }

    /// Get log returns
    pub fn log_returns(&self) -> Vec<f64> {
        if self.prices.len() < 2 {
            return Vec::new();
        }

        self.prices
            .windows(2)
            .map(|w| (w[1] / w[0]).ln())
            .collect()
    }

    /// Compute volatility (standard deviation of returns)
    pub fn volatility(&self) -> f64 {
        let returns = self.returns();
        if returns.is_empty() {
            return 0.0;
        }

        let mean: f64 = returns.iter().sum::<f64>() / returns.len() as f64;
        let variance: f64 =
            returns.iter().map(|r| (r - mean).powi(2)).sum::<f64>() / returns.len() as f64;

        variance.sqrt()
    }
}

/// Autopoietic trading system
///
/// Integrates all autopoiesis components for adaptive trading:
/// - Maintains operational closure (self-consistency)
/// - Tracks dissipative structure dynamics (market regimes)
/// - Uses syntergic coherence for signal generation
/// - Monitors emergence for pattern detection
pub struct AutopoieticTradingSystem {
    /// Configuration
    config: AutopoieticTradingConfig,
    /// Autopoietic bridge for operational closure
    autopoietic_bridge: AutopoieticBridge,
    /// Dissipative bridge for regime tracking
    dissipative_bridge: DissipativeBridge,
    /// Syntergic bridge for coherence signals
    syntergic_bridge: SyntergicBridge,
    /// Synchronization adapter for phase coherence (reserved for advanced sync features)
    #[allow(dead_code)]
    sync: SyncAdapter,
    /// Emergence analyzer
    emergence_analyzer: EmergenceAnalyzer,
    /// Historical market data
    market_history: VecDeque<MarketData>,
    /// Historical signals
    signal_history: VecDeque<TradingResult>,
    /// Current system state
    state: SystemState,
}

/// Internal system state
#[derive(Debug, Clone, Default)]
pub struct SystemState {
    /// System health (0-1)
    pub health: f64,
    /// Coherence level (0-1)
    pub coherence: f64,
    /// Entropy production
    pub entropy: f64,
    /// Risk level (0-1)
    pub risk_level: f64,
    /// Current market regime
    pub regime: MarketRegime,
    /// Last generated signal
    pub last_signal: Option<AutopoieticSignal>,
}

/// Market regime classification
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum MarketRegime {
    #[default]
    /// Low volatility, trending
    Trending,
    /// High volatility, mean-reverting
    MeanReverting,
    /// Near critical transition
    Transitional,
    /// Chaotic / high uncertainty
    Chaotic,
}

impl AutopoieticTradingSystem {
    /// Create new autopoietic trading system
    #[allow(unused_variables)]
    pub fn new(config: AutopoieticTradingConfig) -> Result<Self> {
        let _dynamics_config = DynamicsConfig {
            window_size: config.lookback_window,
            bifurcation_threshold: 0.1,
            emergence_eigenvalue_gap: 0.5,
            sample_interval_ms: 100,
        };

        Ok(Self {
            config: config.clone(),
            autopoietic_bridge: AutopoieticBridge::new(config.min_health),
            dissipative_bridge: DissipativeBridge::new(config.max_entropy),
            syntergic_bridge: SyntergicBridge::new(config.coherence_threshold),
            sync: SyncAdapter::new(config.sync_coupling),
            emergence_analyzer: EmergenceAnalyzer::default(),
            market_history: VecDeque::with_capacity(1000),
            signal_history: VecDeque::with_capacity(1000),
            state: SystemState::default(),
        })
    }

    /// Process market data and generate trading signal
    pub async fn autopoietic_cycle(&mut self, market_data: &MarketData) -> Result<TradingResult> {
        // Store market data
        self.market_history.push_back(market_data.clone());
        if self.market_history.len() > self.config.lookback_window {
            self.market_history.pop_front();
        }

        // 1. Update autopoietic health
        self.update_autopoietic_health(market_data)?;

        // 2. Update dissipative dynamics (regime detection)
        self.update_dissipative_dynamics(market_data)?;

        // 3. Update syntergic coherence
        self.update_syntergic_coherence(market_data)?;

        // 4. Detect emergence patterns
        let patterns = self.detect_emergence_patterns(market_data)?;

        // 5. Generate trading signal
        let signal = self.generate_signal()?;

        // 6. Compute confidence and position sizing
        let confidence = self.compute_confidence();
        let position_size = self.compute_position_size(signal, confidence);

        // 7. Create result
        let result = TradingResult {
            signal,
            health: self.state.health,
            coherence: self.state.coherence,
            entropy: self.state.entropy,
            patterns: patterns.iter().map(|p| format!("{:?}", p.category)).collect(),
            confidence,
            position_size,
            risk_score: self.state.risk_level,
            timestamp: chrono::Utc::now(),
        };

        // Store result
        self.signal_history.push_back(result.clone());
        if self.signal_history.len() > 1000 {
            self.signal_history.pop_front();
        }

        self.state.last_signal = Some(signal);

        Ok(result)
    }

    /// Update autopoietic health from market state
    fn update_autopoietic_health(&mut self, market_data: &MarketData) -> Result<()> {
        // Register market observables as autopoietic components
        self.autopoietic_bridge
            .register_component("price_momentum", market_data.volatility(), 0.5);
        self.autopoietic_bridge
            .register_component("volume_flow", market_data.volumes.last().copied().unwrap_or(0.0), 0.3);

        // Execute autopoietic cycle
        match self.autopoietic_bridge.execute_cycle() {
            Ok(cycle_result) => {
                self.state.health = cycle_result.health;
            }
            Err(AutopoiesisError::OperationalClosureViolation) => {
                // System losing coherence
                self.state.health *= 0.9;
            }
            Err(e) => return Err(e),
        }

        Ok(())
    }

    /// Update dissipative structure dynamics
    fn update_dissipative_dynamics(&mut self, market_data: &MarketData) -> Result<()> {
        let volatility = market_data.volatility();

        // Control parameter is market volatility
        let _regime = self.dissipative_bridge.update_control_parameter(volatility)?;

        // Update market regime based on dissipative state
        self.state.regime = match self.dissipative_bridge.state().regime {
            crate::bridges::DissipativeRegime::Stable => MarketRegime::Trending,
            crate::bridges::DissipativeRegime::Bifurcation => MarketRegime::Transitional,
            crate::bridges::DissipativeRegime::Dissipative => MarketRegime::MeanReverting,
            crate::bridges::DissipativeRegime::Chaotic => MarketRegime::Chaotic,
        };

        // Compute order parameter from returns
        let returns = market_data.returns();
        if !returns.is_empty() {
            let order = self.dissipative_bridge.compute_order_parameter(&returns);
            // Higher order parameter in transitional regime increases risk
            if self.dissipative_bridge.near_bifurcation() {
                self.state.risk_level = (order * 2.0).min(1.0);
            }
        }

        // Update entropy from thermodynamic fluxes
        let fluxes = vec![volatility, market_data.volumes.last().copied().unwrap_or(0.0) / 1e6];
        let forces = vec![1.0, 0.5];

        if let Ok(entropy) = self
            .dissipative_bridge
            .update_entropy_production(&fluxes, &forces)
        {
            self.state.entropy = entropy;
        }

        Ok(())
    }

    /// Update syntergic coherence from market synchronization
    fn update_syntergic_coherence(&mut self, market_data: &MarketData) -> Result<()> {
        // Use price phases for synchronization analysis
        let returns = market_data.returns();
        if returns.len() < 4 {
            return Ok(());
        }

        // Convert returns to phases (Hilbert transform approximation)
        let phases: Vec<f64> = returns
            .iter()
            .map(|r| r.atan2(returns.iter().sum::<f64>() / returns.len() as f64))
            .collect();

        // Update syntergic coherence
        self.state.coherence = self.syntergic_bridge.update_from_phases(&phases);

        // Check for coherence loss - handle gracefully by degrading health
        if let Err(AutopoiesisError::SyntergicCoherenceLoss { coherence }) =
            self.syntergic_bridge.check_coherence_loss()
        {
            // Coherence loss degrades system health instead of failing
            self.state.health *= 0.95;
            self.state.risk_level = (self.state.risk_level + 0.1).min(1.0);
            // Log coherence loss (in production would use proper logging)
            let _ = coherence; // Acknowledge the value
        }

        Ok(())
    }

    /// Detect emergence patterns in market data
    fn detect_emergence_patterns(&mut self, market_data: &MarketData) -> Result<Vec<EmergentPattern>> {
        if !self.config.emergence_signals {
            return Ok(Vec::new());
        }

        // Detect from price time series
        let patterns = self
            .emergence_analyzer
            .detect_from_timeseries(&market_data.prices, 1.0);

        // Update collective state
        self.emergence_analyzer
            .update_collective_state(&market_data.returns());

        Ok(patterns)
    }

    /// Generate trading signal from system state
    fn generate_signal(&self) -> Result<AutopoieticSignal> {
        // Emergency exit conditions
        if self.state.health < self.config.min_health * 0.5 {
            return Ok(AutopoieticSignal::EmergencyExit);
        }

        // Risk reduction in chaotic regime
        if self.state.regime == MarketRegime::Chaotic {
            return Ok(AutopoieticSignal::ReduceRisk);
        }

        // Low health: reduce risk
        if self.state.health < self.config.min_health {
            return Ok(AutopoieticSignal::ReduceRisk);
        }

        // Transitional regime: caution
        if self.state.regime == MarketRegime::Transitional {
            return Ok(AutopoieticSignal::Hold);
        }

        // Coherence-based signals
        if self.state.coherence > 0.9 {
            // High coherence with trending regime: strong signal
            if self.state.regime == MarketRegime::Trending {
                return Ok(AutopoieticSignal::StrongBuy);
            }
            return Ok(AutopoieticSignal::Buy);
        }

        if self.state.coherence > self.config.coherence_threshold {
            return Ok(AutopoieticSignal::Buy);
        }

        if self.state.coherence < self.config.coherence_threshold * 0.5 {
            // Coherence breakdown: sell
            return Ok(AutopoieticSignal::Sell);
        }

        if self.state.coherence < self.config.coherence_threshold * 0.3 {
            return Ok(AutopoieticSignal::StrongSell);
        }

        Ok(AutopoieticSignal::Hold)
    }

    /// Compute confidence in current signal
    fn compute_confidence(&self) -> f64 {
        // Confidence based on:
        // - System health (weight: 0.3)
        // - Coherence stability (weight: 0.3)
        // - Regime clarity (weight: 0.2)
        // - Historical consistency (weight: 0.2)

        let health_score = self.state.health;
        let coherence_score = self.state.coherence;

        let regime_score = match self.state.regime {
            MarketRegime::Trending => 0.9,
            MarketRegime::MeanReverting => 0.7,
            MarketRegime::Transitional => 0.3,
            MarketRegime::Chaotic => 0.1,
        };

        // Historical consistency: how often have recent signals agreed
        let consistency_score = self.compute_signal_consistency();

        0.3 * health_score + 0.3 * coherence_score + 0.2 * regime_score + 0.2 * consistency_score
    }

    /// Compute signal consistency from recent history
    fn compute_signal_consistency(&self) -> f64 {
        if self.signal_history.len() < 3 {
            return 0.5;
        }

        let recent: Vec<_> = self.signal_history.iter().rev().take(10).collect();

        if recent.is_empty() {
            return 0.5;
        }

        // Count agreements between consecutive signals
        let mut agreements = 0;
        for i in 1..recent.len() {
            let pos_curr = recent[i - 1].signal.to_position();
            let pos_prev = recent[i].signal.to_position();

            if pos_curr.signum() == pos_prev.signum() {
                agreements += 1;
            }
        }

        agreements as f64 / (recent.len() - 1) as f64
    }

    /// Compute position size from signal and confidence
    fn compute_position_size(&self, signal: AutopoieticSignal, confidence: f64) -> f64 {
        if signal.requires_exit() {
            return 0.0;
        }

        // Base position from signal strength
        let base_position = signal.to_position().abs();

        // Scale by confidence
        let confidence_scaled = base_position * confidence;

        // Risk adjustment
        let risk_adjusted = confidence_scaled * (1.0 - self.state.risk_level);

        // Apply risk scale from config
        (risk_adjusted * self.config.risk_scale).min(1.0)
    }

    /// Get current system state
    pub fn state(&self) -> &SystemState {
        &self.state
    }

    /// Get configuration
    pub fn config(&self) -> &AutopoieticTradingConfig {
        &self.config
    }

    /// Get current market regime
    pub fn regime(&self) -> MarketRegime {
        self.state.regime
    }

    /// Get signal history
    pub fn signal_history(&self) -> impl Iterator<Item = &TradingResult> {
        self.signal_history.iter()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_trading_system_creation() {
        let config = AutopoieticTradingConfig::default();
        let system = AutopoieticTradingSystem::new(config);
        assert!(system.is_ok());
    }

    #[tokio::test]
    async fn test_trading_cycle() {
        let config = AutopoieticTradingConfig::default();
        let mut system = AutopoieticTradingSystem::new(config).unwrap();

        // Create sample market data
        let prices: Vec<f64> = (0..100)
            .map(|i| 100.0 + (i as f64 * 0.1).sin() * 5.0)
            .collect();
        let volumes: Vec<f64> = vec![1000000.0; 100];

        let market_data = MarketData::new(prices, volumes);

        let result = system.autopoietic_cycle(&market_data).await;
        assert!(result.is_ok());

        let result = result.unwrap();
        assert!(result.confidence >= 0.0 && result.confidence <= 1.0);
        assert!(result.position_size >= 0.0 && result.position_size <= 1.0);
    }

    #[test]
    fn test_market_data_returns() {
        let prices = vec![100.0, 101.0, 102.0, 101.0];
        let market_data = MarketData::new(prices, vec![1000.0; 4]);

        let returns = market_data.returns();
        assert_eq!(returns.len(), 3);

        // First return: (101-100)/100 = 0.01
        assert!((returns[0] - 0.01).abs() < 1e-10);
    }

    #[test]
    fn test_signal_to_position() {
        assert_eq!(AutopoieticSignal::StrongBuy.to_position(), 1.0);
        assert_eq!(AutopoieticSignal::StrongSell.to_position(), -1.0);
        assert_eq!(AutopoieticSignal::Hold.to_position(), 0.0);
    }

    #[test]
    fn test_signal_requires_exit() {
        assert!(AutopoieticSignal::EmergencyExit.requires_exit());
        assert!(AutopoieticSignal::ReduceRisk.requires_exit());
        assert!(!AutopoieticSignal::Buy.requires_exit());
    }
}
