/* auto-generated by NAPI-RS */

/**
 * Model types available for forecasting
 */
export enum ModelType {
  LSTM = 'LSTM',
  GRU = 'GRU',
  Transformer = 'Transformer',
  Ensemble = 'Ensemble',
  NHITS = 'NHITS',
  NBEATS = 'NBEATS',
  TFT = 'TFT',
  DeepAR = 'DeepAR'
}

/**
 * Model configuration options
 */
export interface ModelConfig {
  /**
   * Type of neural network model to use
   */
  modelType: string
  /**
   * Input sequence length (number of past time steps to consider)
   */
  inputSize: number
  /**
   * Forecast horizon (number of future time steps to predict)
   */
  horizon: number
  /**
   * Hidden layer size (optional, default: 64)
   */
  hiddenSize?: number
  /**
   * Number of layers (optional, default: 2)
   */
  numLayers?: number
  /**
   * Dropout rate for regularization (0.0 to 1.0, optional, default: 0.1)
   */
  dropout?: number
  /**
   * Learning rate for training (optional, default: 0.001)
   */
  learningRate?: number
}

/**
 * Time series data point
 */
export interface TimeSeriesPoint {
  /**
   * Timestamp in ISO 8601 format
   */
  timestamp: string
  /**
   * Numerical value at this timestamp
   */
  value: number
  /**
   * Optional additional features (exogenous variables)
   */
  features?: Record<string, number>
}

/**
 * Time series dataset
 */
export interface TimeSeriesData {
  /**
   * Array of time series data points
   */
  points: Array<TimeSeriesPoint>
  /**
   * Frequency of the time series (e.g., "1D" for daily, "1H" for hourly)
   */
  frequency: string
}

/**
 * Prediction result from a model
 */
export interface PredictionResult {
  /**
   * Predicted values
   */
  predictions: Array<number>
  /**
   * Timestamps for the predictions (ISO 8601 format)
   */
  timestamps: Array<string>
  /**
   * Optional confidence intervals as [lower, upper] bounds for each prediction
   */
  confidenceIntervals?: Array<Array<number>>
  /**
   * Model type that generated these predictions
   */
  modelType: string
}

/**
 * Cross-validation results
 */
export interface CrossValidationResult {
  /**
   * Mean Absolute Error
   */
  mae: number
  /**
   * Mean Squared Error
   */
  mse: number
  /**
   * Root Mean Squared Error
   */
  rmse: number
  /**
   * Mean Absolute Percentage Error
   */
  mape: number
}

/**
 * Training metrics for a single epoch
 */
export interface TrainingMetrics {
  /**
   * Epoch number
   */
  epoch: number
  /**
   * Training loss
   */
  trainLoss: number
  /**
   * Validation loss (optional)
   */
  valLoss?: number
  /**
   * Learning rate used for this epoch
   */
  learningRate: number
}

/**
 * Neural forecast engine for time series prediction
 */
export class NeuralForecast {
  /**
   * Create a new neural forecast instance
   */
  constructor()

  /**
   * Add a model with the specified configuration
   *
   * @param config - Model configuration
   * @returns Model ID that can be used for training and prediction
   *
   * @example
   * ```typescript
   * const forecast = new NeuralForecast();
   * const modelId = await forecast.addModel({
   *   modelType: 'LSTM',
   *   inputSize: 10,
   *   horizon: 5,
   *   hiddenSize: 64,
   *   numLayers: 2
   * });
   * ```
   */
  addModel(config: ModelConfig): Promise<string>

  /**
   * Train a model on the provided time series data
   *
   * @param modelId - Model identifier returned from addModel()
   * @param data - Time series training data
   * @returns Training metrics for each epoch
   *
   * @example
   * ```typescript
   * const data = {
   *   points: [
   *     { timestamp: '2024-01-01T00:00:00Z', value: 100 },
   *     { timestamp: '2024-01-02T00:00:00Z', value: 105 },
   *     // ... more data points
   *   ],
   *   frequency: '1D'
   * };
   * const metrics = await forecast.fit(modelId, data);
   * ```
   */
  fit(modelId: string, data: TimeSeriesData): Promise<Array<TrainingMetrics>>

  /**
   * Make predictions for the specified horizon
   *
   * @param modelId - Model identifier
   * @param horizon - Number of time steps to predict
   * @returns Prediction results
   *
   * @example
   * ```typescript
   * const predictions = await forecast.predict(modelId, 5);
   * console.log(predictions.predictions); // [101, 102, 103, 104, 105]
   * ```
   */
  predict(modelId: string, horizon: number): Promise<PredictionResult>

  /**
   * Perform cross-validation on the model
   *
   * @param modelId - Model identifier
   * @param data - Time series data for validation
   * @param nWindows - Number of validation windows
   * @param stepSize - Step size between windows
   * @returns Cross-validation metrics
   *
   * @example
   * ```typescript
   * const cvResults = await forecast.crossValidation(modelId, data, 5, 1);
   * console.log(`MAE: ${cvResults.mae}, RMSE: ${cvResults.rmse}`);
   * ```
   */
  crossValidation(
    modelId: string,
    data: TimeSeriesData,
    nWindows: number,
    stepSize: number
  ): Promise<CrossValidationResult>

  /**
   * Get model configuration
   *
   * @param modelId - Model identifier
   * @returns Model configuration if found
   */
  getConfig(modelId: string): Promise<ModelConfig | null>
}

/**
 * List all available model types
 *
 * @returns Array of model type names
 *
 * @example
 * ```typescript
 * const models = listAvailableModels();
 * console.log(models); // ['LSTM', 'GRU', 'Transformer', 'Ensemble']
 * ```
 */
export function listAvailableModels(): Array<string>

/**
 * Get the version of the neuro-divergent library
 *
 * @returns Version string
 */
export function version(): string

/**
 * Check if GPU acceleration is available
 *
 * @returns true if GPU is available, false otherwise
 */
export function isGpuAvailable(): boolean
