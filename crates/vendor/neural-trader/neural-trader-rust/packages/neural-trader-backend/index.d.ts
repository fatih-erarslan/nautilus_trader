/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Fund allocation strategies */
export const enum AllocationStrategy {
  /** Kelly Criterion with fractional betting */
  KellyCriterion = 0,
  /** Fixed percentage allocation */
  FixedPercentage = 1,
  /** Dynamic confidence-based allocation */
  DynamicConfidence = 2,
  /** Risk parity allocation */
  RiskParity = 3,
  /** Martingale strategy */
  Martingale = 4,
  /** Anti-martingale strategy */
  AntiMartingale = 5
}
/** Profit distribution models */
export const enum DistributionModel {
  /** Pure proportional distribution */
  Proportional = 0,
  /** Performance-weighted distribution */
  PerformanceWeighted = 1,
  /** Tiered distribution */
  Tiered = 2,
  /** Hybrid distribution (50% capital, 30% performance, 20% equal) */
  Hybrid = 3
}
/** Member roles within the syndicate */
export const enum MemberRole {
  /** Lead investor with full control */
  LeadInvestor = 0,
  /** Senior analyst with advanced permissions */
  SeniorAnalyst = 1,
  /** Junior analyst */
  JuniorAnalyst = 2,
  /** Contributing member */
  ContributingMember = 3,
  /** Observer with limited permissions */
  Observer = 4
}
/** Investment tiers based on capital contribution */
export const enum MemberTier {
  /** Bronze tier ($1,000 - $5,000) */
  Bronze = 0,
  /** Silver tier ($5,000 - $25,000) */
  Silver = 1,
  /** Gold tier ($25,000 - $100,000) */
  Gold = 2,
  /** Platinum tier ($100,000+) */
  Platinum = 3
}
/** Bankroll management rules */
export interface BankrollRules {
  /** Maximum single bet as percentage of total bankroll (default: 0.05 = 5%) */
  maxSingleBet: number
  /** Maximum daily exposure (default: 0.20 = 20%) */
  maxDailyExposure: number
  /** Maximum sport concentration (default: 0.40 = 40%) */
  maxSportConcentration: number
  /** Minimum reserve (default: 0.30 = 30%) */
  minimumReserve: number
  /** Daily stop loss limit (default: 0.10 = 10%) */
  stopLossDaily: number
  /** Weekly stop loss limit (default: 0.20 = 20%) */
  stopLossWeekly: number
  /** Profit lock percentage (default: 0.50 = 50%) */
  profitLock: number
  /** Maximum parlay percentage (default: 0.02 = 2%) */
  maxParlayPercentage: number
  /** Maximum live betting percentage (default: 0.15 = 15%) */
  maxLiveBetting: number
}
/** Member permissions configuration */
export interface MemberPermissions {
  /** Can create syndicates */
  createSyndicate: boolean
  /** Can modify strategy */
  modifyStrategy: boolean
  /** Can approve large bets */
  approveLargeBets: boolean
  /** Can manage members */
  manageMembers: boolean
  /** Can distribute profits */
  distributeProfits: boolean
  /** Can access all analytics */
  accessAllAnalytics: boolean
  /** Has veto power */
  vetoPower: boolean
  /** Can propose bets */
  proposeBets: boolean
  /** Can access advanced analytics */
  accessAdvancedAnalytics: boolean
  /** Can create models */
  createModels: boolean
  /** Can vote on strategy */
  voteOnStrategy: boolean
  /** Can manage junior analysts */
  manageJuniorAnalysts: boolean
  /** Can view bets */
  viewBets: boolean
  /** Can vote on major decisions */
  voteOnMajorDecisions: boolean
  /** Can access basic analytics */
  accessBasicAnalytics: boolean
  /** Can propose ideas */
  proposeIdeas: boolean
  /** Can withdraw own funds */
  withdrawOwnFunds: boolean
  /** Can create votes */
  createVotes: boolean
}
/** Betting opportunity details */
export interface BettingOpportunity {
  /** Sport type */
  sport: string
  /** Event description */
  event: string
  /** Bet type (moneyline, spread, total, etc.) */
  betType: string
  /** Selection */
  selection: string
  /** Decimal odds */
  odds: number
  /** Estimated probability */
  probability: number
  /** Betting edge */
  edge: number
  /** Confidence level (0-1) */
  confidence: number
  /** Model agreement (0-1) */
  modelAgreement: number
  /** Time until event in seconds */
  timeUntilEventSecs: number
  /** Market liquidity */
  liquidity: number
  /** Is live betting */
  isLive: boolean
  /** Is parlay bet */
  isParlay: boolean
}

/** Risk metrics for allocation decisions */
export interface RiskMetrics {
  volatility: number
  correlation: number
  var95: number
  cvar95: number
  sharpeRatio: number
  maxDrawdown: number
  beta: number
  concentrationRisk: number
}

/** Stake sizing recommendations */
export interface StakeSizing {
  conservative: number
  moderate: number
  aggressive: number
  kellyOptimal: number
  recommendation: string
}

/** Allocation result */
export interface AllocationResult {
  /** Allocated amount */
  amount: string
  /** Percentage of bankroll */
  percentageOfBankroll: number
  /** Reasoning for allocation */
  reasoning: string
  /** Risk metrics - can be object or JSON string for backward compatibility */
  riskMetrics: RiskMetrics | string
  /** Approval required */
  approvalRequired: boolean
  /** Warning messages */
  warnings: Array<string>
  /** Recommended stake sizing options - can be object or JSON string for backward compatibility */
  recommendedStakeSizing: StakeSizing | string
}

/** Member statistics update details */
export interface MemberStatisticsUpdate {
  betsProposed?: number
  betsWon?: number
  betsLost?: number
  totalProfit?: string
  totalStaked?: string
  roi?: number
  winRate?: number
  accuracy?: number
  profitContribution?: string
  votesCast?: number
  strategyContributions?: number
}

/** Member statistics */
export interface MemberStatistics {
  /** Bets proposed */
  betsProposed: number
  /** Bets won */
  betsWon: number
  /** Bets lost */
  betsLost: number
  /** Total profit */
  totalProfit: string
  /** Total staked */
  totalStaked: string
  /** ROI percentage */
  roi: number
  /** Win rate */
  winRate: number
  /** Accuracy score */
  accuracy: number
  /** Profit contribution */
  profitContribution: string
  /** Votes cast */
  votesCast: number
  /** Strategy contributions */
  strategyContributions: number
}
/** Initialize the syndicate module */
export declare function initSyndicate(): string
/** Get module version */
export declare function getVersion(): string
/** List all available trading strategies */
export declare function listStrategies(): Promise<Array<StrategyInfo>>
/** Strategy information */
export interface StrategyInfo {
  name: string
  description: string
  gpuCapable: boolean
}
/** Get detailed information about a specific strategy */
export declare function getStrategyInfo(strategy: string): Promise<string>
/** Quick market analysis for a symbol */
export declare function quickAnalysis(symbol: string, useGpu?: boolean | undefined | null): Promise<MarketAnalysis>
/** Market analysis result */
export interface MarketAnalysis {
  symbol: string
  trend: string
  volatility: number
  volumeTrend: string
  recommendation: string
}
/** Simulate a trade operation */
export declare function simulateTrade(strategy: string, symbol: string, action: string, useGpu?: boolean | undefined | null): Promise<TradeSimulation>
/** Trade simulation result */
export interface TradeSimulation {
  strategy: string
  symbol: string
  action: string
  expectedReturn: number
  riskScore: number
  executionTimeMs: number
}
/** Get current portfolio status */
export declare function getPortfolioStatus(includeAnalytics?: boolean | undefined | null): Promise<PortfolioStatus>
/** Portfolio status */
export interface PortfolioStatus {
  totalValue: number
  cash: number
  positions: number
  dailyPnl: number
  totalReturn: number
}
/** Execute a live trade */
export declare function executeTrade(strategy: string, symbol: string, action: string, quantity: number, orderType?: string | undefined | null, limitPrice?: number | undefined | null): Promise<TradeExecution>
/** Trade execution result */
export interface TradeExecution {
  orderId: string
  strategy: string
  symbol: string
  action: string
  quantity: number
  status: string
  fillPrice: number
}
/** Run a comprehensive backtest */
export declare function runBacktest(strategy: string, symbol: string, startDate: string, endDate: string, useGpu?: boolean | undefined | null): Promise<StrategyBacktestResult>
/** Strategy backtest result */
export interface StrategyBacktestResult {
  strategy: string
  symbol: string
  startDate: string
  endDate: string
  totalReturn: number
  sharpeRatio: number
  maxDrawdown: number
  totalTrades: number
  winRate: number
}
/** Generate neural network forecasts */
export declare function neuralForecast(symbol: string, horizon: number, useGpu?: boolean | undefined | null, confidenceLevel?: number | undefined | null): Promise<NeuralForecast>
/** Confidence interval for predictions */
export interface ConfidenceInterval {
  lower: number
  upper: number
}
/** Neural forecast result */
export interface NeuralForecast {
  symbol: string
  horizon: number
  predictions: Array<number>
  confidenceIntervals: Array<ConfidenceInterval>
  modelAccuracy: number
}
/** Train a neural forecasting model */
export declare function neuralTrain(dataPath: string, modelType: string, epochs?: number | undefined | null, useGpu?: boolean | undefined | null): Promise<TrainingResult>
/** Training result */
export interface TrainingResult {
  modelId: string
  modelType: string
  trainingTimeMs: number
  finalLoss: number
  validationAccuracy: number
}
/** Evaluate a trained neural model */
export declare function neuralEvaluate(modelId: string, testData: string, useGpu?: boolean | undefined | null): Promise<EvaluationResult>
/** Evaluation result */
export interface EvaluationResult {
  modelId: string
  testSamples: number
  mae: number
  rmse: number
  mape: number
  r2Score: number
}
/** Get neural model status */
export declare function neuralModelStatus(modelId?: string | undefined | null): Promise<Array<ModelStatus>>
/** Model status */
export interface ModelStatus {
  modelId: string
  modelType: string
  status: string
  createdAt: string
  accuracy: number
}
/** Optimize neural model hyperparameters */
export declare function neuralOptimize(modelId: string, parameterRanges: string, useGpu?: boolean | undefined | null): Promise<OptimizationResult>
/** Optimization result */
export interface OptimizationResult {
  modelId: string
  bestParams: string
  bestScore: number
  trialsCompleted: number
  optimizationTimeMs: number
}
/** Run historical backtest with neural model */
export declare function neuralBacktest(modelId: string, startDate: string, endDate: string, benchmark?: string | undefined | null, useGpu?: boolean | undefined | null): Promise<NeuralBacktestResult>
/** Neural model backtest result */
export interface NeuralBacktestResult {
  modelId: string
  startDate: string
  endDate: string
  totalReturn: number
  sharpeRatio: number
  maxDrawdown: number
  winRate: number
  totalTrades: number
}
/** Get upcoming sports events */
export declare function getSportsEvents(sport: string, daysAhead?: number | undefined | null): Promise<Array<SportsEvent>>
/** Sports event */
export interface SportsEvent {
  eventId: string
  sport: string
  homeTeam: string
  awayTeam: string
  startTime: string
}
/** Get sports betting odds */
export declare function getSportsOdds(sport: string): Promise<Array<BettingOdds>>
/** Betting odds */
export interface BettingOdds {
  eventId: string
  market: string
  homeOdds: number
  awayOdds: number
  bookmaker: string
}
/** Find arbitrage opportunities */
export declare function findSportsArbitrage(sport: string, minProfitMargin?: number | undefined | null): Promise<Array<ArbitrageOpportunity>>
/** Arbitrage opportunity */
export interface ArbitrageOpportunity {
  eventId: string
  profitMargin: number
  betHome: BetAllocation
  betAway: BetAllocation
}
/** Bet allocation */
export interface BetAllocation {
  bookmaker: string
  odds: number
  stake: number
}
/** Calculate Kelly Criterion bet size */
export declare function calculateKellyCriterion(probability: number, odds: number, bankroll: number): Promise<KellyCriterion>
/** Kelly Criterion result */
export interface KellyCriterion {
  probability: number
  odds: number
  bankroll: number
  kellyFraction: number
  suggestedStake: number
}
/** Execute a sports bet */
export declare function executeSportsBet(marketId: string, selection: string, stake: number, odds: number, validateOnly?: boolean | undefined | null): Promise<BetExecution>
/** Bet execution result */
export interface BetExecution {
  betId: string
  marketId: string
  selection: string
  stake: number
  odds: number
  status: string
  potentialReturn: number
}
/** Create a new syndicate */
export declare function createSyndicate(syndicateId: string, name: string, description?: string | undefined | null): Promise<Syndicate>
/** Syndicate structure */
export interface Syndicate {
  syndicateId: string
  name: string
  description: string
  totalCapital: number
  memberCount: number
  createdAt: string
}
/** Add member to syndicate */
export declare function addSyndicateMember(syndicateId: string, name: string, email: string, role: string, initialContribution: number): Promise<SyndicateMember>
/** Syndicate member */
export interface SyndicateMember {
  memberId: string
  syndicateId: string
  name: string
  email: string
  role: string
  contribution: number
  profitShare: number
}
/** Get syndicate status */
export declare function getSyndicateStatus(syndicateId: string): Promise<SyndicateStatus>
/** Syndicate status */
export interface SyndicateStatus {
  syndicateId: string
  totalCapital: number
  activeBets: number
  totalProfit: number
  roi: number
  memberCount: number
}
/** Allocate syndicate funds */
export declare function allocateSyndicateFunds(syndicateId: string, opportunities: string, strategy?: string | undefined | null): Promise<FundAllocation>
/** Fund allocation result */
export interface FundAllocation {
  syndicateId: string
  totalAllocated: number
  allocations: Array<Allocation>
  expectedReturn: number
  riskScore: number
}
/** Individual allocation */
export interface Allocation {
  opportunityId: string
  amount: number
  expectedReturn: number
}
/** Distribute profits to members */
export declare function distributeSyndicateProfits(syndicateId: string, totalProfit: number, model?: string | undefined | null): Promise<ProfitDistribution>
/** Profit distribution result */
export interface ProfitDistribution {
  syndicateId: string
  totalProfit: number
  distributions: Array<MemberDistribution>
  distributionDate: string
}
/** Member profit distribution */
export interface MemberDistribution {
  memberId: string
  amount: number
  percentage: number
}
/** Get available prediction markets */
export declare function getPredictionMarkets(category?: string | undefined | null, limit?: number | undefined | null): Promise<Array<PredictionMarket>>
/** Prediction market */
export interface PredictionMarket {
  marketId: string
  question: string
  category: string
  volume: number
  endDate: string
}
/** Analyze market sentiment */
export declare function analyzeMarketSentiment(marketId: string): Promise<MarketSentiment>
/** Market sentiment */
export interface MarketSentiment {
  marketId: string
  bullishProbability: number
  bearishProbability: number
  volumeTrend: string
  sentimentScore: number
}
/** Create E2B sandbox */
export declare function createE2bSandbox(name: string, template?: string | undefined | null): Promise<E2BSandbox>
/** E2B sandbox */
export interface E2BSandbox {
  sandboxId: string
  name: string
  template: string
  status: string
  createdAt: string
}
/** Execute process in sandbox */
export declare function executeE2bProcess(sandboxId: string, command: string): Promise<ProcessExecution>
/** Process execution result */
export interface ProcessExecution {
  sandboxId: string
  command: string
  exitCode: number
  stdout: string
  stderr: string
}
/** Swarm topology types for distributed agent coordination */
export const enum SwarmTopology {
  /** Mesh topology - fully connected peer-to-peer network */
  Mesh = 0,
  /** Hierarchical topology - tree-structured with leader-follower relationships */
  Hierarchical = 1,
  /** Ring topology - agents connected in circular formation */
  Ring = 2,
  /** Star topology - centralized hub with spoke agents */
  Star = 3
}

/** Trading agent types for E2B deployment */
export const enum AgentType {
  /** Momentum trading strategy agent */
  Momentum = 0,
  /** Mean reversion trading strategy agent */
  MeanReversion = 1,
  /** Pairs trading strategy agent */
  Pairs = 2,
  /** Neural network-based trading agent */
  Neural = 3,
  /** Arbitrage opportunity detection agent */
  Arbitrage = 4
}

/** Distribution strategies for task allocation */
export const enum DistributionStrategy {
  /** Round-robin task distribution */
  RoundRobin = 0,
  /** Distribute to least loaded agent */
  LeastLoaded = 1,
  /** Specialized agents for specific tasks */
  Specialized = 2,
  /** Consensus-based decision making */
  Consensus = 3,
  /** Adaptive strategy based on performance */
  Adaptive = 4
}

/** Swarm configuration for initialization */
export interface SwarmConfig {
  /** Swarm topology type */
  topology: SwarmTopology
  /** Maximum number of agents in swarm */
  maxAgents: number
  /** Distribution strategy for task allocation */
  distributionStrategy: DistributionStrategy
  /** Enable GPU acceleration */
  enableGpu: boolean
  /** Auto-scaling enabled */
  autoScaling: boolean
  /** Minimum agents to maintain */
  minAgents?: number
  /** Maximum memory per agent (MB) */
  maxMemoryMb?: number
  /** Agent timeout in seconds */
  timeoutSecs?: number
}

/** Swarm initialization result */
export interface SwarmInit {
  /** Unique swarm identifier */
  swarmId: string
  /** Swarm topology type */
  topology: string
  /** Number of agents deployed */
  agentCount: number
  /** Swarm status */
  status: string
  /** Timestamp of creation */
  createdAt: string
}

/** Trading swarm status information */
export interface SwarmStatus {
  /** Swarm identifier */
  swarmId: string
  /** Current swarm status */
  status: string
  /** Number of active agents */
  activeAgents: number
  /** Number of idle agents */
  idleAgents: number
  /** Number of failed agents */
  failedAgents: number
  /** Total trades executed */
  totalTrades: number
  /** Current profit/loss */
  totalPnl: number
  /** Swarm uptime in seconds */
  uptimeSecs: number
  /** Last update timestamp */
  lastUpdate: string
}

/** Swarm health metrics */
export interface SwarmHealth {
  /** Overall health status */
  status: string
  /** System CPU usage percentage */
  cpuUsage: number
  /** System memory usage percentage */
  memoryUsage: number
  /** Average agent response time (ms) */
  avgResponseTime: number
  /** Number of healthy agents */
  healthyAgents: number
  /** Number of degraded agents */
  degradedAgents: number
  /** Error rate (errors per minute) */
  errorRate: number
  /** Last health check timestamp */
  lastCheck: string
}


/** Agent parameters for E2B deployment */
export interface AgentParameters {
  maxPositionSize?: number
  stopLoss?: number
  takeProfit?: number
  timeframe?: string
  indicators?: string[]
  riskPerTrade?: number
  [key: string]: any
}

/** Agent deployment configuration */
export interface AgentDeployment {
  /** Agent identifier */
  agentId: string
  /** Sandbox identifier */
  sandboxId: string
  /** Agent type */
  agentType: string
  /** Trading symbols assigned */
  symbols: Array<string>
  /** Agent status */
  status: string
  /** Deployment timestamp */
  deployedAt: string
  /** Strategy parameters - can be object or JSON string for backward compatibility */
  parameters?: AgentParameters | string
}

/** Agent status information */
export interface AgentStatus {
  /** Agent identifier */
  agentId: string
  /** Current agent status */
  status: string
  /** Sandbox identifier */
  sandboxId: string
  /** Agent type */
  agentType: string
  /** Number of active trades */
  activeTrades: number
  /** Agent profit/loss */
  pnl: number
  /** CPU usage percentage */
  cpuUsage: number
  /** Memory usage (MB) */
  memoryUsageMb: number
  /** Last activity timestamp */
  lastActivity: string
  /** Error count */
  errorCount: number
}

/** Trading swarm performance metrics */
export interface SwarmPerformance {
  /** Swarm identifier */
  swarmId: string
  /** Time period for metrics */
  periodSecs: number
  /** Total return percentage */
  totalReturn: number
  /** Sharpe ratio */
  sharpeRatio: number
  /** Maximum drawdown percentage */
  maxDrawdown: number
  /** Win rate percentage */
  winRate: number
  /** Total trades executed */
  totalTrades: number
  /** Average trade duration (seconds) */
  avgTradeDuration: number
  /** Average profit per trade */
  avgProfitPerTrade: number
  /** Profit factor */
  profitFactor: number
}

/** Swarm metrics summary */
export interface SwarmMetrics {
  /** Swarm identifier */
  swarmId: string
  /** Number of active agents */
  activeAgents: number
  /** Total throughput (trades/hour) */
  throughput: number
  /** Average latency (ms) */
  avgLatency: number
  /** Success rate percentage */
  successRate: number
  /** Total profit/loss */
  totalPnl: number
  /** Resource utilization percentage */
  resourceUtilization: number
  /** Timestamp of metrics */
  timestamp: string
}

/** Swarm scaling result */
export interface ScaleResult {
  /** Swarm identifier */
  swarmId: string
  /** Previous agent count */
  previousCount: number
  /** New agent count */
  newCount: number
  /** Agents added */
  agentsAdded: number
  /** Agents removed */
  agentsRemoved: number
  /** Scaling status */
  status: string
  /** Timestamp of scaling operation */
  scaledAt: string
}

/** Swarm strategy execution result */
export interface SwarmExecution {
  /** Execution identifier */
  executionId: string
  /** Swarm identifier */
  swarmId: string
  /** Strategy name */
  strategy: string
  /** Trading symbols */
  symbols: Array<string>
  /** Number of agents participating */
  agentsUsed: number
  /** Execution status */
  status: string
  /** Expected return */
  expectedReturn: number
  /** Risk score */
  riskScore: number
  /** Execution timestamp */
  executedAt: string
}

/** Swarm rebalancing result */
export interface SwarmRebalanceResult {
  /** Swarm identifier */
  swarmId: string
  /** Rebalancing status */
  status: string
  /** Number of trades executed */
  tradesExecuted: number
  /** Agents rebalanced */
  agentsRebalanced: number
  /** Total rebalancing cost */
  totalCost: number
  /** New portfolio allocation */
  newAllocation: string
  /** Rebalance timestamp */
  rebalancedAt: string
}

/**
 * Initialize E2B trading swarm with specified topology
 * Creates a distributed swarm of trading agents for parallel execution
 *
 * @param topology - Swarm topology type ("mesh", "hierarchical", "ring", "star")
 * @param config - Swarm configuration object or JSON string with swarm parameters
 * @returns Promise resolving to SwarmInit with swarm details
 */
export declare function initE2bSwarm(topology: string, config: SwarmConfig | string): Promise<SwarmInit>

/**
 * Deploy a trading agent to an E2B sandbox
 * Provisions an isolated trading agent with specified strategy
 *
 * @param sandboxId - Target sandbox identifier
 * @param agentType - Type of trading agent to deploy
 * @param symbols - Array of trading symbols to monitor
 * @param params - Optional strategy parameters object or JSON string
 * @returns Promise resolving to AgentDeployment with deployment details
 */
export declare function deployTradingAgent(sandboxId: string, agentType: string, symbols: Array<string>, params?: AgentParameters | string | undefined | null): Promise<AgentDeployment>

/**
 * Get current status of trading swarm
 * Retrieves real-time swarm health and performance metrics
 *
 * @param swarmId - Optional swarm identifier (uses active swarm if not provided)
 * @returns Promise resolving to SwarmStatus with current state
 */
export declare function getSwarmStatus(swarmId?: string | undefined | null): Promise<SwarmStatus>

/**
 * Scale swarm agent count dynamically
 * Adjusts the number of active trading agents based on load
 *
 * @param swarmId - Swarm identifier to scale
 * @param targetCount - Target number of agents
 * @returns Promise resolving to ScaleResult with scaling details
 */
export declare function scaleSwarm(swarmId: string, targetCount: number): Promise<ScaleResult>

/**
 * Shutdown trading swarm gracefully
 * Stops all agents, closes positions, and cleans up resources
 *
 * @param swarmId - Swarm identifier to shutdown
 * @returns Promise resolving to status message
 */
export declare function shutdownSwarm(swarmId: string): Promise<string>

/**
 * Execute trading strategy across swarm
 * Distributes strategy execution across multiple agents
 *
 * @param swarmId - Swarm identifier
 * @param strategy - Strategy name to execute
 * @param symbols - Array of trading symbols
 * @returns Promise resolving to SwarmExecution with execution details
 */
export declare function executeSwarmStrategy(swarmId: string, strategy: string, symbols: Array<string>): Promise<SwarmExecution>

/**
 * Get swarm performance analytics
 * Retrieves comprehensive performance metrics for the swarm
 *
 * @param swarmId - Swarm identifier
 * @returns Promise resolving to SwarmPerformance with metrics
 */
export declare function getSwarmPerformance(swarmId: string): Promise<SwarmPerformance>

/**
 * Rebalance swarm portfolio allocation
 * Adjusts positions across agents to maintain target allocation
 *
 * @param swarmId - Swarm identifier
 * @returns Promise resolving to SwarmRebalanceResult with rebalancing details
 */
export declare function rebalanceSwarm(swarmId: string): Promise<SwarmRebalanceResult>

/**
 * Monitor overall swarm health
 * Provides system-wide health check across all swarms
 *
 * @returns Promise resolving to SwarmHealth with health metrics
 */
export declare function monitorSwarmHealth(): Promise<SwarmHealth>

/**
 * Get detailed swarm metrics
 * Retrieves operational metrics for monitoring and optimization
 *
 * @param swarmId - Swarm identifier
 * @returns Promise resolving to SwarmMetrics with detailed metrics
 */
export declare function getSwarmMetrics(swarmId: string): Promise<SwarmMetrics>

/**
 * List all agents in a swarm
 * Retrieves status information for all swarm agents
 *
 * @param swarmId - Swarm identifier
 * @returns Promise resolving to array of AgentStatus
 */
export declare function listSwarmAgents(swarmId: string): Promise<Array<AgentStatus>>

/**
 * Get individual agent status
 * Retrieves detailed status for a specific agent
 *
 * @param agentId - Agent identifier
 * @returns Promise resolving to AgentStatus
 */
export declare function getAgentStatus(agentId: string): Promise<AgentStatus>

/**
 * Stop a specific agent in the swarm
 * Gracefully stops an agent and redistributes its work
 *
 * @param agentId - Agent identifier to stop
 * @returns Promise resolving to status message
 */
export declare function stopSwarmAgent(agentId: string): Promise<string>

/**
 * Restart a failed agent
 * Attempts to restart and recover a failed agent
 *
 * @param agentId - Agent identifier to restart
 * @returns Promise resolving to AgentDeployment with new deployment details
 */
export declare function restartSwarmAgent(agentId: string): Promise<AgentDeployment>

/** Get fantasy sports data (placeholder) */
export declare function getFantasyData(sport: string): Promise<string>
/** Analyze news sentiment */
export declare function analyzeNews(symbol: string, lookbackHours?: number | undefined | null): Promise<NewsSentiment>
/** News sentiment result */
export interface NewsSentiment {
  symbol: string
  sentimentScore: number
  articleCount: number
  positiveRatio: number
  negativeRatio: number
}
/** Control news collection */
export declare function controlNewsCollection(action: string, symbols?: Array<string> | undefined | null): Promise<string>
/** Comprehensive portfolio risk analysis */
export declare function riskAnalysis(portfolio: string, useGpu?: boolean | undefined | null): Promise<RiskAnalysis>
/** Risk analysis result */
export interface RiskAnalysis {
  var95: number
  cvar95: number
  sharpeRatio: number
  maxDrawdown: number
  beta: number
}
/** Optimize strategy parameters */
export declare function optimizeStrategy(strategy: string, symbol: string, parameterRanges: string, useGpu?: boolean | undefined | null): Promise<StrategyOptimization>
/** Strategy optimization result */
export interface StrategyOptimization {
  strategy: string
  symbol: string
  bestParams: string
  bestSharpe: number
  optimizationTimeMs: number
}
/** Calculate portfolio rebalancing */
export declare function portfolioRebalance(targetAllocations: string, currentPortfolio?: string | undefined | null): Promise<PortfolioRebalanceResult>
/** Portfolio rebalance result */
export interface PortfolioRebalanceResult {
  tradesNeeded: Array<RebalanceTrade>
  estimatedCost: number
  targetAchieved: boolean
}
/** Rebalance trade */
export interface RebalanceTrade {
  symbol: string
  action: string
  quantity: number
}
/** Analyze asset correlations */
export declare function correlationAnalysis(symbols: Array<string>, useGpu?: boolean | undefined | null): Promise<CorrelationMatrix>
/** Correlation matrix */
export interface CorrelationMatrix {
  symbols: Array<string>
  matrix: Array<Array<number>>
  analysisPeriod: string
}
/** User roles for RBAC */
export const enum UserRole {
  /** Read-only access */
  ReadOnly = 0,
  /** Standard user with trading capabilities */
  User = 1,
  /** Administrative access */
  Admin = 2,
  /** System service account */
  Service = 3
}
/** Authenticated user information */
export interface AuthUser {
  userId: string
  username: string
  role: UserRole
  apiKey: string
  createdAt: string
  lastActivity: string
}
/** API Key statistics */
export interface ApiKeyStats {
  keyId: string
  username: string
  role: UserRole
  createdAt: string
  expiresAt?: string
  isActive: boolean
  rateLimit: number
}
/** Initialize authentication system */
export declare function initAuth(jwtSecret?: string | undefined | null): string
/** Create a new API key */
export declare function createApiKey(username: string, role: string, rateLimit?: number | undefined | null, expiresInDays?: number | undefined | null): string
/** Validate an API key */
export declare function validateApiKey(apiKey: string): AuthUser
/** Revoke an API key */
export declare function revokeApiKey(apiKey: string): string
/** Generate JWT token */
export declare function generateToken(apiKey: string): string
/** Validate JWT token */
export declare function validateToken(token: string): AuthUser
/** Check authorization for an operation */
export declare function checkAuthorization(apiKey: string, operation: string, requiredRole: string): boolean
/** Rate limit configuration */
export interface RateLimitConfig {
  /** Maximum requests per minute */
  maxRequestsPerMinute: number
  /** Maximum burst size */
  burstSize: number
  /** Window duration in seconds */
  windowDurationSecs: number
}
/** Rate limit statistics */
export interface RateLimitStats {
  tokensAvailable: number
  maxTokens: number
  refillRate: number
  totalRequests: number
  blockedRequests: number
  successRate: number
}
/** Initialize rate limiter */
export declare function initRateLimiter(config?: RateLimitConfig | undefined | null): string
/** Check rate limit for an identifier */
export declare function checkRateLimit(identifier: string, tokens?: number | undefined | null): boolean
/** Get rate limit statistics */
export declare function getRateLimitStats(identifier: string): RateLimitStats
/** Reset rate limit for an identifier (admin operation) */
export declare function resetRateLimit(identifier: string): string
/** Check DDoS protection */
export declare function checkDdosProtection(ipAddress: string, requestCount?: number | undefined | null): boolean
/** Get list of blocked IPs */
export declare function getBlockedIps(): Array<string>
/** Block an IP address (admin operation) */
export declare function blockIp(ipAddress: string): string
/** Unblock an IP address (admin operation) */
export declare function unblockIp(ipAddress: string): string
/** Cleanup old rate limit entries */
export declare function cleanupRateLimiter(): string
/** Audit event severity levels */
export const enum AuditLevel {
  /** Informational event */
  Info = 0,
  /** Warning event */
  Warning = 1,
  /** Security-related event */
  Security = 2,
  /** Error event */
  Error = 3,
  /** Critical security event */
  Critical = 4
}
/** Audit event categories */
export const enum AuditCategory {
  /** Authentication events */
  Authentication = 0,
  /** Authorization/permission checks */
  Authorization = 1,
  /** Trading operations */
  Trading = 2,
  /** Portfolio changes */
  Portfolio = 3,
  /** Configuration changes */
  Configuration = 4,
  /** Data access */
  DataAccess = 5,
  /** System events */
  System = 6,
  /** Security events */
  Security = 7
}

/** Audit event details */
export interface AuditDetails {
  previousValue?: string
  newValue?: string
  reason?: string
  metadata?: Record<string, any>
}

/** Audit event structure */
export interface AuditEvent {
  /** Unique event ID */
  eventId: string
  /** Timestamp of event */
  timestamp: string
  /** Event level */
  level: AuditLevel
  /** Event category */
  category: AuditCategory
  /** User ID (if applicable) */
  userId?: string
  /** Username (if applicable) */
  username?: string
  /** IP address */
  ipAddress?: string
  /** Action performed */
  action: string
  /** Resource affected */
  resource?: string
  /** Event outcome (success/failure) */
  outcome: string
  /** Additional details - can be object or JSON string for backward compatibility */
  details?: AuditDetails | string
  /** Error message (if outcome is failure) */
  errorMessage?: string
}
/** Initialize audit logger */
export declare function initAuditLogger(maxEvents?: number | undefined | null, logToConsole?: boolean | undefined | null, logToFile?: boolean | undefined | null): string
/** Log an audit event */
export declare function logAuditEvent(level: string, category: string, action: string, outcome: string, userId?: string | undefined | null, username?: string | undefined | null, ipAddress?: string | undefined | null, resource?: string | undefined | null, details?: AuditDetails | string | undefined | null): string
/** Get recent audit events */
export declare function getAuditEvents(limit?: number | undefined | null): Array<AuditEvent>
/** Get audit statistics */
export declare function getAuditStatistics(): string
/** Clear audit log (admin operation) */
export declare function clearAuditLog(): string
/** Request context with security information */
export interface SecurityContext {
  userId?: string
  username?: string
  role: string
  ipAddress: string
  userAgent?: string
  requestId: string
  timestamp: string
}
/** NAPI functions for input sanitization and validation */
export declare function sanitizeInput(input: string): string
export declare function validateTradingParams(symbol: string, quantity: number, price?: number | undefined | null): boolean
export declare function validateEmailFormat(email: string): boolean
export declare function validateApiKeyFormat(key: string): boolean
export declare function checkSecurityThreats(input: string): Array<string>
/** CORS configuration */
export interface CorsConfig {
  /** Allowed origins */
  allowedOrigins: Array<string>
  /** Allowed methods */
  allowedMethods: Array<string>
  /** Allowed headers */
  allowedHeaders: Array<string>
  /** Exposed headers */
  exposedHeaders: Array<string>
  /** Allow credentials */
  allowCredentials: boolean
  /** Max age for preflight cache (seconds) */
  maxAge: number
}
/** Security headers configuration */
export interface SecurityHeaders {
  /** Strict-Transport-Security header */
  hstsMaxAge: number
  /** X-Frame-Options */
  frameOptions: string
  /** X-Content-Type-Options */
  contentTypeOptions: boolean
  /** X-XSS-Protection */
  xssProtection: boolean
  /** Referrer-Policy */
  referrerPolicy: string
  /** Content-Security-Policy */
  csp?: string
}
/** Initialize security configuration */
export declare function initSecurityConfig(corsConfig?: CorsConfig | undefined | null, requireHttps?: boolean | undefined | null): string
/** Get CORS headers for a request */
export declare function getCorsHeaders(origin?: string | undefined | null): string
/** Get security headers */
export declare function getSecurityHeaders(): string
/** Check if IP is allowed */
export declare function checkIpAllowed(ip: string): boolean
/** Check if origin is allowed for CORS */
export declare function checkCorsOrigin(origin: string): boolean
/** Add IP to blacklist (admin operation) */
export declare function addIpToBlacklist(ip: string): string
/** Remove IP from blacklist (admin operation) */
export declare function removeIpFromBlacklist(ip: string): string
/**
 * Initialize the neural-trader native module
 * Sets up logging, validates configuration, and prepares runtime
 */
export declare function initNeuralTrader(config?: string | undefined | null): Promise<string>
/** Get system information and capabilities */
export declare function getSystemInfo(): SystemInfo
/** System information structure */
export interface SystemInfo {
  version: string
  rustVersion: string
  buildTimestamp: string
  features: Array<string>
  totalTools: number
}
/** Health check endpoint */
export declare function healthCheck(): Promise<HealthStatus>
/** Health status structure */
export interface HealthStatus {
  status: string
  timestamp: string
  uptimeSeconds: number
}
/** Shutdown the neural-trader module gracefully */
export declare function shutdown(): Promise<string>
/** Fund allocation engine for automated bankroll management */
export declare class FundAllocationEngine {
  /** Create new fund allocation engine */
  constructor(syndicateId: string, totalBankroll: string)
  /** Allocate funds for a betting opportunity */
  allocateFunds(opportunity: BettingOpportunity, strategy: AllocationStrategy): AllocationResult
  /** Update exposure tracking after bet placement */
  updateExposure(betPlaced: string): void
  /** Get current exposure summary */
  getExposureSummary(): string
}
/** Profit distribution system */
export declare class ProfitDistributionSystem {
  /** Create new profit distribution system */
  constructor(syndicateId: string)
  /** Calculate profit distribution for members */
  calculateDistribution(totalProfit: string, membersJson: string, model: DistributionModel): string
}
/** Withdrawal manager */
export declare class WithdrawalManager {
  /** Create new withdrawal manager */
  constructor(syndicateId: string)
  /** Request withdrawal */
  requestWithdrawal(memberId: string, memberBalance: string, amount: string, isEmergency: boolean): string
  /** Get withdrawal history */
  getWithdrawalHistory(): string
}
/** Member manager */
export declare class MemberManager {
  /** Create new member manager */
  constructor(syndicateId: string)
  /** Add new member */
  addMember(name: string, email: string, role: MemberRole, initialContribution: string): string
  /** Update member role */
  updateMemberRole(memberId: string, newRole: MemberRole, authorizedBy: string): void
  /** Suspend member */
  suspendMember(memberId: string, reason: string, authorizedBy: string): void
  /** Update member capital contribution */
  updateContribution(memberId: string, amount: string): void
  /** Track bet outcome for member performance */
  trackBetOutcome(memberId: string, betDetails: string): void
  /** Get member performance report */
  getMemberPerformanceReport(memberId: string): string
  /** Get total syndicate capital */
  getTotalCapital(): string
  /** List all members */
  listMembers(activeOnly: boolean): string
  /** Get member by ID */
  getMember(memberId: string): string
  /** Update member statistics */
  updateMemberStatistics(memberId: string, statistics: MemberStatisticsUpdate | string): void
  /** Calculate member alpha (skill-based returns) */
  calculateMemberAlpha(memberId: string): string
  /** Get member count */
  getMemberCount(): number
  /** Get active member count */
  getActiveMemberCount(): number
}
/** Performance tracker */
export declare class MemberPerformanceTracker {
  /** Create new performance tracker */
  constructor()
  /** Track bet outcome */
  trackBetOutcome(memberId: string, betDetails: string): void
  /** Get performance history */
  getPerformanceHistory(memberId: string): string
  /** Identify member strengths */
  identifyMemberStrengths(memberId: string): string
}
/** Voting system for syndicate decisions */
export declare class VotingSystem {
  /** Create new voting system */
  constructor(syndicateId: string)
  /** Create a new vote */
  createVote(proposalType: string, proposalDetails: string, proposedBy: string, votingPeriodHours?: number | undefined | null): string
  /** Cast a vote */
  castVote(voteId: string, memberId: string, decision: string, votingWeight: number): boolean
  /** Get vote results */
  getVoteResults(voteId: string): string
  /** Finalize vote */
  finalizeVote(voteId: string): string
  /** List all active votes */
  listActiveVotes(): string
  /** Get vote details */
  getVoteDetails(voteId: string): string
  /** Check if member has voted */
  hasVoted(voteId: string, memberId: string): boolean
  /** Get member's vote */
  getMemberVote(voteId: string, memberId: string): string
}
/** Collaboration hub for syndicate communication */
export declare class CollaborationHub {
  /** Create new collaboration hub */
  constructor(syndicateId: string)
  /** Create a new channel */
  createChannel(name: string, description: string, channelType: string): string
  /** Add member to channel */
  addMemberToChannel(channelId: string, memberId: string): void
  /** Post message to channel */
  postMessage(channelId: string, authorId: string, content: string, messageType: string, attachments: Array<string>): string
  /** Get channel messages */
  getChannelMessages(channelId: string, limit?: number | undefined | null): string
  /** List all channels */
  listChannels(): string
  /** Get channel details */
  getChannelDetails(channelId: string): string
}
