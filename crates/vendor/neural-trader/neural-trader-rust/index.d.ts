/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Broker configuration for connection */
export interface BrokerConfig {
  brokerType: string
  apiKey: string
  apiSecret: string
  baseUrl?: string
  paperTrading: boolean
  exchange?: string
}
/** Order placement request */
export interface OrderRequest {
  symbol: string
  side: string
  orderType: string
  quantity: number
  limitPrice?: number
  stopPrice?: number
  timeInForce: string
}
/** Order response from broker */
export interface OrderResponse {
  orderId: string
  brokerOrderId: string
  status: string
  filledQuantity: number
  filledPrice?: number
  timestamp: string
}
/** Account balance information */
export interface AccountBalance {
  cash: number
  equity: number
  buyingPower: number
  currency: string
}
/** List all available broker types */
export declare function listBrokerTypes(): Array<string>
/** Validate broker configuration */
export declare function validateBrokerConfig(config: BrokerConfig): boolean
/** Model type enumeration */
export const enum ModelType {
  NHITS = 'NHITS',
  LSTMAttention = 'LSTMAttention',
  Transformer = 'Transformer'
}
/** Model configuration */
export interface ModelConfig {
  modelType: string
  inputSize: number
  horizon: number
  hiddenSize: number
  numLayers: number
  dropout: number
  learningRate: number
}
/** Training configuration */
export interface TrainingConfig {
  epochs: number
  batchSize: number
  validationSplit: number
  earlyStoppingPatience: number
  useGpu: boolean
}
/** Training metrics */
export interface TrainingMetrics {
  epoch: number
  trainLoss: number
  valLoss: number
  trainMae: number
  valMae: number
}
/** Prediction result with confidence intervals */
export interface PredictionResult {
  predictions: Array<number>
  lowerBound: Array<number>
  upperBound: Array<number>
  timestamp: string
}
/** List available model types */
export declare function listModelTypes(): Array<string>
/** Risk calculation configuration */
export interface RiskConfig {
  confidenceLevel: number
  lookbackPeriods: number
  method: string
}
/** VaR calculation result */
export interface VaRResult {
  varAmount: number
  varPercentage: number
  confidenceLevel: number
  method: string
  portfolioValue: number
}
/** CVaR (Expected Shortfall) result */
export interface CVaRResult {
  cvarAmount: number
  cvarPercentage: number
  varAmount: number
  confidenceLevel: number
}
/** Drawdown metrics */
export interface DrawdownMetrics {
  maxDrawdown: number
  maxDrawdownDuration: number
  currentDrawdown: number
  recoveryFactor: number
}
/** Kelly Criterion result for position sizing */
export interface KellyResult {
  kellyFraction: number
  halfKelly: number
  quarterKelly: number
  winRate: number
  avgWin: number
  avgLoss: number
}
/** Position sizing recommendation */
export interface PositionSize {
  shares: number
  dollarAmount: number
  percentageOfPortfolio: number
  maxLoss: number
  reasoning: string
}
/** Calculate Sharpe Ratio */
export declare function calculateSharpeRatio(returns: Array<number>, riskFreeRate: number, annualizationFactor: number): number
/** Calculate Sortino Ratio (uses downside deviation only) */
export declare function calculateSortinoRatio(returns: Array<number>, targetReturn: number, annualizationFactor: number): number
/** Calculate maximum leverage allowed */
export declare function calculateMaxLeverage(portfolioValue: number, volatility: number, maxVolatilityTarget: number): number
/** Backtest configuration */
export interface BacktestConfig {
  initialCapital: number
  startDate: string
  endDate: string
  commission: number
  slippage: number
  useMarkToMarket: boolean
}
/** Trade record from backtest */
export interface Trade {
  symbol: string
  entryDate: string
  exitDate: string
  entryPrice: number
  exitPrice: number
  quantity: number
  pnl: number
  pnlPercentage: number
  commissionPaid: number
}
/** Backtest performance metrics */
export interface BacktestMetrics {
  totalReturn: number
  annualReturn: number
  sharpeRatio: number
  sortinoRatio: number
  maxDrawdown: number
  winRate: number
  profitFactor: number
  totalTrades: number
  winningTrades: number
  losingTrades: number
  avgWin: number
  avgLoss: number
  largestWin: number
  largestLoss: number
  finalEquity: number
}
/** Backtest result */
export interface BacktestResult {
  metrics: BacktestMetrics
  trades: Array<Trade>
  equityCurve: Array<number>
  dates: Array<string>
}
/** Compare multiple backtest results */
export declare function compareBacktests(results: Array<BacktestResult>): string
/** Market data bar/candle */
export interface Bar {
  symbol: string
  timestamp: string
  open: number
  high: number
  low: number
  close: number
  volume: number
}
/** Real-time quote */
export interface Quote {
  symbol: string
  bid: number
  ask: number
  bidSize: number
  askSize: number
  last: number
  lastSize: number
  timestamp: string
}
/** Market data provider configuration */
export interface MarketDataConfig {
  provider: string
  apiKey?: string
  apiSecret?: string
  websocketEnabled: boolean
}
/** Calculate technical indicators */
export declare function calculateSma(prices: Array<number>, period: number): Array<number>
/** Calculate Relative Strength Index (RSI) */
export declare function calculateRsi(prices: Array<number>, period: number): Array<number>
/** List available market data providers */
export declare function listDataProviders(): Array<string>
/** Trading signal from a strategy */
export interface Signal {
  id: string
  strategyId: string
  symbol: string
  direction: string
  confidence: number
  entryPrice?: number
  stopLoss?: number
  takeProfit?: number
  reasoning: string
  timestampNs: number
}
/** Strategy configuration */
export interface StrategyConfig {
  name: string
  symbols: Array<string>
  parameters: string
}
/** Portfolio position */
export interface Position {
  symbol: string
  quantity: number
  avgCost: number
  marketValue: number
  unrealizedPnl: number
  realizedPnl: number
}
/** Portfolio optimization result */
export interface PortfolioOptimization {
  allocations: Record<string, number>
  expectedReturn: number
  risk: number
  sharpeRatio: number
}
/** Risk metrics */
export interface RiskMetrics {
  var95: number
  cvar95: number
  beta: number
  sharpeRatio: number
  maxDrawdown: number
}
/** Portfolio optimizer configuration */
export interface OptimizerConfig {
  riskFreeRate: number
  maxPositionSize?: number
  minPositionSize?: number
}
/** JavaScript-compatible bar data */
export interface JsBar {
  symbol: string
  timestamp: string
  open: string
  high: string
  low: string
  close: string
  volume: string
}
/** JavaScript-compatible signal data */
export interface JsSignal {
  id: string
  strategyId: string
  symbol: string
  direction: string
  confidence: number
  entryPrice?: string
  stopLoss?: string
  takeProfit?: string
  quantity?: string
  reasoning: string
  timestamp: string
}
/** JavaScript-compatible order data */
export interface JsOrder {
  id: string
  symbol: string
  side: string
  orderType: string
  quantity: string
  limitPrice?: string
  stopPrice?: string
  timeInForce: string
}
/** JavaScript-compatible position data */
export interface JsPosition {
  symbol: string
  quantity: string
  avgEntryPrice: string
  currentPrice: string
  unrealizedPnl: string
  side: string
  marketValue: string
}
/** JavaScript-compatible configuration */
export interface JsConfig {
  apiKey?: string
  apiSecret?: string
  baseUrl?: string
  paperTrading: boolean
}
/**
 * Fetch historical market data
 *
 * # Arguments
 *
 * * `symbol` - Trading symbol (e.g., "AAPL")
 * * `start` - Start timestamp (RFC3339 format)
 * * `end` - End timestamp (RFC3339 format)
 * * `timeframe` - Bar timeframe (e.g., "1Min", "1Hour", "1Day")
 *
 * # Returns
 *
 * Array of bar objects with OHLCV data
 *
 * # Example
 *
 * ```javascript
 * const bars = await fetchMarketData('AAPL', '2024-01-01T00:00:00Z', '2024-01-31T23:59:59Z', '1Day');
 * console.log(`Fetched ${bars.length} bars`);
 * ```
 */
export declare function fetchMarketData(symbol: string, start: string, end: string, timeframe: string): Promise<NapiResult>
/**
 * Calculate technical indicators
 *
 * # Arguments
 *
 * * `bars` - Array of bar data
 * * `indicator` - Indicator name (e.g., "SMA", "RSI", "MACD")
 * * `params` - JSON string with indicator parameters
 *
 * # Returns
 *
 * Array of indicator values (same length as input bars, with NaN for warmup period)
 */
export declare function calculateIndicator(bars: Array<JsBar>, indicator: string, params: string): Promise<NapiResult>
/**
 * Encode bars to MessagePack buffer for efficient transfer
 *
 * For large datasets (>1000 bars), encoding to binary format provides
 * significant performance improvement over JSON serialization.
 *
 * # Example
 *
 * ```javascript
 * const buffer = encodeBarsToBuffer(bars);
 * // Transfer buffer over network
 * const decodedBars = decodeBarsFromBuffer(buffer);
 * ```
 */
export declare function encodeBarsToBuffer(bars: Array<JsBar>): NapiResult
/**
 * Decode bars from MessagePack buffer
 *
 * Companion function to `encodeBarsToBuffer` for efficient binary transfer.
 */
export declare function decodeBarsFromBuffer(buffer: Buffer): NapiResult
/**
 * Initialize tokio runtime with custom thread count
 *
 * Call this once at application startup to configure the async runtime.
 * If not called, defaults to number of CPU cores.
 *
 * # Arguments
 *
 * * `num_threads` - Number of worker threads (None = auto-detect)
 */
export declare function initRuntime(numThreads?: number | undefined | null): NapiResult
/**
 * Get version information
 *
 * Returns version strings for all components
 */
export interface VersionInfo {
  rustCore: string
  napiBindings: string
  rustCompiler: string
}
export declare function getVersionInfo(): NapiResult
/** Broker client for executing trades */
export declare class BrokerClient {
  /** Create a new broker client */
  constructor(config: BrokerConfig)
  /** Connect to the broker */
  connect(): Promise<boolean>
  /** Disconnect from broker */
  disconnect(): Promise<void>
  /** Place an order */
  placeOrder(order: OrderRequest): Promise<OrderResponse>
  /** Cancel an order */
  cancelOrder(orderId: string): Promise<boolean>
  /** Get order status */
  getOrderStatus(orderId: string): Promise<OrderResponse>
  /** Get account balance */
  getAccountBalance(): Promise<AccountBalance>
  /** List all open orders */
  listOrders(): Promise<Array<OrderResponse>>
  /** Get current positions */
  getPositions(): Promise<Array<JsPosition>>
}
/** Neural model for time series forecasting */
export declare class NeuralModel {
  /** Create a new neural model */
  constructor(config: ModelConfig)
  /** Train the model on historical data */
  train(data: Array<number>, targets: Array<number>, trainingConfig: TrainingConfig): Promise<Array<TrainingMetrics>>
  /** Make predictions */
  predict(inputData: Array<number>): Promise<PredictionResult>
  /** Save model to disk */
  save(path: string): Promise<string>
  /** Load model from disk */
  load(path: string): Promise<void>
  /** Get model info as JSON string */
  getInfo(): Promise<string>
}
/** Batch predictor for processing multiple time series */
export declare class BatchPredictor {
  /** Create a new batch predictor */
  constructor()
  /** Add a model to the batch */
  addModel(model: NeuralModel): Promise<number>
  /** Predict using all models in parallel */
  predictBatch(inputs: Array<Array<number>>): Promise<Array<PredictionResult>>
}
/** Risk manager for portfolio risk calculations */
export declare class RiskManager {
  /** Create a new risk manager */
  constructor(config: RiskConfig)
  /** Calculate Value at Risk */
  calculateVar(returns: Array<number>, portfolioValue: number): VaRResult
  /** Calculate Conditional VaR (Expected Shortfall) */
  calculateCvar(returns: Array<number>, portfolioValue: number): CVaRResult
  /** Calculate Kelly Criterion for position sizing */
  calculateKelly(winRate: number, avgWin: number, avgLoss: number): KellyResult
  /** Calculate drawdown metrics */
  calculateDrawdown(equityCurve: Array<number>): DrawdownMetrics
  /** Calculate recommended position size */
  calculatePositionSize(portfolioValue: number, pricePerShare: number, riskPerTrade: number, stopLossDistance: number): PositionSize
  /** Validate if a position passes risk limits */
  validatePosition(positionSize: number, portfolioValue: number, maxPositionPercentage: number): boolean
}
/** Backtesting engine */
export declare class BacktestEngine {
  /** Create a new backtest engine */
  constructor(config: BacktestConfig)
  /** Run backtest with strategy signals */
  run(signals: Array<Signal>, marketData: string): Promise<BacktestResult>
  /** Calculate performance metrics from equity curve */
  calculateMetrics(equityCurve: Array<number>): BacktestMetrics
  /** Export backtest results to CSV */
  exportTradesCsv(trades: Array<Trade>): string
}
/** Market data provider */
export declare class MarketDataProvider {
  /** Create a new market data provider */
  constructor(config: MarketDataConfig)
  /** Connect to market data provider */
  connect(): Promise<boolean>
  /** Disconnect from provider */
  disconnect(): Promise<void>
  /** Fetch historical bars */
  fetchBars(symbol: string, start: string, end: string, timeframe: string): Promise<Array<Bar>>
  /** Get latest quote */
  getQuote(symbol: string): Promise<Quote>
  /** Subscribe to real-time quotes */
  subscribeQuotes(symbols: Array<string>, callback: (...args: any[]) => any): SubscriptionHandle
  /** Get multiple quotes at once */
  getQuotesBatch(symbols: Array<string>): Promise<Array<Quote>>
  /** Check if provider is connected */
  isConnected(): Promise<boolean>
}
/** Subscription handle for cleanup */
export declare class SubscriptionHandle {
  /** Unsubscribe from quotes */
  unsubscribe(): Promise<void>
  /** Unsubscribe from signals */
  unsubscribe(): Promise<void>
}
/** Strategy runner that manages multiple strategies */
export declare class StrategyRunner {
  /** Create a new strategy runner */
  constructor()
  /** Add a momentum strategy */
  addMomentumStrategy(config: StrategyConfig): Promise<string>
  /** Add a mean reversion strategy */
  addMeanReversionStrategy(config: StrategyConfig): Promise<string>
  /** Add an arbitrage strategy */
  addArbitrageStrategy(config: StrategyConfig): Promise<string>
  /** Generate signals from all strategies */
  generateSignals(): Promise<Array<Signal>>
  /** Subscribe to signals with a callback */
  subscribeSignals(callback: (...args: any[]) => any): SubscriptionHandle
  /** Get list of active strategies */
  listStrategies(): Promise<Array<string>>
  /** Remove a strategy by ID */
  removeStrategy(strategyId: string): Promise<boolean>
}
/** Portfolio optimizer using modern portfolio theory */
export declare class PortfolioOptimizer {
  /** Create a new portfolio optimizer */
  constructor(config: OptimizerConfig)
  /** Optimize portfolio allocation */
  optimize(symbols: Array<string>, returns: Array<number>, covariance: Array<number>): Promise<PortfolioOptimization>
  /** Calculate risk metrics for given positions */
  calculateRisk(positions: Record<string, number>): RiskMetrics
}
/** Portfolio manager for tracking positions */
export declare class PortfolioManager {
  /** Create a new portfolio manager */
  constructor(initialCash: number)
  /** Get all positions */
  getPositions(): Promise<Array<Position>>
  /** Get position for a specific symbol */
  getPosition(symbol: string): Promise<Position | null>
  /** Update position (called after trade execution) */
  updatePosition(symbol: string, quantity: number, price: number): Promise<Position>
  /** Get current cash balance */
  getCash(): Promise<number>
  /** Get total portfolio value */
  getTotalValue(): Promise<number>
  /** Get total unrealized P&L */
  getTotalPnl(): Promise<number>
}
/**
 * Main Neural Trader system instance
 *
 * This is the primary interface for interacting with the trading system from Node.js.
 * It manages strategies, execution, and portfolio state.
 *
 * # Example
 *
 * ```javascript
 * const { NeuralTrader } = require('@neural-trader/rust-core');
 *
 * const trader = new NeuralTrader({
 *   apiKey: process.env.ALPACA_API_KEY,
 *   apiSecret: process.env.ALPACA_API_SECRET,
 *   paperTrading: true
 * });
 *
 * await trader.start();
 * const positions = await trader.getPositions();
 * await trader.stop();
 * ```
 */
export declare class NeuralTrader {
  /**
   * Create a new Neural Trader instance
   *
   * # Arguments
   *
   * * `config` - Configuration object with API credentials and settings
   */
  constructor(config: JsConfig)
  /**
   * Start the trading system
   *
   * Initializes connections to market data providers and brokers.
   * Returns a Promise that resolves when the system is ready.
   */
  start(): Promise<NapiResult>
  /**
   * Stop the trading system gracefully
   *
   * Closes all positions, cancels open orders, and disconnects from services.
   */
  stop(): Promise<NapiResult>
  /**
   * Get current portfolio positions
   *
   * Returns all open positions with real-time P&L.
   */
  getPositions(): Promise<NapiResult>
  /**
   * Place a new order
   *
   * # Arguments
   *
   * * `order` - Order details (symbol, side, quantity, etc.)
   *
   * # Returns
   *
   * Broker's order ID as a string
   */
  placeOrder(order: JsOrder): Promise<NapiResult>
  /**
   * Get current account balance
   *
   * Returns cash balance in account currency
   */
  getBalance(): Promise<NapiResult>
  /** Get current portfolio equity (cash + positions) */
  getEquity(): Promise<NapiResult>
}
