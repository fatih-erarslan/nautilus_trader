"""
Base strategy class for Polymarket trading strategies

This module provides the abstract base class and common utilities for all
Polymarket trading strategies, following the existing pattern in the codebase.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
from typing import Dict, List, Any, Optional, Tuple
import asyncio

from ..models import Market, Order, Trade
from ..api import PolymarketClient


logger = logging.getLogger(__name__)


class SignalStrength(Enum):
    """Trading signal strength levels"""
    VERY_WEAK = 1
    WEAK = 2
    MODERATE = 3
    STRONG = 4
    VERY_STRONG = 5


class SignalDirection(Enum):
    """Trading signal direction"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class TradingSignal:
    """Trading signal generated by a strategy"""
    market_id: str
    outcome: str
    direction: SignalDirection
    strength: SignalStrength
    target_price: Decimal
    size: Decimal
    confidence: float  # 0.0 to 1.0
    reasoning: str
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate signal data"""
        if not isinstance(self.target_price, Decimal):
            self.target_price = Decimal(str(self.target_price))
        if not isinstance(self.size, Decimal):
            self.size = Decimal(str(self.size))
            
        if not 0 <= self.confidence <= 1:
            raise ValueError("Confidence must be between 0 and 1")
        if self.target_price < 0 or self.target_price > 1:
            raise ValueError("Target price must be between 0 and 1")
        if self.size <= 0:
            raise ValueError("Size must be positive")
    
    @property
    def is_strong_signal(self) -> bool:
        """Check if this is a strong trading signal"""
        return self.strength.value >= SignalStrength.STRONG.value
    
    @property
    def expected_value(self) -> Decimal:
        """Calculate expected value of the signal"""
        return self.size * self.target_price * Decimal(str(self.confidence))


@dataclass
class StrategyConfig:
    """Configuration for trading strategies"""
    max_position_size: Decimal = Decimal('100.0')
    risk_per_trade: Decimal = Decimal('0.02')  # 2% of portfolio
    min_confidence: float = 0.6
    min_signal_strength: SignalStrength = SignalStrength.MODERATE
    max_trades_per_hour: int = 10
    max_markets_monitored: int = 50
    enable_gpu_acceleration: bool = True
    cache_duration: int = 300  # seconds
    
    # Risk management
    max_drawdown: Decimal = Decimal('0.1')  # 10%
    stop_loss_threshold: Decimal = Decimal('0.05')  # 5%
    take_profit_threshold: Decimal = Decimal('0.15')  # 15%
    
    # Performance thresholds
    min_sharpe_ratio: float = 1.0
    min_win_rate: float = 0.55
    
    def __post_init__(self):
        """Validate configuration"""
        for field_name in ['max_position_size', 'risk_per_trade', 'max_drawdown', 
                          'stop_loss_threshold', 'take_profit_threshold']:
            value = getattr(self, field_name)
            if not isinstance(value, Decimal):
                setattr(self, field_name, Decimal(str(value)))


@dataclass
class StrategyMetrics:
    """Performance metrics for a strategy"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: Decimal = Decimal('0')
    max_drawdown: Decimal = Decimal('0')
    sharpe_ratio: float = 0.0
    win_rate: float = 0.0
    average_win: Decimal = Decimal('0')
    average_loss: Decimal = Decimal('0')
    profit_factor: float = 0.0
    last_updated: datetime = field(default_factory=datetime.now)
    
    def __post_init__(self):
        """Calculate derived metrics"""
        if self.total_trades > 0:
            self.win_rate = self.winning_trades / self.total_trades
            
        if self.losing_trades > 0 and self.average_loss > 0:
            self.profit_factor = float(self.average_win / abs(self.average_loss))
    
    def update_from_trade(self, trade_pnl: Decimal):
        """Update metrics from a completed trade"""
        self.total_trades += 1
        self.total_pnl += trade_pnl
        
        if trade_pnl > 0:
            self.winning_trades += 1
            # Update average win
            if self.winning_trades == 1:
                self.average_win = trade_pnl
            else:
                self.average_win = (self.average_win * (self.winning_trades - 1) + trade_pnl) / self.winning_trades
        else:
            self.losing_trades += 1
            # Update average loss
            if self.losing_trades == 1:
                self.average_loss = trade_pnl
            else:
                self.average_loss = (self.average_loss * (self.losing_trades - 1) + trade_pnl) / self.losing_trades
        
        # Recalculate derived metrics
        self.__post_init__()
        self.last_updated = datetime.now()


class StrategyError(Exception):
    """Base exception for strategy errors"""
    pass


class PolymarketStrategy(ABC):
    """
    Abstract base class for all Polymarket trading strategies
    
    Provides common functionality for strategy implementation:
    - Market analysis and signal generation
    - Risk management
    - Performance tracking
    - Integration with news sources and GPU acceleration
    """
    
    def __init__(
        self,
        client: PolymarketClient,
        config: Optional[StrategyConfig] = None,
        strategy_name: Optional[str] = None,
    ):
        """
        Initialize strategy
        
        Args:
            client: Polymarket API client
            config: Strategy configuration
            strategy_name: Name for this strategy instance
        """
        self.client = client
        self.config = config or StrategyConfig()
        self.name = strategy_name or self.__class__.__name__
        
        # Performance tracking
        self.metrics = StrategyMetrics()
        self.active_positions: Dict[str, Dict] = {}  # market_id -> position info
        self.pending_orders: Dict[str, Order] = {}  # order_id -> order
        
        # State management
        self.is_running = False
        self.last_analysis_time: Optional[datetime] = None
        self._shutdown_event = asyncio.Event()
        
        logger.info(f"Initialized {self.name} strategy")
    
    @abstractmethod
    async def analyze_market(self, market: Market) -> Optional[TradingSignal]:
        """
        Analyze a market and generate trading signal
        
        Args:
            market: Market to analyze
            
        Returns:
            Trading signal if opportunity found, None otherwise
        """
        pass
    
    @abstractmethod
    async def should_trade_market(self, market: Market) -> bool:
        """
        Determine if this strategy should trade on a given market
        
        Args:
            market: Market to evaluate
            
        Returns:
            True if market is suitable for this strategy
        """
        pass
    
    async def analyze_markets(self, markets: List[Market]) -> List[TradingSignal]:
        """
        Analyze multiple markets and generate signals
        
        Args:
            markets: List of markets to analyze
            
        Returns:
            List of trading signals
        """
        signals = []
        
        # Filter markets suitable for this strategy
        suitable_markets = []
        for market in markets:
            if await self.should_trade_market(market):
                suitable_markets.append(market)
        
        # Limit number of markets to prevent overload
        if len(suitable_markets) > self.config.max_markets_monitored:
            suitable_markets = suitable_markets[:self.config.max_markets_monitored]
            logger.warning(f"Limited analysis to {self.config.max_markets_monitored} markets")
        
        # Analyze markets (potentially in parallel for GPU acceleration)
        if self.config.enable_gpu_acceleration and len(suitable_markets) > 1:
            signals = await self._analyze_markets_batch(suitable_markets)
        else:
            for market in suitable_markets:
                try:
                    signal = await self.analyze_market(market)
                    if signal and self._validate_signal(signal):
                        signals.append(signal)
                except Exception as e:
                    logger.error(f"Error analyzing market {market.id}: {str(e)}")
        
        # Filter by configuration thresholds
        filtered_signals = []
        for signal in signals:
            if (signal.confidence >= self.config.min_confidence and 
                signal.strength.value >= self.config.min_signal_strength.value):
                filtered_signals.append(signal)
        
        logger.info(f"Generated {len(filtered_signals)} valid signals from {len(markets)} markets")
        return filtered_signals
    
    async def _analyze_markets_batch(self, markets: List[Market]) -> List[TradingSignal]:
        """
        Analyze markets in batch for GPU acceleration
        
        This method should be overridden by strategies that support batch processing
        """
        signals = []
        for market in markets:
            try:
                signal = await self.analyze_market(market)
                if signal and self._validate_signal(signal):
                    signals.append(signal)
            except Exception as e:
                logger.error(f"Error in batch analysis for market {market.id}: {str(e)}")
        return signals
    
    def _validate_signal(self, signal: TradingSignal) -> bool:
        """Validate a trading signal"""
        try:
            # Basic validation
            if signal.confidence < 0 or signal.confidence > 1:
                return False
            if signal.target_price < 0 or signal.target_price > 1:
                return False
            if signal.size <= 0:
                return False
                
            # Risk checks
            if signal.size > self.config.max_position_size:
                logger.warning(f"Signal size {signal.size} exceeds max position size")
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"Signal validation error: {str(e)}")
            return False
    
    async def execute_signal(self, signal: TradingSignal) -> Optional[Order]:
        """
        Execute a trading signal by placing an order
        
        Args:
            signal: Trading signal to execute
            
        Returns:
            Placed order if successful, None otherwise
        """
        try:
            # Risk management checks
            if not self._check_risk_limits(signal):
                logger.warning(f"Risk limits prevent execution of signal for {signal.market_id}")
                return None
            
            # Place order through client
            order = await self._place_order(signal)
            
            if order:
                self.pending_orders[order.id] = order
                logger.info(f"Placed order {order.id} for {signal.market_id}")
            
            return order
            
        except Exception as e:
            logger.error(f"Error executing signal: {str(e)}")
            raise StrategyError(f"Failed to execute signal: {str(e)}") from e
    
    async def _place_order(self, signal: TradingSignal) -> Optional[Order]:
        """Place order based on signal - to be implemented by subclasses"""
        # This would integrate with the CLOB client
        # Implementation depends on the specific client interface
        raise NotImplementedError("Subclasses must implement _place_order")
    
    def _check_risk_limits(self, signal: TradingSignal) -> bool:
        """Check if signal passes risk management rules"""
        # Check position size
        if signal.size > self.config.max_position_size:
            return False
        
        # Check current exposure
        current_exposure = sum(
            pos.get('size', 0) for pos in self.active_positions.values()
        )
        if current_exposure + signal.size > self.config.max_position_size:
            return False
        
        # Check recent trading frequency
        recent_trades = len([
            order for order in self.pending_orders.values()
            if order.created_at > datetime.now() - timedelta(hours=1)
        ])
        if recent_trades >= self.config.max_trades_per_hour:
            return False
        
        return True
    
    def update_position(self, market_id: str, outcome: str, size: Decimal, price: Decimal):
        """Update position tracking"""
        if market_id not in self.active_positions:
            self.active_positions[market_id] = {}
        
        self.active_positions[market_id][outcome] = {
            'size': size,
            'price': price,
            'timestamp': datetime.now()
        }
    
    def get_performance_summary(self) -> Dict[str, Any]:
        """Get strategy performance summary"""
        return {
            'strategy_name': self.name,
            'metrics': {
                'total_trades': self.metrics.total_trades,
                'win_rate': self.metrics.win_rate,
                'total_pnl': float(self.metrics.total_pnl),
                'sharpe_ratio': self.metrics.sharpe_ratio,
                'max_drawdown': float(self.metrics.max_drawdown),
                'profit_factor': self.metrics.profit_factor,
            },
            'positions': {
                'active_count': len(self.active_positions),
                'pending_orders': len(self.pending_orders),
            },
            'configuration': {
                'max_position_size': float(self.config.max_position_size),
                'min_confidence': self.config.min_confidence,
                'min_signal_strength': self.config.min_signal_strength.name,
            },
            'last_updated': self.metrics.last_updated.isoformat(),
        }
    
    async def start(self):
        """Start the strategy"""
        if self.is_running:
            logger.warning(f"Strategy {self.name} is already running")
            return
        
        self.is_running = True
        self._shutdown_event.clear()
        logger.info(f"Started strategy {self.name}")
    
    async def stop(self):
        """Stop the strategy"""
        if not self.is_running:
            return
        
        self.is_running = False
        self._shutdown_event.set()
        logger.info(f"Stopped strategy {self.name}")
    
    async def cleanup(self):
        """Cleanup strategy resources"""
        await self.stop()
        # Cancel pending orders if needed
        # Close positions if needed
        logger.info(f"Cleaned up strategy {self.name}")