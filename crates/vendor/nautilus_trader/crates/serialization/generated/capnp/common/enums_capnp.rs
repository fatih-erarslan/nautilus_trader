// @generated by the capnpc-rust plugin to the Cap'n Proto schema compiler.
// DO NOT EDIT.
// source: common/enums.capnp


#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum AccountType {
  Cash = 0,
  Margin = 1,
  Betting = 2,
  Wallet = 3,
}

impl ::capnp::introspect::Introspect for AccountType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &account_type::ENCODED_NODE, annotation_types: account_type::get_annotation_types }).into() }
}
impl ::core::convert::From<AccountType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: AccountType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &account_type::ENCODED_NODE, annotation_types: account_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for AccountType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <AccountType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Cash),
      1 => ::core::result::Result::Ok(Self::Margin),
      2 => ::core::result::Result::Ok(Self::Betting),
      3 => ::core::result::Result::Ok(Self::Wallet),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<AccountType> for u16 {
  #[inline]
  fn from(x: AccountType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for AccountType {
  const TYPE_ID: u64 = 0xdf1e_8bc7_c054_f256u64;
}
mod account_type {
pub static ENCODED_NODE: [::capnp::Word; 35] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(86, 242, 84, 192, 199, 139, 30, 223),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(67, 0, 0, 0, 146, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 250, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 103, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 65, 99, 99, 111, 117),
  ::capnp::word(110, 116, 84, 121, 112, 101, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(16, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(41, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(25, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 97, 115, 104, 0, 0, 0, 0),
  ::capnp::word(109, 97, 114, 103, 105, 110, 0, 0),
  ::capnp::word(98, 101, 116, 116, 105, 110, 103, 0),
  ::capnp::word(119, 97, 108, 108, 101, 116, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum AggressorSide {
  NoAggressor = 0,
  Buyer = 1,
  Seller = 2,
}

impl ::capnp::introspect::Introspect for AggressorSide {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &aggressor_side::ENCODED_NODE, annotation_types: aggressor_side::get_annotation_types }).into() }
}
impl ::core::convert::From<AggressorSide> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: AggressorSide) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &aggressor_side::ENCODED_NODE, annotation_types: aggressor_side::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for AggressorSide {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <AggressorSide as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::NoAggressor),
      1 => ::core::result::Result::Ok(Self::Buyer),
      2 => ::core::result::Result::Ok(Self::Seller),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<AggressorSide> for u16 {
  #[inline]
  fn from(x: AggressorSide) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for AggressorSide {
  const TYPE_ID: u64 = 0xf201_19f9_54ad_2ae8u64;
}
mod aggressor_side {
pub static ENCODED_NODE: [::capnp::Word; 33] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(232, 42, 173, 84, 249, 25, 1, 242),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(148, 0, 0, 0, 219, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 10, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 79, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 65, 103, 103, 114, 101),
  ::capnp::word(115, 115, 111, 114, 83, 105, 100, 101),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(12, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 98, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(25, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 65, 103, 103, 114, 101, 115),
  ::capnp::word(115, 111, 114, 0, 0, 0, 0, 0),
  ::capnp::word(98, 117, 121, 101, 114, 0, 0, 0),
  ::capnp::word(115, 101, 108, 108, 101, 114, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum AssetClass {
  Fx = 0,
  Equity = 1,
  Commodity = 2,
  Debt = 3,
  Index = 4,
  Cryptocurrency = 5,
  Alternative = 6,
}

impl ::capnp::introspect::Introspect for AssetClass {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &asset_class::ENCODED_NODE, annotation_types: asset_class::get_annotation_types }).into() }
}
impl ::core::convert::From<AssetClass> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: AssetClass) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &asset_class::ENCODED_NODE, annotation_types: asset_class::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for AssetClass {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <AssetClass as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Fx),
      1 => ::core::result::Result::Ok(Self::Equity),
      2 => ::core::result::Result::Ok(Self::Commodity),
      3 => ::core::result::Result::Ok(Self::Debt),
      4 => ::core::result::Result::Ok(Self::Index),
      5 => ::core::result::Result::Ok(Self::Cryptocurrency),
      6 => ::core::result::Result::Ok(Self::Alternative),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<AssetClass> for u16 {
  #[inline]
  fn from(x: AssetClass) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for AssetClass {
  const TYPE_ID: u64 = 0xebdb_0309_2fcb_7e04u64;
}
mod asset_class {
pub static ENCODED_NODE: [::capnp::Word; 50] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(4, 126, 203, 47, 9, 3, 219, 235),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(221, 0, 0, 0, 98, 1, 0, 0),
  ::capnp::word(21, 0, 0, 0, 242, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 175, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 65, 115, 115, 101, 116),
  ::capnp::word(67, 108, 97, 115, 115, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(28, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(77, 0, 0, 0, 26, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(69, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(61, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(57, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(49, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(41, 0, 0, 0, 122, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(37, 0, 0, 0, 98, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(102, 120, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 113, 117, 105, 116, 121, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 100, 105, 116),
  ::capnp::word(121, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(100, 101, 98, 116, 0, 0, 0, 0),
  ::capnp::word(105, 110, 100, 101, 120, 0, 0, 0),
  ::capnp::word(99, 114, 121, 112, 116, 111, 99, 117),
  ::capnp::word(114, 114, 101, 110, 99, 121, 0, 0),
  ::capnp::word(97, 108, 116, 101, 114, 110, 97, 116),
  ::capnp::word(105, 118, 101, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum InstrumentClass {
  Spot = 0,
  Swap = 1,
  Future = 2,
  FuturesSpread = 3,
  Forward = 4,
  Cfd = 5,
  Bond = 6,
  Option = 7,
  OptionSpread = 8,
  Warrant = 9,
  SportsBetting = 10,
  BinaryOption = 11,
}

impl ::capnp::introspect::Introspect for InstrumentClass {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &instrument_class::ENCODED_NODE, annotation_types: instrument_class::get_annotation_types }).into() }
}
impl ::core::convert::From<InstrumentClass> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: InstrumentClass) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &instrument_class::ENCODED_NODE, annotation_types: instrument_class::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for InstrumentClass {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <InstrumentClass as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Spot),
      1 => ::core::result::Result::Ok(Self::Swap),
      2 => ::core::result::Result::Ok(Self::Future),
      3 => ::core::result::Result::Ok(Self::FuturesSpread),
      4 => ::core::result::Result::Ok(Self::Forward),
      5 => ::core::result::Result::Ok(Self::Cfd),
      6 => ::core::result::Result::Ok(Self::Bond),
      7 => ::core::result::Result::Ok(Self::Option),
      8 => ::core::result::Result::Ok(Self::OptionSpread),
      9 => ::core::result::Result::Ok(Self::Warrant),
      10 => ::core::result::Result::Ok(Self::SportsBetting),
      11 => ::core::result::Result::Ok(Self::BinaryOption),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<InstrumentClass> for u16 {
  #[inline]
  fn from(x: InstrumentClass) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for InstrumentClass {
  const TYPE_ID: u64 = 0xe86e_440b_d7a7_b3f8u64;
}
mod instrument_class {
pub static ENCODED_NODE: [::capnp::Word; 72] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(248, 179, 167, 215, 11, 68, 110, 232),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(100, 1, 0, 0, 96, 2, 0, 0),
  ::capnp::word(21, 0, 0, 0, 26, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 39, 1, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 73, 110, 115, 116, 114),
  ::capnp::word(117, 109, 101, 110, 116, 67, 108, 97),
  ::capnp::word(115, 115, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(48, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(137, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(129, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(121, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(113, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(93, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(85, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(77, 0, 0, 0, 106, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(73, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(10, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(65, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(11, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(61, 0, 0, 0, 106, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(115, 112, 111, 116, 0, 0, 0, 0),
  ::capnp::word(115, 119, 97, 112, 0, 0, 0, 0),
  ::capnp::word(102, 117, 116, 117, 114, 101, 0, 0),
  ::capnp::word(102, 117, 116, 117, 114, 101, 115, 83),
  ::capnp::word(112, 114, 101, 97, 100, 0, 0, 0),
  ::capnp::word(102, 111, 114, 119, 97, 114, 100, 0),
  ::capnp::word(99, 102, 100, 0, 0, 0, 0, 0),
  ::capnp::word(98, 111, 110, 100, 0, 0, 0, 0),
  ::capnp::word(111, 112, 116, 105, 111, 110, 0, 0),
  ::capnp::word(111, 112, 116, 105, 111, 110, 83, 112),
  ::capnp::word(114, 101, 97, 100, 0, 0, 0, 0),
  ::capnp::word(119, 97, 114, 114, 97, 110, 116, 0),
  ::capnp::word(115, 112, 111, 114, 116, 115, 66, 101),
  ::capnp::word(116, 116, 105, 110, 103, 0, 0, 0),
  ::capnp::word(98, 105, 110, 97, 114, 121, 79, 112),
  ::capnp::word(116, 105, 111, 110, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum OptionKind {
  Call = 0,
  Put = 1,
}

impl ::capnp::introspect::Introspect for OptionKind {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &option_kind::ENCODED_NODE, annotation_types: option_kind::get_annotation_types }).into() }
}
impl ::core::convert::From<OptionKind> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: OptionKind) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &option_kind::ENCODED_NODE, annotation_types: option_kind::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for OptionKind {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <OptionKind as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Call),
      1 => ::core::result::Result::Ok(Self::Put),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<OptionKind> for u16 {
  #[inline]
  fn from(x: OptionKind) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for OptionKind {
  const TYPE_ID: u64 = 0xe888_3060_916e_0843u64;
}
mod option_kind {
pub static ENCODED_NODE: [::capnp::Word; 27] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(67, 8, 110, 145, 96, 48, 136, 232),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(98, 2, 0, 0, 142, 2, 0, 0),
  ::capnp::word(21, 0, 0, 0, 242, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 55, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 79, 112, 116, 105, 111),
  ::capnp::word(110, 75, 105, 110, 100, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(8, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(9, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 97, 108, 108, 0, 0, 0, 0),
  ::capnp::word(112, 117, 116, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum OrderSide {
  NoOrderSide = 0,
  Buy = 1,
  Sell = 2,
}

impl ::capnp::introspect::Introspect for OrderSide {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &order_side::ENCODED_NODE, annotation_types: order_side::get_annotation_types }).into() }
}
impl ::core::convert::From<OrderSide> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: OrderSide) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &order_side::ENCODED_NODE, annotation_types: order_side::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for OrderSide {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <OrderSide as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::NoOrderSide),
      1 => ::core::result::Result::Ok(Self::Buy),
      2 => ::core::result::Result::Ok(Self::Sell),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<OrderSide> for u16 {
  #[inline]
  fn from(x: OrderSide) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for OrderSide {
  const TYPE_ID: u64 = 0x8ce6_6de3_c879_66dau64;
}
mod order_side {
pub static ENCODED_NODE: [::capnp::Word; 32] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(218, 102, 121, 200, 227, 109, 230, 140),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(144, 2, 0, 0, 207, 2, 0, 0),
  ::capnp::word(21, 0, 0, 0, 234, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 79, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 79, 114, 100, 101, 114),
  ::capnp::word(83, 105, 100, 101, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(12, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 98, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(25, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 79, 114, 100, 101, 114, 83),
  ::capnp::word(105, 100, 101, 0, 0, 0, 0, 0),
  ::capnp::word(98, 117, 121, 0, 0, 0, 0, 0),
  ::capnp::word(115, 101, 108, 108, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum OrderType {
  Market = 0,
  Limit = 1,
  StopMarket = 2,
  StopLimit = 3,
  MarketToLimit = 4,
  MarketIfTouched = 5,
  LimitIfTouched = 6,
  TrailingStopMarket = 7,
  TrailingStopLimit = 8,
}

impl ::capnp::introspect::Introspect for OrderType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &order_type::ENCODED_NODE, annotation_types: order_type::get_annotation_types }).into() }
}
impl ::core::convert::From<OrderType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: OrderType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &order_type::ENCODED_NODE, annotation_types: order_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for OrderType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <OrderType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Market),
      1 => ::core::result::Result::Ok(Self::Limit),
      2 => ::core::result::Result::Ok(Self::StopMarket),
      3 => ::core::result::Result::Ok(Self::StopLimit),
      4 => ::core::result::Result::Ok(Self::MarketToLimit),
      5 => ::core::result::Result::Ok(Self::MarketIfTouched),
      6 => ::core::result::Result::Ok(Self::LimitIfTouched),
      7 => ::core::result::Result::Ok(Self::TrailingStopMarket),
      8 => ::core::result::Result::Ok(Self::TrailingStopLimit),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<OrderType> for u16 {
  #[inline]
  fn from(x: OrderType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for OrderType {
  const TYPE_ID: u64 = 0xb0a4_8d4c_59d9_56b2u64;
}
mod order_type {
pub static ENCODED_NODE: [::capnp::Word; 64] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(178, 86, 217, 89, 76, 141, 164, 176),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(209, 2, 0, 0, 159, 3, 0, 0),
  ::capnp::word(21, 0, 0, 0, 234, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 223, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 79, 114, 100, 101, 114),
  ::capnp::word(84, 121, 112, 101, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(36, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(93, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(85, 0, 0, 0, 90, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(81, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(77, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(73, 0, 0, 0, 130, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(69, 0, 0, 0, 122, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(65, 0, 0, 0, 154, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(65, 0, 0, 0, 146, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 97, 114, 107, 101, 116, 0, 0),
  ::capnp::word(108, 105, 109, 105, 116, 0, 0, 0),
  ::capnp::word(115, 116, 111, 112, 77, 97, 114, 107),
  ::capnp::word(101, 116, 0, 0, 0, 0, 0, 0),
  ::capnp::word(115, 116, 111, 112, 76, 105, 109, 105),
  ::capnp::word(116, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 97, 114, 107, 101, 116, 84, 111),
  ::capnp::word(76, 105, 109, 105, 116, 0, 0, 0),
  ::capnp::word(109, 97, 114, 107, 101, 116, 73, 102),
  ::capnp::word(84, 111, 117, 99, 104, 101, 100, 0),
  ::capnp::word(108, 105, 109, 105, 116, 73, 102, 84),
  ::capnp::word(111, 117, 99, 104, 101, 100, 0, 0),
  ::capnp::word(116, 114, 97, 105, 108, 105, 110, 103),
  ::capnp::word(83, 116, 111, 112, 77, 97, 114, 107),
  ::capnp::word(101, 116, 0, 0, 0, 0, 0, 0),
  ::capnp::word(116, 114, 97, 105, 108, 105, 110, 103),
  ::capnp::word(83, 116, 111, 112, 76, 105, 109, 105),
  ::capnp::word(116, 0, 0, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum OrderStatus {
  Initialized = 0,
  Denied = 1,
  Emulated = 2,
  Released = 3,
  Submitted = 4,
  Accepted = 5,
  Rejected = 6,
  Canceled = 7,
  Expired = 8,
  Triggered = 9,
  PendingUpdate = 10,
  PendingCancel = 11,
  PartiallyFilled = 12,
  Filled = 13,
}

impl ::capnp::introspect::Introspect for OrderStatus {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &order_status::ENCODED_NODE, annotation_types: order_status::get_annotation_types }).into() }
}
impl ::core::convert::From<OrderStatus> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: OrderStatus) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &order_status::ENCODED_NODE, annotation_types: order_status::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for OrderStatus {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <OrderStatus as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Initialized),
      1 => ::core::result::Result::Ok(Self::Denied),
      2 => ::core::result::Result::Ok(Self::Emulated),
      3 => ::core::result::Result::Ok(Self::Released),
      4 => ::core::result::Result::Ok(Self::Submitted),
      5 => ::core::result::Result::Ok(Self::Accepted),
      6 => ::core::result::Result::Ok(Self::Rejected),
      7 => ::core::result::Result::Ok(Self::Canceled),
      8 => ::core::result::Result::Ok(Self::Expired),
      9 => ::core::result::Result::Ok(Self::Triggered),
      10 => ::core::result::Result::Ok(Self::PendingUpdate),
      11 => ::core::result::Result::Ok(Self::PendingCancel),
      12 => ::core::result::Result::Ok(Self::PartiallyFilled),
      13 => ::core::result::Result::Ok(Self::Filled),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<OrderStatus> for u16 {
  #[inline]
  fn from(x: OrderStatus) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for OrderStatus {
  const TYPE_ID: u64 = 0xf704_cd7d_31c2_8cd0u64;
}
mod order_status {
pub static ENCODED_NODE: [::capnp::Word; 86] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(208, 140, 194, 49, 125, 205, 4, 247),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(161, 3, 0, 0, 184, 4, 0, 0),
  ::capnp::word(21, 0, 0, 0, 250, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 87, 1, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 79, 114, 100, 101, 114),
  ::capnp::word(83, 116, 97, 116, 117, 115, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(56, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(161, 0, 0, 0, 98, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(157, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(149, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(145, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(141, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(137, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(133, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(129, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(125, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(117, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(10, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(113, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(11, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(105, 0, 0, 0, 130, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(105, 110, 105, 116, 105, 97, 108, 105),
  ::capnp::word(122, 101, 100, 0, 0, 0, 0, 0),
  ::capnp::word(100, 101, 110, 105, 101, 100, 0, 0),
  ::capnp::word(101, 109, 117, 108, 97, 116, 101, 100),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(114, 101, 108, 101, 97, 115, 101, 100),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(115, 117, 98, 109, 105, 116, 116, 101),
  ::capnp::word(100, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(97, 99, 99, 101, 112, 116, 101, 100),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(114, 101, 106, 101, 99, 116, 101, 100),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 97, 110, 99, 101, 108, 101, 100),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 120, 112, 105, 114, 101, 100, 0),
  ::capnp::word(116, 114, 105, 103, 103, 101, 114, 101),
  ::capnp::word(100, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(112, 101, 110, 100, 105, 110, 103, 85),
  ::capnp::word(112, 100, 97, 116, 101, 0, 0, 0),
  ::capnp::word(112, 101, 110, 100, 105, 110, 103, 67),
  ::capnp::word(97, 110, 99, 101, 108, 0, 0, 0),
  ::capnp::word(112, 97, 114, 116, 105, 97, 108, 108),
  ::capnp::word(121, 70, 105, 108, 108, 101, 100, 0),
  ::capnp::word(102, 105, 108, 108, 101, 100, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TimeInForce {
  Gtc = 0,
  Ioc = 1,
  Fok = 2,
  Gtd = 3,
  Day = 4,
  AtTheOpen = 5,
  AtTheClose = 6,
}

impl ::capnp::introspect::Introspect for TimeInForce {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &time_in_force::ENCODED_NODE, annotation_types: time_in_force::get_annotation_types }).into() }
}
impl ::core::convert::From<TimeInForce> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: TimeInForce) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &time_in_force::ENCODED_NODE, annotation_types: time_in_force::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for TimeInForce {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <TimeInForce as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Gtc),
      1 => ::core::result::Result::Ok(Self::Ioc),
      2 => ::core::result::Result::Ok(Self::Fok),
      3 => ::core::result::Result::Ok(Self::Gtd),
      4 => ::core::result::Result::Ok(Self::Day),
      5 => ::core::result::Result::Ok(Self::AtTheOpen),
      6 => ::core::result::Result::Ok(Self::AtTheClose),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<TimeInForce> for u16 {
  #[inline]
  fn from(x: TimeInForce) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for TimeInForce {
  const TYPE_ID: u64 = 0xa76d_7dff_8889_19d9u64;
}
mod time_in_force {
pub static ENCODED_NODE: [::capnp::Word; 49] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(217, 25, 137, 136, 255, 125, 109, 167),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(186, 4, 0, 0, 131, 5, 0, 0),
  ::capnp::word(21, 0, 0, 0, 250, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 175, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 84, 105, 109, 101, 73),
  ::capnp::word(110, 70, 111, 114, 99, 101, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(28, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(77, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(69, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(61, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(53, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(45, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(37, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 90, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(103, 116, 99, 0, 0, 0, 0, 0),
  ::capnp::word(105, 111, 99, 0, 0, 0, 0, 0),
  ::capnp::word(102, 111, 107, 0, 0, 0, 0, 0),
  ::capnp::word(103, 116, 100, 0, 0, 0, 0, 0),
  ::capnp::word(100, 97, 121, 0, 0, 0, 0, 0),
  ::capnp::word(97, 116, 84, 104, 101, 79, 112, 101),
  ::capnp::word(110, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(97, 116, 84, 104, 101, 67, 108, 111),
  ::capnp::word(115, 101, 0, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TriggerType {
  NoTrigger = 0,
  Default = 1,
  LastPrice = 2,
  MarkPrice = 3,
  IndexPrice = 4,
  BidAsk = 5,
  DoubleLast = 6,
  DoubleBidAsk = 7,
  LastOrBidAsk = 8,
  MidPoint = 9,
}

impl ::capnp::introspect::Introspect for TriggerType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &trigger_type::ENCODED_NODE, annotation_types: trigger_type::get_annotation_types }).into() }
}
impl ::core::convert::From<TriggerType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: TriggerType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &trigger_type::ENCODED_NODE, annotation_types: trigger_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for TriggerType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <TriggerType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::NoTrigger),
      1 => ::core::result::Result::Ok(Self::Default),
      2 => ::core::result::Result::Ok(Self::LastPrice),
      3 => ::core::result::Result::Ok(Self::MarkPrice),
      4 => ::core::result::Result::Ok(Self::IndexPrice),
      5 => ::core::result::Result::Ok(Self::BidAsk),
      6 => ::core::result::Result::Ok(Self::DoubleLast),
      7 => ::core::result::Result::Ok(Self::DoubleBidAsk),
      8 => ::core::result::Result::Ok(Self::LastOrBidAsk),
      9 => ::core::result::Result::Ok(Self::MidPoint),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<TriggerType> for u16 {
  #[inline]
  fn from(x: TriggerType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for TriggerType {
  const TYPE_ID: u64 = 0xf5f1_1c17_3032_6a40u64;
}
mod trigger_type {
pub static ENCODED_NODE: [::capnp::Word; 67] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(64, 106, 50, 48, 23, 28, 241, 245),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(133, 5, 0, 0, 79, 6, 0, 0),
  ::capnp::word(21, 0, 0, 0, 250, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 247, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 84, 114, 105, 103, 103),
  ::capnp::word(101, 114, 84, 121, 112, 101, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(40, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(113, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(97, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(93, 0, 0, 0, 90, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(89, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(81, 0, 0, 0, 90, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(77, 0, 0, 0, 106, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(73, 0, 0, 0, 106, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(69, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 84, 114, 105, 103, 103, 101),
  ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(100, 101, 102, 97, 117, 108, 116, 0),
  ::capnp::word(108, 97, 115, 116, 80, 114, 105, 99),
  ::capnp::word(101, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 97, 114, 107, 80, 114, 105, 99),
  ::capnp::word(101, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(105, 110, 100, 101, 120, 80, 114, 105),
  ::capnp::word(99, 101, 0, 0, 0, 0, 0, 0),
  ::capnp::word(98, 105, 100, 65, 115, 107, 0, 0),
  ::capnp::word(100, 111, 117, 98, 108, 101, 76, 97),
  ::capnp::word(115, 116, 0, 0, 0, 0, 0, 0),
  ::capnp::word(100, 111, 117, 98, 108, 101, 66, 105),
  ::capnp::word(100, 65, 115, 107, 0, 0, 0, 0),
  ::capnp::word(108, 97, 115, 116, 79, 114, 66, 105),
  ::capnp::word(100, 65, 115, 107, 0, 0, 0, 0),
  ::capnp::word(109, 105, 100, 80, 111, 105, 110, 116),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ContingencyType {
  NoContingency = 0,
  Oco = 1,
  Oto = 2,
  Ouo = 3,
}

impl ::capnp::introspect::Introspect for ContingencyType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &contingency_type::ENCODED_NODE, annotation_types: contingency_type::get_annotation_types }).into() }
}
impl ::core::convert::From<ContingencyType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: ContingencyType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &contingency_type::ENCODED_NODE, annotation_types: contingency_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for ContingencyType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <ContingencyType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::NoContingency),
      1 => ::core::result::Result::Ok(Self::Oco),
      2 => ::core::result::Result::Ok(Self::Oto),
      3 => ::core::result::Result::Ok(Self::Ouo),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<ContingencyType> for u16 {
  #[inline]
  fn from(x: ContingencyType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for ContingencyType {
  const TYPE_ID: u64 = 0xf38d_d3fd_792a_cfceu64;
}
mod contingency_type {
pub static ENCODED_NODE: [::capnp::Word; 37] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(206, 207, 42, 121, 253, 211, 141, 243),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(81, 6, 0, 0, 239, 6, 0, 0),
  ::capnp::word(21, 0, 0, 0, 26, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 103, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 67, 111, 110, 116, 105),
  ::capnp::word(110, 103, 101, 110, 99, 121, 84, 121),
  ::capnp::word(112, 101, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(16, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(41, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(37, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 67, 111, 110, 116, 105, 110),
  ::capnp::word(103, 101, 110, 99, 121, 0, 0, 0),
  ::capnp::word(111, 99, 111, 0, 0, 0, 0, 0),
  ::capnp::word(111, 116, 111, 0, 0, 0, 0, 0),
  ::capnp::word(111, 117, 111, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PositionSide {
  NoPositionSide = 0,
  Flat = 1,
  Long = 2,
  Short = 3,
}

impl ::capnp::introspect::Introspect for PositionSide {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &position_side::ENCODED_NODE, annotation_types: position_side::get_annotation_types }).into() }
}
impl ::core::convert::From<PositionSide> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: PositionSide) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &position_side::ENCODED_NODE, annotation_types: position_side::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for PositionSide {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <PositionSide as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::NoPositionSide),
      1 => ::core::result::Result::Ok(Self::Flat),
      2 => ::core::result::Result::Ok(Self::Long),
      3 => ::core::result::Result::Ok(Self::Short),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<PositionSide> for u16 {
  #[inline]
  fn from(x: PositionSide) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for PositionSide {
  const TYPE_ID: u64 = 0xf2e8_8dda_5506_c715u64;
}
mod position_side {
pub static ENCODED_NODE: [::capnp::Word; 36] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(21, 199, 6, 85, 218, 141, 232, 242),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(241, 6, 0, 0, 69, 7, 0, 0),
  ::capnp::word(21, 0, 0, 0, 2, 1, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 103, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 80, 111, 115, 105, 116),
  ::capnp::word(105, 111, 110, 83, 105, 100, 101, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(16, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(41, 0, 0, 0, 122, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(37, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 80, 111, 115, 105, 116, 105),
  ::capnp::word(111, 110, 83, 105, 100, 101, 0, 0),
  ::capnp::word(102, 108, 97, 116, 0, 0, 0, 0),
  ::capnp::word(108, 111, 110, 103, 0, 0, 0, 0),
  ::capnp::word(115, 104, 111, 114, 116, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum LiquiditySide {
  NoLiquiditySide = 0,
  Maker = 1,
  Taker = 2,
}

impl ::capnp::introspect::Introspect for LiquiditySide {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &liquidity_side::ENCODED_NODE, annotation_types: liquidity_side::get_annotation_types }).into() }
}
impl ::core::convert::From<LiquiditySide> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: LiquiditySide) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &liquidity_side::ENCODED_NODE, annotation_types: liquidity_side::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for LiquiditySide {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <LiquiditySide as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::NoLiquiditySide),
      1 => ::core::result::Result::Ok(Self::Maker),
      2 => ::core::result::Result::Ok(Self::Taker),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<LiquiditySide> for u16 {
  #[inline]
  fn from(x: LiquiditySide) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for LiquiditySide {
  const TYPE_ID: u64 = 0xc45b_5bbf_a763_18c4u64;
}
mod liquidity_side {
pub static ENCODED_NODE: [::capnp::Word; 33] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(196, 24, 99, 167, 191, 91, 91, 196),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(71, 7, 0, 0, 145, 7, 0, 0),
  ::capnp::word(21, 0, 0, 0, 10, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 79, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 76, 105, 113, 117, 105),
  ::capnp::word(100, 105, 116, 121, 83, 105, 100, 101),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(12, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 130, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(25, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 76, 105, 113, 117, 105, 100),
  ::capnp::word(105, 116, 121, 83, 105, 100, 101, 0),
  ::capnp::word(109, 97, 107, 101, 114, 0, 0, 0),
  ::capnp::word(116, 97, 107, 101, 114, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BookAction {
  Add = 0,
  Update = 1,
  Delete = 2,
  Clear = 3,
}

impl ::capnp::introspect::Introspect for BookAction {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &book_action::ENCODED_NODE, annotation_types: book_action::get_annotation_types }).into() }
}
impl ::core::convert::From<BookAction> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: BookAction) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &book_action::ENCODED_NODE, annotation_types: book_action::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for BookAction {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <BookAction as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Add),
      1 => ::core::result::Result::Ok(Self::Update),
      2 => ::core::result::Result::Ok(Self::Delete),
      3 => ::core::result::Result::Ok(Self::Clear),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<BookAction> for u16 {
  #[inline]
  fn from(x: BookAction) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for BookAction {
  const TYPE_ID: u64 = 0x8ba2_aa32_63d7_b234u64;
}
mod book_action {
pub static ENCODED_NODE: [::capnp::Word; 35] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(52, 178, 215, 99, 50, 170, 162, 139),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(147, 7, 0, 0, 222, 7, 0, 0),
  ::capnp::word(21, 0, 0, 0, 242, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 103, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 66, 111, 111, 107, 65),
  ::capnp::word(99, 116, 105, 111, 110, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(16, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(41, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(25, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(97, 100, 100, 0, 0, 0, 0, 0),
  ::capnp::word(117, 112, 100, 97, 116, 101, 0, 0),
  ::capnp::word(100, 101, 108, 101, 116, 101, 0, 0),
  ::capnp::word(99, 108, 101, 97, 114, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BookType {
  TopOfBookBidOffer = 0,
  MarketByPrice = 1,
  MarketByOrder = 2,
}

impl ::capnp::introspect::Introspect for BookType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &book_type::ENCODED_NODE, annotation_types: book_type::get_annotation_types }).into() }
}
impl ::core::convert::From<BookType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: BookType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &book_type::ENCODED_NODE, annotation_types: book_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for BookType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <BookType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::TopOfBookBidOffer),
      1 => ::core::result::Result::Ok(Self::MarketByPrice),
      2 => ::core::result::Result::Ok(Self::MarketByOrder),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<BookType> for u16 {
  #[inline]
  fn from(x: BookType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for BookType {
  const TYPE_ID: u64 = 0x8a33_0d53_857f_2062u64;
}
mod book_type {
pub static ENCODED_NODE: [::capnp::Word; 35] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(98, 32, 127, 133, 83, 13, 51, 138),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(224, 7, 0, 0, 156, 8, 0, 0),
  ::capnp::word(21, 0, 0, 0, 226, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 79, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 66, 111, 111, 107, 84),
  ::capnp::word(121, 112, 101, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(12, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 146, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(25, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(116, 111, 112, 79, 102, 66, 111, 111),
  ::capnp::word(107, 66, 105, 100, 79, 102, 102, 101),
  ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 97, 114, 107, 101, 116, 66, 121),
  ::capnp::word(80, 114, 105, 99, 101, 0, 0, 0),
  ::capnp::word(109, 97, 114, 107, 101, 116, 66, 121),
  ::capnp::word(79, 114, 100, 101, 114, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum OrderBookDeltaType {
  Add = 0,
  Update = 1,
  Delete = 2,
  Clear = 3,
}

impl ::capnp::introspect::Introspect for OrderBookDeltaType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &order_book_delta_type::ENCODED_NODE, annotation_types: order_book_delta_type::get_annotation_types }).into() }
}
impl ::core::convert::From<OrderBookDeltaType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: OrderBookDeltaType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &order_book_delta_type::ENCODED_NODE, annotation_types: order_book_delta_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for OrderBookDeltaType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <OrderBookDeltaType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Add),
      1 => ::core::result::Result::Ok(Self::Update),
      2 => ::core::result::Result::Ok(Self::Delete),
      3 => ::core::result::Result::Ok(Self::Clear),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<OrderBookDeltaType> for u16 {
  #[inline]
  fn from(x: OrderBookDeltaType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for OrderBookDeltaType {
  const TYPE_ID: u64 = 0xfe6c_e40c_109f_fbdcu64;
}
mod order_book_delta_type {
pub static ENCODED_NODE: [::capnp::Word; 36] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(220, 251, 159, 16, 12, 228, 108, 254),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(158, 8, 0, 0, 241, 8, 0, 0),
  ::capnp::word(21, 0, 0, 0, 50, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 103, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 79, 114, 100, 101, 114),
  ::capnp::word(66, 111, 111, 107, 68, 101, 108, 116),
  ::capnp::word(97, 84, 121, 112, 101, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(16, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(41, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(25, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(97, 100, 100, 0, 0, 0, 0, 0),
  ::capnp::word(117, 112, 100, 97, 116, 101, 0, 0),
  ::capnp::word(100, 101, 108, 101, 116, 101, 0, 0),
  ::capnp::word(99, 108, 101, 97, 114, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum RecordFlag {
  FLast = 0,
  FTob = 1,
  FSnapshot = 2,
  FMbp = 3,
  Reserved2 = 4,
  Reserved1 = 5,
}

impl ::capnp::introspect::Introspect for RecordFlag {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &record_flag::ENCODED_NODE, annotation_types: record_flag::get_annotation_types }).into() }
}
impl ::core::convert::From<RecordFlag> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: RecordFlag) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &record_flag::ENCODED_NODE, annotation_types: record_flag::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for RecordFlag {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <RecordFlag as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::FLast),
      1 => ::core::result::Result::Ok(Self::FTob),
      2 => ::core::result::Result::Ok(Self::FSnapshot),
      3 => ::core::result::Result::Ok(Self::FMbp),
      4 => ::core::result::Result::Ok(Self::Reserved2),
      5 => ::core::result::Result::Ok(Self::Reserved1),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<RecordFlag> for u16 {
  #[inline]
  fn from(x: RecordFlag) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for RecordFlag {
  const TYPE_ID: u64 = 0xcd55_3a95_d2e3_1571u64;
}
mod record_flag {
pub static ENCODED_NODE: [::capnp::Word; 46] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(113, 21, 227, 210, 149, 58, 85, 205),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(243, 8, 0, 0, 107, 10, 0, 0),
  ::capnp::word(21, 0, 0, 0, 242, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 151, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 82, 101, 99, 111, 114),
  ::capnp::word(100, 70, 108, 97, 103, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(24, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(65, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(57, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(49, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(45, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(37, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(102, 76, 97, 115, 116, 0, 0, 0),
  ::capnp::word(102, 84, 111, 98, 0, 0, 0, 0),
  ::capnp::word(102, 83, 110, 97, 112, 115, 104, 111),
  ::capnp::word(116, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(102, 77, 98, 112, 0, 0, 0, 0),
  ::capnp::word(114, 101, 115, 101, 114, 118, 101, 100),
  ::capnp::word(50, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(114, 101, 115, 101, 114, 118, 101, 100),
  ::capnp::word(49, 0, 0, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum AggregationSource {
  External = 0,
  Internal = 1,
}

impl ::capnp::introspect::Introspect for AggregationSource {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &aggregation_source::ENCODED_NODE, annotation_types: aggregation_source::get_annotation_types }).into() }
}
impl ::core::convert::From<AggregationSource> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: AggregationSource) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &aggregation_source::ENCODED_NODE, annotation_types: aggregation_source::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for AggregationSource {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <AggregationSource as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::External),
      1 => ::core::result::Result::Ok(Self::Internal),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<AggregationSource> for u16 {
  #[inline]
  fn from(x: AggregationSource) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for AggregationSource {
  const TYPE_ID: u64 = 0x946f_a419_8403_c015u64;
}
mod aggregation_source {
pub static ENCODED_NODE: [::capnp::Word; 30] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(21, 192, 3, 132, 25, 164, 111, 148),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 10, 0, 0, 169, 10, 0, 0),
  ::capnp::word(21, 0, 0, 0, 42, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 55, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 65, 103, 103, 114, 101),
  ::capnp::word(103, 97, 116, 105, 111, 110, 83, 111),
  ::capnp::word(117, 114, 99, 101, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(8, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 120, 116, 101, 114, 110, 97, 108),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(105, 110, 116, 101, 114, 110, 97, 108),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PriceType {
  Bid = 0,
  Ask = 1,
  Mid = 2,
  Last = 3,
  Mark = 4,
}

impl ::capnp::introspect::Introspect for PriceType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &price_type::ENCODED_NODE, annotation_types: price_type::get_annotation_types }).into() }
}
impl ::core::convert::From<PriceType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: PriceType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &price_type::ENCODED_NODE, annotation_types: price_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for PriceType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <PriceType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Bid),
      1 => ::core::result::Result::Ok(Self::Ask),
      2 => ::core::result::Result::Ok(Self::Mid),
      3 => ::core::result::Result::Ok(Self::Last),
      4 => ::core::result::Result::Ok(Self::Mark),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<PriceType> for u16 {
  #[inline]
  fn from(x: PriceType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for PriceType {
  const TYPE_ID: u64 = 0xec7c_ed40_7682_a0ccu64;
}
mod price_type {
pub static ENCODED_NODE: [::capnp::Word; 39] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(204, 160, 130, 118, 64, 237, 124, 236),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(171, 10, 0, 0, 251, 10, 0, 0),
  ::capnp::word(21, 0, 0, 0, 234, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 127, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 80, 114, 105, 99, 101),
  ::capnp::word(84, 121, 112, 101, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(20, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(53, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(45, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(37, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(98, 105, 100, 0, 0, 0, 0, 0),
  ::capnp::word(97, 115, 107, 0, 0, 0, 0, 0),
  ::capnp::word(109, 105, 100, 0, 0, 0, 0, 0),
  ::capnp::word(108, 97, 115, 116, 0, 0, 0, 0),
  ::capnp::word(109, 97, 114, 107, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BarAggregation {
  Tick = 0,
  TickImbalance = 1,
  TickRuns = 2,
  Volume = 3,
  VolumeImbalance = 4,
  VolumeRuns = 5,
  Value = 6,
  ValueImbalance = 7,
  ValueRuns = 8,
  Millisecond = 9,
  Second = 10,
  Minute = 11,
  Hour = 12,
  Day = 13,
  Week = 14,
  Month = 15,
  Year = 16,
  Renko = 17,
}

impl ::capnp::introspect::Introspect for BarAggregation {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &bar_aggregation::ENCODED_NODE, annotation_types: bar_aggregation::get_annotation_types }).into() }
}
impl ::core::convert::From<BarAggregation> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: BarAggregation) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &bar_aggregation::ENCODED_NODE, annotation_types: bar_aggregation::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for BarAggregation {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <BarAggregation as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Tick),
      1 => ::core::result::Result::Ok(Self::TickImbalance),
      2 => ::core::result::Result::Ok(Self::TickRuns),
      3 => ::core::result::Result::Ok(Self::Volume),
      4 => ::core::result::Result::Ok(Self::VolumeImbalance),
      5 => ::core::result::Result::Ok(Self::VolumeRuns),
      6 => ::core::result::Result::Ok(Self::Value),
      7 => ::core::result::Result::Ok(Self::ValueImbalance),
      8 => ::core::result::Result::Ok(Self::ValueRuns),
      9 => ::core::result::Result::Ok(Self::Millisecond),
      10 => ::core::result::Result::Ok(Self::Second),
      11 => ::core::result::Result::Ok(Self::Minute),
      12 => ::core::result::Result::Ok(Self::Hour),
      13 => ::core::result::Result::Ok(Self::Day),
      14 => ::core::result::Result::Ok(Self::Week),
      15 => ::core::result::Result::Ok(Self::Month),
      16 => ::core::result::Result::Ok(Self::Year),
      17 => ::core::result::Result::Ok(Self::Renko),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<BarAggregation> for u16 {
  #[inline]
  fn from(x: BarAggregation) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for BarAggregation {
  const TYPE_ID: u64 = 0xe9c7_bb7d_5a7f_09b2u64;
}
mod bar_aggregation {
pub static ENCODED_NODE: [::capnp::Word; 99] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(178, 9, 127, 90, 125, 187, 199, 233),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(253, 10, 0, 0, 66, 12, 0, 0),
  ::capnp::word(21, 0, 0, 0, 18, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 183, 1, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 66, 97, 114, 65, 103),
  ::capnp::word(103, 114, 101, 103, 97, 116, 105, 111),
  ::capnp::word(110, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(72, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(209, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(201, 0, 0, 0, 114, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(197, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(193, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(185, 0, 0, 0, 130, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(181, 0, 0, 0, 90, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(177, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(169, 0, 0, 0, 122, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(165, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(161, 0, 0, 0, 98, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(10, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(157, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(11, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(149, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(141, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(133, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(14, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(125, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(15, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(117, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(116, 105, 99, 107, 0, 0, 0, 0),
  ::capnp::word(116, 105, 99, 107, 73, 109, 98, 97),
  ::capnp::word(108, 97, 110, 99, 101, 0, 0, 0),
  ::capnp::word(116, 105, 99, 107, 82, 117, 110, 115),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(118, 111, 108, 117, 109, 101, 0, 0),
  ::capnp::word(118, 111, 108, 117, 109, 101, 73, 109),
  ::capnp::word(98, 97, 108, 97, 110, 99, 101, 0),
  ::capnp::word(118, 111, 108, 117, 109, 101, 82, 117),
  ::capnp::word(110, 115, 0, 0, 0, 0, 0, 0),
  ::capnp::word(118, 97, 108, 117, 101, 0, 0, 0),
  ::capnp::word(118, 97, 108, 117, 101, 73, 109, 98),
  ::capnp::word(97, 108, 97, 110, 99, 101, 0, 0),
  ::capnp::word(118, 97, 108, 117, 101, 82, 117, 110),
  ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 105, 108, 108, 105, 115, 101, 99),
  ::capnp::word(111, 110, 100, 0, 0, 0, 0, 0),
  ::capnp::word(115, 101, 99, 111, 110, 100, 0, 0),
  ::capnp::word(109, 105, 110, 117, 116, 101, 0, 0),
  ::capnp::word(104, 111, 117, 114, 0, 0, 0, 0),
  ::capnp::word(100, 97, 121, 0, 0, 0, 0, 0),
  ::capnp::word(119, 101, 101, 107, 0, 0, 0, 0),
  ::capnp::word(109, 111, 110, 116, 104, 0, 0, 0),
  ::capnp::word(121, 101, 97, 114, 0, 0, 0, 0),
  ::capnp::word(114, 101, 110, 107, 111, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TrailingOffsetType {
  NoTrailingOffset = 0,
  Price = 1,
  BasisPoints = 2,
  Ticks = 3,
  PriceTier = 4,
}

impl ::capnp::introspect::Introspect for TrailingOffsetType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &trailing_offset_type::ENCODED_NODE, annotation_types: trailing_offset_type::get_annotation_types }).into() }
}
impl ::core::convert::From<TrailingOffsetType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: TrailingOffsetType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &trailing_offset_type::ENCODED_NODE, annotation_types: trailing_offset_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for TrailingOffsetType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <TrailingOffsetType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::NoTrailingOffset),
      1 => ::core::result::Result::Ok(Self::Price),
      2 => ::core::result::Result::Ok(Self::BasisPoints),
      3 => ::core::result::Result::Ok(Self::Ticks),
      4 => ::core::result::Result::Ok(Self::PriceTier),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<TrailingOffsetType> for u16 {
  #[inline]
  fn from(x: TrailingOffsetType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for TrailingOffsetType {
  const TYPE_ID: u64 = 0xa371_3806_ebb6_9f8eu64;
}
mod trailing_offset_type {
pub static ENCODED_NODE: [::capnp::Word; 44] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(142, 159, 182, 235, 6, 56, 113, 163),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(68, 12, 0, 0, 186, 12, 0, 0),
  ::capnp::word(21, 0, 0, 0, 50, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 127, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 84, 114, 97, 105, 108),
  ::capnp::word(105, 110, 103, 79, 102, 102, 115, 101),
  ::capnp::word(116, 84, 121, 112, 101, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(20, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(53, 0, 0, 0, 138, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(53, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(45, 0, 0, 0, 98, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(41, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 84, 114, 97, 105, 108, 105),
  ::capnp::word(110, 103, 79, 102, 102, 115, 101, 116),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(112, 114, 105, 99, 101, 0, 0, 0),
  ::capnp::word(98, 97, 115, 105, 115, 80, 111, 105),
  ::capnp::word(110, 116, 115, 0, 0, 0, 0, 0),
  ::capnp::word(116, 105, 99, 107, 115, 0, 0, 0),
  ::capnp::word(112, 114, 105, 99, 101, 84, 105, 101),
  ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum OmsType {
  Unspecified = 0,
  Netting = 1,
  Hedging = 2,
}

impl ::capnp::introspect::Introspect for OmsType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &oms_type::ENCODED_NODE, annotation_types: oms_type::get_annotation_types }).into() }
}
impl ::core::convert::From<OmsType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: OmsType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &oms_type::ENCODED_NODE, annotation_types: oms_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for OmsType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <OmsType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Unspecified),
      1 => ::core::result::Result::Ok(Self::Netting),
      2 => ::core::result::Result::Ok(Self::Hedging),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<OmsType> for u16 {
  #[inline]
  fn from(x: OmsType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for OmsType {
  const TYPE_ID: u64 = 0xbb27_63d9_0807_97c5u64;
}
mod oms_type {
pub static ENCODED_NODE: [::capnp::Word; 32] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(197, 151, 7, 8, 217, 99, 39, 187),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(188, 12, 0, 0, 0, 13, 0, 0),
  ::capnp::word(21, 0, 0, 0, 218, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 79, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 79, 109, 115, 84, 121),
  ::capnp::word(112, 101, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(12, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 98, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(25, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(117, 110, 115, 112, 101, 99, 105, 102),
  ::capnp::word(105, 101, 100, 0, 0, 0, 0, 0),
  ::capnp::word(110, 101, 116, 116, 105, 110, 103, 0),
  ::capnp::word(104, 101, 100, 103, 105, 110, 103, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum CurrencyType {
  Crypto = 0,
  Fiat = 1,
  CommodityBacked = 2,
}

impl ::capnp::introspect::Introspect for CurrencyType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &currency_type::ENCODED_NODE, annotation_types: currency_type::get_annotation_types }).into() }
}
impl ::core::convert::From<CurrencyType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: CurrencyType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &currency_type::ENCODED_NODE, annotation_types: currency_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for CurrencyType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <CurrencyType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Crypto),
      1 => ::core::result::Result::Ok(Self::Fiat),
      2 => ::core::result::Result::Ok(Self::CommodityBacked),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<CurrencyType> for u16 {
  #[inline]
  fn from(x: CurrencyType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for CurrencyType {
  const TYPE_ID: u64 = 0x83d2_f362_aae3_98b7u64;
}
mod currency_type {
pub static ENCODED_NODE: [::capnp::Word; 32] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(183, 152, 227, 170, 98, 243, 210, 131),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 13, 0, 0, 75, 13, 0, 0),
  ::capnp::word(21, 0, 0, 0, 2, 1, 0, 0),
  ::capnp::word(33, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 79, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 67, 117, 114, 114, 101),
  ::capnp::word(110, 99, 121, 84, 121, 112, 101, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(12, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 130, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 114, 121, 112, 116, 111, 0, 0),
  ::capnp::word(102, 105, 97, 116, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 100, 105, 116),
  ::capnp::word(121, 66, 97, 99, 107, 101, 100, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum InstrumentCloseType {
  EndOfSession = 0,
  ContractExpired = 1,
}

impl ::capnp::introspect::Introspect for InstrumentCloseType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &instrument_close_type::ENCODED_NODE, annotation_types: instrument_close_type::get_annotation_types }).into() }
}
impl ::core::convert::From<InstrumentCloseType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: InstrumentCloseType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &instrument_close_type::ENCODED_NODE, annotation_types: instrument_close_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for InstrumentCloseType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <InstrumentCloseType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::EndOfSession),
      1 => ::core::result::Result::Ok(Self::ContractExpired),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<InstrumentCloseType> for u16 {
  #[inline]
  fn from(x: InstrumentCloseType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for InstrumentCloseType {
  const TYPE_ID: u64 = 0xbfe2_c25f_cb93_74afu64;
}
mod instrument_close_type {
pub static ENCODED_NODE: [::capnp::Word; 30] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(175, 116, 147, 203, 95, 194, 226, 191),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(77, 13, 0, 0, 150, 13, 0, 0),
  ::capnp::word(21, 0, 0, 0, 58, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 55, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 73, 110, 115, 116, 114),
  ::capnp::word(117, 109, 101, 110, 116, 67, 108, 111),
  ::capnp::word(115, 101, 84, 121, 112, 101, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(8, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 106, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 130, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 110, 100, 79, 102, 83, 101, 115),
  ::capnp::word(115, 105, 111, 110, 0, 0, 0, 0),
  ::capnp::word(99, 111, 110, 116, 114, 97, 99, 116),
  ::capnp::word(69, 120, 112, 105, 114, 101, 100, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum MarketStatusAction {
  None = 0,
  PreOpen = 1,
  PreCross = 2,
  Quoting = 3,
  Cross = 4,
  Rotation = 5,
  NewPriceIndication = 6,
  Trading = 7,
  Halt = 8,
  Pause = 9,
  Suspend = 10,
  PreClose = 11,
  Close = 12,
  PostClose = 13,
  ShortSellRestrictionChange = 14,
  NotAvailableForTrading = 15,
}

impl ::capnp::introspect::Introspect for MarketStatusAction {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &market_status_action::ENCODED_NODE, annotation_types: market_status_action::get_annotation_types }).into() }
}
impl ::core::convert::From<MarketStatusAction> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: MarketStatusAction) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &market_status_action::ENCODED_NODE, annotation_types: market_status_action::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for MarketStatusAction {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <MarketStatusAction as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::None),
      1 => ::core::result::Result::Ok(Self::PreOpen),
      2 => ::core::result::Result::Ok(Self::PreCross),
      3 => ::core::result::Result::Ok(Self::Quoting),
      4 => ::core::result::Result::Ok(Self::Cross),
      5 => ::core::result::Result::Ok(Self::Rotation),
      6 => ::core::result::Result::Ok(Self::NewPriceIndication),
      7 => ::core::result::Result::Ok(Self::Trading),
      8 => ::core::result::Result::Ok(Self::Halt),
      9 => ::core::result::Result::Ok(Self::Pause),
      10 => ::core::result::Result::Ok(Self::Suspend),
      11 => ::core::result::Result::Ok(Self::PreClose),
      12 => ::core::result::Result::Ok(Self::Close),
      13 => ::core::result::Result::Ok(Self::PostClose),
      14 => ::core::result::Result::Ok(Self::ShortSellRestrictionChange),
      15 => ::core::result::Result::Ok(Self::NotAvailableForTrading),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<MarketStatusAction> for u16 {
  #[inline]
  fn from(x: MarketStatusAction) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for MarketStatusAction {
  const TYPE_ID: u64 = 0xa006_30ff_1b89_b376u64;
}
mod market_status_action {
pub static ENCODED_NODE: [::capnp::Word; 95] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(118, 179, 137, 27, 255, 48, 6, 160),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(152, 13, 0, 0, 223, 14, 0, 0),
  ::capnp::word(21, 0, 0, 0, 50, 1, 0, 0),
  ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(33, 0, 0, 0, 135, 1, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 77, 97, 114, 107, 101),
  ::capnp::word(116, 83, 116, 97, 116, 117, 115, 65),
  ::capnp::word(99, 116, 105, 111, 110, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(64, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(185, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(177, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(169, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(165, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(157, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(149, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(145, 0, 0, 0, 154, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(145, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(137, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(129, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(10, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(121, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(11, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(113, 0, 0, 0, 74, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(109, 0, 0, 0, 50, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 0, 0, 0, 82, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(14, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(97, 0, 0, 0, 218, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(15, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(101, 0, 0, 0, 186, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 110, 101, 0, 0, 0, 0),
  ::capnp::word(112, 114, 101, 79, 112, 101, 110, 0),
  ::capnp::word(112, 114, 101, 67, 114, 111, 115, 115),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(113, 117, 111, 116, 105, 110, 103, 0),
  ::capnp::word(99, 114, 111, 115, 115, 0, 0, 0),
  ::capnp::word(114, 111, 116, 97, 116, 105, 111, 110),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 101, 119, 80, 114, 105, 99, 101),
  ::capnp::word(73, 110, 100, 105, 99, 97, 116, 105),
  ::capnp::word(111, 110, 0, 0, 0, 0, 0, 0),
  ::capnp::word(116, 114, 97, 100, 105, 110, 103, 0),
  ::capnp::word(104, 97, 108, 116, 0, 0, 0, 0),
  ::capnp::word(112, 97, 117, 115, 101, 0, 0, 0),
  ::capnp::word(115, 117, 115, 112, 101, 110, 100, 0),
  ::capnp::word(112, 114, 101, 67, 108, 111, 115, 101),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 108, 111, 115, 101, 0, 0, 0),
  ::capnp::word(112, 111, 115, 116, 67, 108, 111, 115),
  ::capnp::word(101, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(115, 104, 111, 114, 116, 83, 101, 108),
  ::capnp::word(108, 82, 101, 115, 116, 114, 105, 99),
  ::capnp::word(116, 105, 111, 110, 67, 104, 97, 110),
  ::capnp::word(103, 101, 0, 0, 0, 0, 0, 0),
  ::capnp::word(110, 111, 116, 65, 118, 97, 105, 108),
  ::capnp::word(97, 98, 108, 101, 70, 111, 114, 84),
  ::capnp::word(114, 97, 100, 105, 110, 103, 0, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PositionAdjustmentType {
  Commission = 0,
  Funding = 1,
}

impl ::capnp::introspect::Introspect for PositionAdjustmentType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &position_adjustment_type::ENCODED_NODE, annotation_types: position_adjustment_type::get_annotation_types }).into() }
}
impl ::core::convert::From<PositionAdjustmentType> for ::capnp::dynamic_value::Reader<'_> {
  fn from(e: PositionAdjustmentType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &position_adjustment_type::ENCODED_NODE, annotation_types: position_adjustment_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for PositionAdjustmentType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <PositionAdjustmentType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Commission),
      1 => ::core::result::Result::Ok(Self::Funding),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<PositionAdjustmentType> for u16 {
  #[inline]
  fn from(x: PositionAdjustmentType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for PositionAdjustmentType {
  const TYPE_ID: u64 = 0xe4d7_b45b_7075_debeu64;
}
mod position_adjustment_type {
pub static ENCODED_NODE: [::capnp::Word; 30] = [
  ::capnp::word(0, 0, 0, 0, 6, 0, 6, 0),
  ::capnp::word(190, 222, 117, 112, 91, 180, 215, 228),
  ::capnp::word(19, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(41, 24, 7, 246, 229, 212, 195, 178),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(225, 14, 0, 0, 35, 15, 0, 0),
  ::capnp::word(21, 0, 0, 0, 82, 1, 0, 0),
  ::capnp::word(41, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(37, 0, 0, 0, 55, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 111, 110, 47, 101),
  ::capnp::word(110, 117, 109, 115, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 80, 111, 115, 105, 116),
  ::capnp::word(105, 111, 110, 65, 100, 106, 117, 115),
  ::capnp::word(116, 109, 101, 110, 116, 84, 121, 112),
  ::capnp::word(101, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(8, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(17, 0, 0, 0, 90, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(99, 111, 109, 109, 105, 115, 115, 105),
  ::capnp::word(111, 110, 0, 0, 0, 0, 0, 0),
  ::capnp::word(102, 117, 110, 100, 105, 110, 103, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  ::capnp::introspect::panic_invalid_annotation_indices(child_index, index)
}
}
