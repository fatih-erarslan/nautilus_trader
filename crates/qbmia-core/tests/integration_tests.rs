//! Comprehensive integration tests for QBMIA Core\n//! \n//! This test suite follows TDD principles and validates:\n//! - System initialization and configuration\n//! - Quantum-biological integration workflows\n//! - Performance benchmarks and optimization\n//! - Error handling and recovery scenarios\n//! - Memory management and resource utilization\n\nuse qbmia_core::*;\nuse std::time::Instant;\nuse tokio::time::{sleep, Duration};\n\n/// Test comprehensive system initialization\n#[tokio::test]\nasync fn test_comprehensive_system_initialization() {\n    // Test default configuration\n    let config = QbmiaConfig::default();\n    assert!(config.max_integration_depth > 0);\n    assert!(config.quantum_coherence_timeout_ms > 0);\n    assert!(config.biological_learning_rate > 0.0);\n    assert!(config.enable_simd);\n    \n    // Test system creation and initialization\n    let core = QbmiaCore::new(config.clone());\n    let result = core.initialize().await;\n    assert!(result.is_ok(), \"System initialization failed: {:?}\", result.err());\n    \n    // Verify configuration is preserved\n    assert_eq!(core.config().id, config.id);\n}\n\n/// Test custom configuration scenarios\n#[tokio::test]\nasync fn test_custom_configuration_scenarios() {\n    let mut config = QbmiaConfig::default();\n    config.max_integration_depth = 50;\n    config.quantum_coherence_timeout_ms = 500;\n    config.biological_learning_rate = 0.05;\n    config.optimization_level = 3;\n    config.enable_simd = false;\n    \n    let core = QbmiaCore::new(config.clone());\n    assert!(core.initialize().await.is_ok());\n    assert_eq!(core.config().max_integration_depth, 50);\n    assert_eq!(core.config().optimization_level, 3);\n    assert!(!core.config().enable_simd);\n}\n\n/// Test quantum-biological integration pipeline\n#[tokio::test]\nasync fn test_quantum_biological_integration_pipeline() {\n    let config = QbmiaConfig::default();\n    let core = QbmiaCore::new(config);\n    core.initialize().await.expect(\"Failed to initialize core\");\n    \n    // Test various input sizes and patterns\n    let test_cases = vec![\n        vec![1.0, 2.0, 3.0],\n        vec![0.5, -0.3, 0.8, -0.9, 0.1],\n        vec![1.0; 10],\n        vec![-1.0, 1.0, -1.0, 1.0],\n        vec![0.0; 8],\n    ];\n    \n    for (i, input) in test_cases.iter().enumerate() {\n        let result = core.process_integration_step(input).await;\n        assert!(result.is_ok(), \"Integration failed for test case {}: {:?}\", i, result.err());\n        \n        let output = result.unwrap();\n        assert!(!output.is_empty(), \"Empty output for test case {}\", i);\n        assert!(output.iter().all(|&x| x.is_finite()), \"Non-finite values in output for test case {}\", i);\n    }\n}\n\n/// Test performance requirements (sub-100ms)\n#[tokio::test]\nasync fn test_performance_requirements() {\n    let config = QbmiaConfig::default();\n    let core = QbmiaCore::new(config);\n    core.initialize().await.unwrap();\n    \n    let input = vec![0.5, 0.7, 0.3, 0.9, 0.2];\n    let iterations = 10;\n    let mut total_time = Duration::new(0, 0);\n    \n    for _ in 0..iterations {\n        let start = Instant::now();\n        let result = core.process_integration_step(&input).await;\n        let elapsed = start.elapsed();\n        \n        assert!(result.is_ok());\n        total_time += elapsed;\n        \n        // Each individual operation should be under 100ms\n        assert!(elapsed.as_millis() < 100, \n               \"Single operation took {}ms, exceeding 100ms requirement\", elapsed.as_millis());\n    }\n    \n    let avg_time = total_time / iterations;\n    println!(\"Average processing time: {}ms\", avg_time.as_millis());\n    assert!(avg_time.as_millis() < 50, \"Average time {}ms exceeds 50ms target\", avg_time.as_millis());\n}\n\n/// Test concurrent processing capabilities\n#[tokio::test]\nasync fn test_concurrent_processing() {\n    let config = QbmiaConfig::default();\n    let core = std::sync::Arc::new(QbmiaCore::new(config));\n    core.initialize().await.unwrap();\n    \n    let mut handles = Vec::new();\n    \n    // Spawn 10 concurrent processing tasks\n    for i in 0..10 {\n        let core_clone = core.clone();\n        let input = vec![i as f64, (i + 1) as f64, (i + 2) as f64];\n        \n        let handle = tokio::spawn(async move {\n            core_clone.process_integration_step(&input).await\n        });\n        \n        handles.push(handle);\n    }\n    \n    // Wait for all tasks to complete\n    for (i, handle) in handles.into_iter().enumerate() {\n        let result = handle.await.expect(\"Task panicked\")\n            .expect(&format!(\"Processing failed for task {}\", i));\n        assert!(!result.is_empty());\n    }\n}\n\n/// Test error handling and recovery\n#[tokio::test]\nasync fn test_error_handling_and_recovery() {\n    let config = QbmiaConfig::default();\n    let core = QbmiaCore::new(config);\n    \n    // Test processing before initialization\n    let input = vec![1.0, 2.0, 3.0];\n    let result = core.process_integration_step(&input).await;\n    // This should handle gracefully or return appropriate error\n    \n    // Initialize and test normal operation\n    core.initialize().await.unwrap();\n    let result = core.process_integration_step(&input).await;\n    assert!(result.is_ok());\n    \n    // Test edge cases\n    let empty_input = vec![];\n    let result = core.process_integration_step(&empty_input).await;\n    // Should handle empty input gracefully\n    \n    let large_input = vec![1.0; 1000];\n    let result = core.process_integration_step(&large_input).await;\n    assert!(result.is_ok(), \"Failed to handle large input\");\n}\n\n/// Test memory management and resource utilization\n#[tokio::test]\nasync fn test_memory_management() {\n    let config = QbmiaConfig::default();\n    let core = QbmiaCore::new(config);\n    core.initialize().await.unwrap();\n    \n    // Process many operations to test memory stability\n    for i in 0..100 {\n        let input = vec![i as f64 % 10.0; 5];\n        let result = core.process_integration_step(&input).await;\n        assert!(result.is_ok(), \"Memory management failed at iteration {}\", i);\n        \n        // Check performance metrics don't degrade\n        let metrics = core.get_performance_metrics().await;\n        assert!(metrics.total_processing_count() == i + 1);\n    }\n}\n\n/// Test quantum coherence timeout handling\n#[tokio::test]\nasync fn test_quantum_coherence_timeout() {\n    let mut config = QbmiaConfig::default();\n    config.quantum_coherence_timeout_ms = 100; // Very short timeout\n    \n    let core = QbmiaCore::new(config);\n    core.initialize().await.unwrap();\n    \n    let input = vec![1.0, 2.0, 3.0];\n    \n    // Process immediately - should work\n    let result = core.process_integration_step(&input).await;\n    assert!(result.is_ok());\n    \n    // Wait for timeout and try again\n    sleep(Duration::from_millis(150)).await;\n    \n    // This might fail due to quantum coherence timeout\n    // The system should handle this gracefully\n    let result = core.process_integration_step(&input).await;\n    // Depending on implementation, this could succeed with re-initialization\n    // or return a specific error type\n}\n\n/// Test SIMD optimization impact\n#[tokio::test]\nasync fn test_simd_optimization_impact() {\n    // Test with SIMD enabled\n    let mut config_simd = QbmiaConfig::default();\n    config_simd.enable_simd = true;\n    config_simd.optimization_level = 3;\n    \n    let core_simd = QbmiaCore::new(config_simd);\n    core_simd.initialize().await.unwrap();\n    \n    // Test with SIMD disabled\n    let mut config_no_simd = QbmiaConfig::default();\n    config_no_simd.enable_simd = false;\n    config_no_simd.optimization_level = 0;\n    \n    let core_no_simd = QbmiaCore::new(config_no_simd);\n    core_no_simd.initialize().await.unwrap();\n    \n    let large_input = vec![0.5; 100];\n    \n    // Benchmark SIMD version\n    let start = Instant::now();\n    let result_simd = core_simd.process_integration_step(&large_input).await;\n    let simd_time = start.elapsed();\n    \n    // Benchmark non-SIMD version\n    let start = Instant::now();\n    let result_no_simd = core_no_simd.process_integration_step(&large_input).await;\n    let no_simd_time = start.elapsed();\n    \n    assert!(result_simd.is_ok());\n    assert!(result_no_simd.is_ok());\n    \n    println!(\"SIMD time: {}μs, No-SIMD time: {}μs\", \n             simd_time.as_micros(), no_simd_time.as_micros());\n    \n    // SIMD should generally be faster, but not required for correctness\n    // Just log the performance difference\n}\n\n/// Test performance metrics collection\n#[tokio::test]\nasync fn test_performance_metrics_collection() {\n    let config = QbmiaConfig::default();\n    let core = QbmiaCore::new(config);\n    core.initialize().await.unwrap();\n    \n    // Initially no processing\n    let initial_metrics = core.get_performance_metrics().await;\n    assert_eq!(initial_metrics.total_processing_count(), 0);\n    \n    // Process some data\n    let input = vec![1.0, 2.0, 3.0];\n    for i in 1..=5 {\n        core.process_integration_step(&input).await.unwrap();\n        let metrics = core.get_performance_metrics().await;\n        assert_eq!(metrics.total_processing_count(), i);\n    }\n}\n\n/// Test biological learning rate impact\n#[tokio::test]\nasync fn test_biological_learning_rate_impact() {\n    // Test with different learning rates\n    let learning_rates = vec![0.001, 0.01, 0.1, 0.5];\n    let input = vec![0.7, 0.3, 0.9, 0.1, 0.5];\n    \n    for rate in learning_rates {\n        let mut config = QbmiaConfig::default();\n        config.biological_learning_rate = rate;\n        \n        let core = QbmiaCore::new(config);\n        core.initialize().await.unwrap();\n        \n        // Process the same input multiple times\n        let mut outputs = Vec::new();\n        for _ in 0..3 {\n            let result = core.process_integration_step(&input).await.unwrap();\n            outputs.push(result);\n        }\n        \n        // Verify all outputs are valid\n        for output in outputs {\n            assert!(!output.is_empty());\n            assert!(output.iter().all(|&x| x.is_finite()));\n        }\n    }\n}\n\n/// Stress test for system stability\n#[tokio::test]\nasync fn test_system_stability_stress() {\n    let config = QbmiaConfig::default();\n    let core = QbmiaCore::new(config);\n    core.initialize().await.unwrap();\n    \n    // Stress test with various input patterns\n    let test_patterns = vec![\n        vec![1.0; 10],\n        vec![-1.0; 10],\n        (0..10).map(|i| i as f64).collect(),\n        (0..10).map(|i| (i as f64).sin()).collect(),\n        (0..10).map(|i| if i % 2 == 0 { 1.0 } else { -1.0 }).collect(),\n    ];\n    \n    for _ in 0..20 {\n        for pattern in &test_patterns {\n            let result = core.process_integration_step(pattern).await;\n            assert!(result.is_ok(), \"Stress test failed\");\n        }\n    }\n    \n    // Verify system is still responsive\n    let final_result = core.process_integration_step(&vec![0.5, 0.5, 0.5]).await;\n    assert!(final_result.is_ok());\n}\n"