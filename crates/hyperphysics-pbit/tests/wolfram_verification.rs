//! Formal verification tests for pBit/Ising model generated by Wolfram
//!
//! These test vectors verify the mathematical correctness of
//! probabilistic bit and Ising model computations.
//!
//! Generated: 2025-12-06
//! Reference: Ising (1925), Borders et al. (2019) "Integer Factorization using pBits"

const EPSILON: f64 = 1e-10;

/// Wolfram-verified Ising Hamiltonian
/// H = -Σ_{i<j} J_{ij} s_i s_j - Σ_i h_i s_i
#[test]
fn test_ising_hamiltonian_wolfram_verified() {
    // 3-spin system with J and h
    // J = [[0, 1, 0.5], [1, 0, 1], [0.5, 1, 0]]
    // h = [0.1, 0.2, 0.1]

    // Test case 1: spins = [1, 1, 1], H = -2.9
    let h1 = ising_hamiltonian_3(&[1, 1, 1], &[[0.0, 1.0, 0.5], [1.0, 0.0, 1.0], [0.5, 1.0, 0.0]], &[0.1, 0.2, 0.1]);
    assert!(
        (h1 - (-2.9)).abs() < EPSILON,
        "H([1,1,1]) = {}, expected -2.9",
        h1
    );

    // Test case 2: spins = [1, -1, 1], H = 1.5
    let h2 = ising_hamiltonian_3(&[1, -1, 1], &[[0.0, 1.0, 0.5], [1.0, 0.0, 1.0], [0.5, 1.0, 0.0]], &[0.1, 0.2, 0.1]);
    assert!(
        (h2 - 1.5).abs() < EPSILON,
        "H([1,-1,1]) = {}, expected 1.5",
        h2
    );
}

/// Verify Hamiltonian properties
#[test]
fn test_ising_hamiltonian_properties() {
    let j = [[0.0, 1.0], [1.0, 0.0]]; // Ferromagnetic coupling
    let h = [0.0, 0.0]; // No external field

    // Aligned spins should have lower energy
    let h_aligned = ising_hamiltonian_2(&[1, 1], &j, &h);
    let h_anti = ising_hamiltonian_2(&[1, -1], &j, &h);

    assert!(
        h_aligned < h_anti,
        "Aligned H={} should be < anti-aligned H={}",
        h_aligned,
        h_anti
    );
}

/// Wolfram-verified mutual information
/// I(X;Y) = H(X) + H(Y) - H(X,Y)
#[test]
fn test_mutual_information_wolfram_verified() {
    // Test case 1: Independent variables -> MI = 0
    let pxy1 = [[0.25, 0.25], [0.25, 0.25]];
    let mi1 = mutual_information(&pxy1);
    assert!(
        mi1.abs() < EPSILON,
        "MI(independent) = {}, expected 0",
        mi1
    );

    // Test case 2: Perfectly correlated -> MI = ln(2)
    let pxy2 = [[0.5, 0.0], [0.0, 0.5]];
    let mi2 = mutual_information(&pxy2);
    assert!(
        (mi2 - 0.6931471805599453).abs() < 1e-10,
        "MI(correlated) = {}, expected ln(2)",
        mi2
    );
}

/// Verify pBit probability consistency
#[test]
fn test_pbit_probability() {
    // pBit probability: p(+1) = sigmoid(I/kT) where I is input current
    // At I=0, p(+1) = 0.5
    let p_zero = sigmoid(0.0);
    assert!((p_zero - 0.5).abs() < EPSILON);

    // Positive I -> p(+1) > 0.5
    let p_pos = sigmoid(1.0);
    assert!(p_pos > 0.5);

    // Negative I -> p(+1) < 0.5
    let p_neg = sigmoid(-1.0);
    assert!(p_neg < 0.5);

    // Symmetry: p(I) + p(-I) = 1
    assert!((p_pos + p_neg - 1.0).abs() < EPSILON);
}

// Helper functions

fn ising_hamiltonian_2(spins: &[i32; 2], j: &[[f64; 2]; 2], h: &[f64; 2]) -> f64 {
    let n = spins.len();
    let mut energy = 0.0;

    // Coupling term: -sum J_ij s_i s_j
    for i in 0..n {
        for j_idx in (i + 1)..n {
            energy -= j[i][j_idx] * (spins[i] as f64) * (spins[j_idx] as f64);
        }
    }

    // External field term: -sum h_i s_i
    for i in 0..n {
        energy -= h[i] * (spins[i] as f64);
    }

    energy
}

fn ising_hamiltonian_3(spins: &[i32; 3], j: &[[f64; 3]; 3], h: &[f64; 3]) -> f64 {
    let mut energy = 0.0;

    for i in 0..3 {
        for j_idx in (i + 1)..3 {
            energy -= j[i][j_idx] * (spins[i] as f64) * (spins[j_idx] as f64);
        }
        energy -= h[i] * (spins[i] as f64);
    }

    energy
}

fn mutual_information(pxy: &[[f64; 2]; 2]) -> f64 {
    let px = [pxy[0][0] + pxy[0][1], pxy[1][0] + pxy[1][1]];
    let py = [pxy[0][0] + pxy[1][0], pxy[0][1] + pxy[1][1]];

    let hx = -px.iter().filter(|&&p| p > 0.0).map(|&p| p * p.ln()).sum::<f64>();
    let hy = -py.iter().filter(|&&p| p > 0.0).map(|&p| p * p.ln()).sum::<f64>();

    let hxy = -pxy.iter().flat_map(|row| row.iter())
        .filter(|&&p| p > 0.0)
        .map(|&p| p * p.ln())
        .sum::<f64>();

    hx + hy - hxy
}

fn sigmoid(x: f64) -> f64 {
    1.0 / (1.0 + (-x).exp())
}
