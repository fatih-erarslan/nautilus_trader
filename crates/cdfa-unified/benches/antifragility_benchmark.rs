use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse cdfa_unified::analyzers::antifragility::*;\nuse std::time::Duration;\n\nfn generate_test_data(n: usize) -> (Vec<f64>, Vec<f64>) {\n    let mut prices = Vec::with_capacity(n);\n    let mut volumes = Vec::with_capacity(n);\n    \n    let mut price = 100.0;\n    for i in 0..n {\n        let return_rate = 0.001 * ((i as f64) * 0.1).sin();\n        price *= 1.0 + return_rate;\n        prices.push(price);\n        volumes.push(1000.0 + 100.0 * ((i as f64) * 0.05).cos());\n    }\n    \n    (prices, volumes)\n}\n\nfn benchmark_antifragility_analysis(c: &mut Criterion) {\n    let analyzer = AntifragilityAnalyzer::new().expect(\"Failed to create analyzer\");\n    \n    // Benchmark different data sizes\n    for &size in &[100, 500, 1000, 2000] {\n        let (prices, volumes) = generate_test_data(size);\n        \n        c.bench_function(&format!(\"antifragility_analysis_{}\", size), |b| {\n            b.iter(|| {\n                let result = analyzer.analyze_prices(\n                    black_box(&prices),\n                    black_box(&volumes)\n                );\n                black_box(result)\n            })\n        });\n    }\n}\n\nfn benchmark_volatility_estimators(c: &mut Criterion) {\n    use ndarray::Array1;\n    \n    let analyzer = AntifragilityAnalyzer::new().expect(\"Failed to create analyzer\");\n    let prices = Array1::from_vec((0..1000).map(|i| 100.0 + (i as f64).sin()).collect());\n    let volumes = Array1::ones(1000);\n    \n    c.bench_function(\"yang_zhang_volatility\", |b| {\n        b.iter(|| {\n            let result = analyzer.calculate_yang_zhang_volatility(\n                black_box(&prices),\n                black_box(&volumes)\n            );\n            black_box(result)\n        })\n    });\n    \n    c.bench_function(\"garch_volatility\", |b| {\n        b.iter(|| {\n            let result = analyzer.calculate_garch_volatility(black_box(&prices));\n            black_box(result)\n        })\n    });\n    \n    c.bench_function(\"parkinson_volatility\", |b| {\n        b.iter(|| {\n            let result = analyzer.calculate_parkinson_volatility(black_box(&prices));\n            black_box(result)\n        })\n    });\n    \n    c.bench_function(\"atr_volatility\", |b| {\n        b.iter(|| {\n            let result = analyzer.calculate_atr_volatility(black_box(&prices));\n            black_box(result)\n        })\n    });\n}\n\nfn benchmark_simd_optimization(c: &mut Criterion) {\n    let analyzer = AntifragilityAnalyzer::new().expect(\"Failed to create analyzer\");\n    let (prices, volumes) = generate_test_data(1000);\n    \n    // Compare SIMD vs non-SIMD performance\n    let mut params_simd = AntifragilityParameters::default();\n    params_simd.enable_simd = true;\n    let analyzer_simd = AntifragilityAnalyzer::with_params(params_simd)\n        .expect(\"Failed to create SIMD analyzer\");\n    \n    let mut params_no_simd = AntifragilityParameters::default();\n    params_no_simd.enable_simd = false;\n    let analyzer_no_simd = AntifragilityAnalyzer::with_params(params_no_simd)\n        .expect(\"Failed to create non-SIMD analyzer\");\n    \n    c.bench_function(\"analysis_with_simd\", |b| {\n        b.iter(|| {\n            let result = analyzer_simd.analyze_prices(\n                black_box(&prices),\n                black_box(&volumes)\n            );\n            black_box(result)\n        })\n    });\n    \n    c.bench_function(\"analysis_without_simd\", |b| {\n        b.iter(|| {\n            let result = analyzer_no_simd.analyze_prices(\n                black_box(&prices),\n                black_box(&volumes)\n            );\n            black_box(result)\n        })\n    });\n}\n\nfn benchmark_cache_performance(c: &mut Criterion) {\n    let analyzer = AntifragilityAnalyzer::new().expect(\"Failed to create analyzer\");\n    let (prices, volumes) = generate_test_data(500);\n    \n    // Prime the cache\n    let _ = analyzer.analyze_prices(&prices, &volumes);\n    \n    c.bench_function(\"analysis_cache_hit\", |b| {\n        b.iter(|| {\n            let result = analyzer.analyze_prices(\n                black_box(&prices),\n                black_box(&volumes)\n            );\n            black_box(result)\n        })\n    });\n    \n    c.bench_function(\"analysis_cache_miss\", |b| {\n        b.iter_custom(|iters| {\n            let mut total_duration = Duration::new(0, 0);\n            \n            for i in 0..iters {\n                // Generate unique data for cache miss\n                let (unique_prices, unique_volumes) = generate_test_data(500 + i as usize % 10);\n                \n                let start = std::time::Instant::now();\n                let result = analyzer.analyze_prices(\n                    black_box(&unique_prices),\n                    black_box(&unique_volumes)\n                );\n                total_duration += start.elapsed();\n                black_box(result);\n            }\n            \n            total_duration\n        })\n    });\n}\n\ncriterion_group!(\n    benches,\n    benchmark_antifragility_analysis,\n    benchmark_volatility_estimators,\n    benchmark_simd_optimization,\n    benchmark_cache_performance\n);\ncriterion_main!(benches);\n