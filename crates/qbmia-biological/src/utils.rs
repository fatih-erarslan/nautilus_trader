//! Utility functions for QBMIA biological systems\n\nuse crate::{QBMIAError, QBMIAResult};\nuse ndarray::{Array1, Array2};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Mathematical utilities\npub mod math {\n    use super::*;\n    \n    /// Calculate Gini coefficient for wealth distribution\n    pub fn gini_coefficient(wealth_values: &[f64]) -> f64 {\n        if wealth_values.is_empty() {\n            return 0.0;\n        }\n        \n        let mut sorted = wealth_values.to_vec();\n        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        \n        let n = sorted.len() as f64;\n        let sum: f64 = sorted.iter().sum();\n        \n        if sum == 0.0 {\n            return 0.0;\n        }\n        \n        let mut cumsum = 0.0;\n        for (i, &value) in sorted.iter().enumerate() {\n            cumsum += (2.0 * (i as f64 + 1.0) - n - 1.0) * value;\n        }\n        \n        (cumsum / (n * sum)).max(0.0).min(1.0)\n    }\n    \n    /// Calculate cosine similarity between two vectors\n    pub fn cosine_similarity(a: &Array1<f64>, b: &Array1<f64>) -> f64 {\n        let dot_product = a.dot(b);\n        let norm_a = a.mapv(|x| x * x).sum().sqrt();\n        let norm_b = b.mapv(|x| x * x).sum().sqrt();\n        \n        if norm_a * norm_b == 0.0 {\n            0.0\n        } else {\n            (dot_product / (norm_a * norm_b)).max(0.0).min(1.0)\n        }\n    }\n    \n    /// Normalize array to unit vector\n    pub fn normalize_vector(arr: &Array1<f64>) -> Array1<f64> {\n        let norm = arr.mapv(|x| x * x).sum().sqrt();\n        if norm > 1e-8 {\n            arr / norm\n        } else {\n            arr.clone()\n        }\n    }\n    \n    /// Apply softmax transformation\n    pub fn softmax(arr: &Array1<f64>) -> Array1<f64> {\n        let max_val = arr.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b));\n        let exp_arr = arr.mapv(|x| (x - max_val).exp());\n        let sum = exp_arr.sum();\n        \n        if sum > 0.0 {\n            exp_arr / sum\n        } else {\n            Array1::from_elem(arr.len(), 1.0 / arr.len() as f64)\n        }\n    }\n    \n    /// Calculate entropy of a probability distribution\n    pub fn entropy(probs: &Array1<f64>) -> f64 {\n        -probs.iter()\n            .filter(|&&p| p > 1e-10)\n            .map(|&p| p * p.ln())\n            .sum::<f64>()\n    }\n    \n    /// Calculate mutual information between two distributions\n    pub fn mutual_information(joint: &Array2<f64>) -> f64 {\n        let marginal_x = joint.sum_axis(ndarray::Axis(1));\n        let marginal_y = joint.sum_axis(ndarray::Axis(0));\n        \n        let mut mi = 0.0;\n        for i in 0..joint.nrows() {\n            for j in 0..joint.ncols() {\n                let p_xy = joint[[i, j]];\n                let p_x = marginal_x[i];\n                let p_y = marginal_y[j];\n                \n                if p_xy > 1e-10 && p_x > 1e-10 && p_y > 1e-10 {\n                    mi += p_xy * (p_xy / (p_x * p_y)).ln();\n                }\n            }\n        }\n        \n        mi\n    }\n}\n\n/// Pattern matching utilities\npub mod patterns {\n    use super::*;\n    \n    /// Find patterns in time series data\n    pub fn find_patterns(data: &[f64], pattern_length: usize) -> Vec<Pattern> {\n        let mut patterns = Vec::new();\n        \n        if data.len() < pattern_length * 2 {\n            return patterns;\n        }\n        \n        for i in 0..=data.len() - pattern_length {\n            let pattern_data = &data[i..i + pattern_length];\n            let pattern = Pattern {\n                start_index: i,\n                length: pattern_length,\n                data: pattern_data.to_vec(),\n                strength: calculate_pattern_strength(pattern_data),\n            };\n            patterns.push(pattern);\n        }\n        \n        patterns.sort_by(|a, b| b.strength.partial_cmp(&a.strength).unwrap());\n        patterns\n    }\n    \n    fn calculate_pattern_strength(data: &[f64]) -> f64 {\n        // Simple pattern strength based on variance\n        let mean = data.iter().sum::<f64>() / data.len() as f64;\n        let variance = data.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / data.len() as f64;\n        variance.sqrt()\n    }\n    \n    /// Pattern structure\n    #[derive(Debug, Clone, Serialize, Deserialize)]\n    pub struct Pattern {\n        pub start_index: usize,\n        pub length: usize,\n        pub data: Vec<f64>,\n        pub strength: f64,\n    }\n    \n    /// Detect anomalies in data\n    pub fn detect_anomalies(data: &[f64], threshold: f64) -> Vec<Anomaly> {\n        let mut anomalies = Vec::new();\n        \n        if data.len() < 3 {\n            return anomalies;\n        }\n        \n        let mean = data.iter().sum::<f64>() / data.len() as f64;\n        let std_dev = (data.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / data.len() as f64).sqrt();\n        \n        for (i, &value) in data.iter().enumerate() {\n            let z_score = (value - mean) / std_dev;\n            if z_score.abs() > threshold {\n                anomalies.push(Anomaly {\n                    index: i,\n                    value,\n                    z_score,\n                    severity: if z_score.abs() > threshold * 2.0 { \"high\" } else { \"medium\" }.to_string(),\n                });\n            }\n        }\n        \n        anomalies\n    }\n    \n    /// Anomaly structure\n    #[derive(Debug, Clone, Serialize, Deserialize)]\n    pub struct Anomaly {\n        pub index: usize,\n        pub value: f64,\n        pub z_score: f64,\n        pub severity: String,\n    }\n}\n\n/// Time series utilities\npub mod timeseries {\n    use super::*;\n    \n    /// Calculate moving average\n    pub fn moving_average(data: &[f64], window: usize) -> Vec<f64> {\n        if window == 0 || data.len() < window {\n            return Vec::new();\n        }\n        \n        let mut result = Vec::new();\n        \n        for i in 0..=data.len() - window {\n            let avg = data[i..i + window].iter().sum::<f64>() / window as f64;\n            result.push(avg);\n        }\n        \n        result\n    }\n    \n    /// Calculate exponential moving average\n    pub fn exponential_moving_average(data: &[f64], alpha: f64) -> Vec<f64> {\n        if data.is_empty() {\n            return Vec::new();\n        }\n        \n        let mut result = Vec::with_capacity(data.len());\n        result.push(data[0]);\n        \n        for i in 1..data.len() {\n            let ema = alpha * data[i] + (1.0 - alpha) * result[i - 1];\n            result.push(ema);\n        }\n        \n        result\n    }\n    \n    /// Calculate volatility (rolling standard deviation)\n    pub fn volatility(data: &[f64], window: usize) -> Vec<f64> {\n        if window == 0 || data.len() < window {\n            return Vec::new();\n        }\n        \n        let mut result = Vec::new();\n        \n        for i in 0..=data.len() - window {\n            let window_data = &data[i..i + window];\n            let mean = window_data.iter().sum::<f64>() / window as f64;\n            let variance = window_data.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / window as f64;\n            result.push(variance.sqrt());\n        }\n        \n        result\n    }\n    \n    /// Calculate correlation between two time series\n    pub fn correlation(x: &[f64], y: &[f64]) -> f64 {\n        if x.len() != y.len() || x.is_empty() {\n            return 0.0;\n        }\n        \n        let n = x.len() as f64;\n        let mean_x = x.iter().sum::<f64>() / n;\n        let mean_y = y.iter().sum::<f64>() / n;\n        \n        let mut numerator = 0.0;\n        let mut sum_x2 = 0.0;\n        let mut sum_y2 = 0.0;\n        \n        for i in 0..x.len() {\n            let dx = x[i] - mean_x;\n            let dy = y[i] - mean_y;\n            \n            numerator += dx * dy;\n            sum_x2 += dx * dx;\n            sum_y2 += dy * dy;\n        }\n        \n        let denominator = (sum_x2 * sum_y2).sqrt();\n        \n        if denominator > 1e-10 {\n            numerator / denominator\n        } else {\n            0.0\n        }\n    }\n    \n    /// Calculate returns from prices\n    pub fn returns(prices: &[f64]) -> Vec<f64> {\n        if prices.len() < 2 {\n            return Vec::new();\n        }\n        \n        let mut returns = Vec::with_capacity(prices.len() - 1);\n        \n        for i in 1..prices.len() {\n            if prices[i - 1] > 0.0 {\n                returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);\n            } else {\n                returns.push(0.0);\n            }\n        }\n        \n        returns\n    }\n}\n\n/// Validation utilities\npub mod validation {\n    use super::*;\n    \n    /// Validate market data\n    pub fn validate_market_data(data: &serde_json::Value) -> QBMIAResult<()> {\n        // Check required fields\n        if !data.is_object() {\n            return Err(QBMIAError::ConfigError(\"Market data must be an object\".to_string()));\n        }\n        \n        // Validate snapshot\n        if let Some(snapshot) = data.get(\"snapshot\") {\n            if let Some(price) = snapshot.get(\"price\").and_then(|v| v.as_f64()) {\n                if price <= 0.0 {\n                    return Err(QBMIAError::ConfigError(\"Price must be positive\".to_string()));\n                }\n            }\n            \n            if let Some(volume) = snapshot.get(\"volume\").and_then(|v| v.as_f64()) {\n                if volume < 0.0 {\n                    return Err(QBMIAError::ConfigError(\"Volume must be non-negative\".to_string()));\n                }\n            }\n        }\n        \n        // Validate price history\n        if let Some(history) = data.get(\"price_history\").and_then(|v| v.as_array()) {\n            if history.is_empty() {\n                return Err(QBMIAError::ConfigError(\"Price history cannot be empty\".to_string()));\n            }\n            \n            for (i, price) in history.iter().enumerate() {\n                if let Some(p) = price.as_f64() {\n                    if p <= 0.0 {\n                        return Err(QBMIAError::ConfigError(format!(\"Price at index {} must be positive\", i)));\n                    }\n                } else {\n                    return Err(QBMIAError::ConfigError(format!(\"Invalid price at index {}\", i)));\n                }\n            }\n        }\n        \n        Ok(())\n    }\n    \n    /// Validate decision data\n    pub fn validate_decision(decision: &serde_json::Value) -> QBMIAResult<()> {\n        if !decision.is_object() {\n            return Err(QBMIAError::ConfigError(\"Decision must be an object\".to_string()));\n        }\n        \n        // Validate action\n        if let Some(action) = decision.get(\"action\").and_then(|v| v.as_str()) {\n            if ![\"buy\", \"sell\", \"hold\", \"wait\"].contains(&action) {\n                return Err(QBMIAError::ConfigError(\"Invalid action\".to_string()));\n            }\n        }\n        \n        // Validate confidence\n        if let Some(confidence) = decision.get(\"confidence\").and_then(|v| v.as_f64()) {\n            if confidence < 0.0 || confidence > 1.0 {\n                return Err(QBMIAError::ConfigError(\"Confidence must be between 0 and 1\".to_string()));\n            }\n        }\n        \n        // Validate decision vector\n        if let Some(vector) = decision.get(\"decision_vector\").and_then(|v| v.as_array()) {\n            if vector.len() != 4 {\n                return Err(QBMIAError::ConfigError(\"Decision vector must have 4 elements\".to_string()));\n            }\n            \n            let mut sum = 0.0;\n            for (i, val) in vector.iter().enumerate() {\n                if let Some(v) = val.as_f64() {\n                    if v < 0.0 {\n                        return Err(QBMIAError::ConfigError(format!(\"Decision vector element {} must be non-negative\", i)));\n                    }\n                    sum += v;\n                } else {\n                    return Err(QBMIAError::ConfigError(format!(\"Invalid decision vector element at index {}\", i)));\n                }\n            }\n            \n            if (sum - 1.0).abs() > 1e-6 {\n                return Err(QBMIAError::ConfigError(\"Decision vector must sum to 1.0\".to_string()));\n            }\n        }\n        \n        Ok(())\n    }\n    \n    /// Validate configuration\n    pub fn validate_config(config: &serde_json::Value) -> QBMIAResult<()> {\n        if !config.is_object() {\n            return Err(QBMIAError::ConfigError(\"Configuration must be an object\".to_string()));\n        }\n        \n        // Validate numeric parameters\n        if let Some(num_qubits) = config.get(\"num_qubits\").and_then(|v| v.as_u64()) {\n            if num_qubits == 0 || num_qubits > 32 {\n                return Err(QBMIAError::ConfigError(\"num_qubits must be between 1 and 32\".to_string()));\n            }\n        }\n        \n        if let Some(memory_capacity) = config.get(\"memory_capacity\").and_then(|v| v.as_u64()) {\n            if memory_capacity == 0 {\n                return Err(QBMIAError::ConfigError(\"memory_capacity must be positive\".to_string()));\n            }\n        }\n        \n        if let Some(learning_rate) = config.get(\"learning_rate\").and_then(|v| v.as_f64()) {\n            if learning_rate <= 0.0 || learning_rate > 1.0 {\n                return Err(QBMIAError::ConfigError(\"learning_rate must be between 0 and 1\".to_string()));\n            }\n        }\n        \n        Ok(())\n    }\n}\n\n/// Serialization utilities\npub mod serialization {\n    use super::*;\n    \n    /// Serialize array to JSON\n    pub fn serialize_array(arr: &Array1<f64>) -> serde_json::Value {\n        serde_json::json!(arr.to_vec())\n    }\n    \n    /// Deserialize array from JSON\n    pub fn deserialize_array(value: &serde_json::Value) -> QBMIAResult<Array1<f64>> {\n        if let Some(arr) = value.as_array() {\n            let vec: Result<Vec<f64>, _> = arr.iter().map(|v| {\n                v.as_f64().ok_or_else(|| QBMIAError::SerializationError(\n                    serde_json::Error::custom(\"Invalid array element\")\n                ))\n            }).collect();\n            \n            Ok(Array1::from_vec(vec?))\n        } else {\n            Err(QBMIAError::SerializationError(\n                serde_json::Error::custom(\"Value is not an array\")\n            ))\n        }\n    }\n    \n    /// Serialize hashmap to JSON\n    pub fn serialize_hashmap<T: Serialize>(map: &HashMap<String, T>) -> serde_json::Value {\n        serde_json::to_value(map).unwrap_or(serde_json::Value::Null)\n    }\n    \n    /// Deserialize hashmap from JSON\n    pub fn deserialize_hashmap<T: for<'de> Deserialize<'de>>(value: &serde_json::Value) -> QBMIAResult<HashMap<String, T>> {\n        serde_json::from_value(value.clone())\n            .map_err(|e| QBMIAError::SerializationError(e))\n    }\n}\n\n/// Logging utilities\npub mod logging {\n    use super::*;\n    \n    /// Log performance metrics\n    pub fn log_performance(component: &str, operation: &str, duration: std::time::Duration, success: bool) {\n        if success {\n            tracing::info!(\n                \"{}::{} completed in {:?}\",\n                component,\n                operation,\n                duration\n            );\n        } else {\n            tracing::warn!(\n                \"{}::{} failed after {:?}\",\n                component,\n                operation,\n                duration\n            );\n        }\n    }\n    \n    /// Log memory usage\n    pub fn log_memory_usage(component: &str, used_mb: f64, total_mb: f64) {\n        let usage_percent = (used_mb / total_mb) * 100.0;\n        \n        if usage_percent > 90.0 {\n            tracing::warn!(\n                \"{} memory usage: {:.1}MB / {:.1}MB ({:.1}%)\",\n                component,\n                used_mb,\n                total_mb,\n                usage_percent\n            );\n        } else {\n            tracing::debug!(\n                \"{} memory usage: {:.1}MB / {:.1}MB ({:.1}%)\",\n                component,\n                used_mb,\n                total_mb,\n                usage_percent\n            );\n        }\n    }\n    \n    /// Log error with context\n    pub fn log_error(component: &str, operation: &str, error: &QBMIAError) {\n        tracing::error!(\n            \"{}::{} error: {}\",\n            component,\n            operation,\n            error\n        );\n    }\n}\n\n/// Configuration utilities\npub mod config {\n    use super::*;\n    \n    /// Load configuration from file\n    pub fn load_config(path: &str) -> QBMIAResult<serde_json::Value> {\n        let content = std::fs::read_to_string(path)\n            .map_err(|e| QBMIAError::IoError(e))?;\n        \n        let config: serde_json::Value = serde_json::from_str(&content)\n            .map_err(|e| QBMIAError::SerializationError(e))?;\n        \n        validation::validate_config(&config)?;\n        \n        Ok(config)\n    }\n    \n    /// Save configuration to file\n    pub fn save_config(path: &str, config: &serde_json::Value) -> QBMIAResult<()> {\n        validation::validate_config(config)?;\n        \n        let content = serde_json::to_string_pretty(config)\n            .map_err(|e| QBMIAError::SerializationError(e))?;\n        \n        std::fs::write(path, content)\n            .map_err(|e| QBMIAError::IoError(e))?;\n        \n        Ok(())\n    }\n    \n    /// Merge configurations\n    pub fn merge_configs(base: &serde_json::Value, override_config: &serde_json::Value) -> serde_json::Value {\n        let mut merged = base.clone();\n        \n        if let (Some(base_obj), Some(override_obj)) = (base.as_object(), override_config.as_object()) {\n            if let Some(merged_obj) = merged.as_object_mut() {\n                for (key, value) in override_obj {\n                    merged_obj.insert(key.clone(), value.clone());\n                }\n            }\n        }\n        \n        merged\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_gini_coefficient() {\n        let equal_wealth = vec![1.0, 1.0, 1.0, 1.0];\n        assert!((math::gini_coefficient(&equal_wealth) - 0.0).abs() < 1e-6);\n        \n        let unequal_wealth = vec![1.0, 2.0, 3.0, 4.0];\n        assert!(math::gini_coefficient(&unequal_wealth) > 0.0);\n    }\n    \n    #[test]\n    fn test_cosine_similarity() {\n        let a = Array1::from(vec![1.0, 0.0, 0.0]);\n        let b = Array1::from(vec![1.0, 0.0, 0.0]);\n        assert!((math::cosine_similarity(&a, &b) - 1.0).abs() < 1e-6);\n        \n        let c = Array1::from(vec![0.0, 1.0, 0.0]);\n        assert!((math::cosine_similarity(&a, &c) - 0.0).abs() < 1e-6);\n    }\n    \n    #[test]\n    fn test_moving_average() {\n        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n        let ma = timeseries::moving_average(&data, 3);\n        assert_eq!(ma.len(), 3);\n        assert!((ma[0] - 2.0).abs() < 1e-6);\n        assert!((ma[1] - 3.0).abs() < 1e-6);\n        assert!((ma[2] - 4.0).abs() < 1e-6);\n    }\n    \n    #[test]\n    fn test_correlation() {\n        let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n        let y = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n        assert!((timeseries::correlation(&x, &y) - 1.0).abs() < 1e-6);\n        \n        let z = vec![5.0, 4.0, 3.0, 2.0, 1.0];\n        assert!((timeseries::correlation(&x, &z) + 1.0).abs() < 1e-6);\n    }\n    \n    #[test]\n    fn test_returns() {\n        let prices = vec![100.0, 110.0, 99.0, 105.0];\n        let returns = timeseries::returns(&prices);\n        assert_eq!(returns.len(), 3);\n        assert!((returns[0] - 0.1).abs() < 1e-6);\n        assert!((returns[1] - (-0.1)).abs() < 1e-6);\n    }\n    \n    #[test]\n    fn test_softmax() {\n        let arr = Array1::from(vec![1.0, 2.0, 3.0]);\n        let softmax = math::softmax(&arr);\n        assert!((softmax.sum() - 1.0).abs() < 1e-6);\n        assert!(softmax[2] > softmax[1]);\n        assert!(softmax[1] > softmax[0]);\n    }\n    \n    #[test]\n    fn test_entropy() {\n        let uniform = Array1::from(vec![0.25, 0.25, 0.25, 0.25]);\n        let entropy = math::entropy(&uniform);\n        assert!(entropy > 0.0);\n        \n        let certain = Array1::from(vec![1.0, 0.0, 0.0, 0.0]);\n        let entropy_certain = math::entropy(&certain);\n        assert!(entropy_certain < entropy);\n    }\n    \n    #[test]\n    fn test_pattern_detection() {\n        let data = vec![1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 5.0];\n        let patterns = patterns::find_patterns(&data, 3);\n        assert!(!patterns.is_empty());\n    }\n    \n    #[test]\n    fn test_anomaly_detection() {\n        let data = vec![1.0, 1.0, 1.0, 10.0, 1.0, 1.0];\n        let anomalies = patterns::detect_anomalies(&data, 2.0);\n        assert_eq!(anomalies.len(), 1);\n        assert_eq!(anomalies[0].index, 3);\n    }\n    \n    #[test]\n    fn test_validation() {\n        let valid_data = serde_json::json!({\n            \"snapshot\": {\n                \"price\": 100.0,\n                \"volume\": 1000.0\n            },\n            \"price_history\": [95.0, 98.0, 100.0, 102.0]\n        });\n        \n        assert!(validation::validate_market_data(&valid_data).is_ok());\n        \n        let invalid_data = serde_json::json!({\n            \"snapshot\": {\n                \"price\": -100.0,\n                \"volume\": 1000.0\n            }\n        });\n        \n        assert!(validation::validate_market_data(&invalid_data).is_err());\n    }\n    \n    #[test]\n    fn test_array_serialization() {\n        let arr = Array1::from(vec![1.0, 2.0, 3.0]);\n        let json = serialization::serialize_array(&arr);\n        let restored = serialization::deserialize_array(&json).unwrap();\n        \n        assert_eq!(arr.len(), restored.len());\n        for (a, b) in arr.iter().zip(restored.iter()) {\n            assert!((a - b).abs() < 1e-6);\n        }\n    }\n}\n"