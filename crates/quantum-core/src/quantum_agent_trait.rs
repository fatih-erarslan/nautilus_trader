//! Unified Quantum Agent Trait for Nautilus Trader
//!
//! This module defines the core QuantumAgent trait that unifies all quantum trading agents
//! under a common interface, enabling PADS integration and unified orchestration.

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::error::{QuantumError, QuantumResult};
use crate::quantum_state::QuantumState;

/// Market data structure for quantum agent processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketData {
    /// Market symbol
    pub symbol: String,
    /// Current price
    pub price: f64,
    /// Volume
    pub volume: f64,
    /// Market factors [trend, volatility, momentum, sentiment, liquidity, correlation, cycle, anomaly]
    pub factors: [f64; 8],
    /// Volatility measure
    pub volatility: f64,
    /// Bid-ask spread
    pub spread: f64,
    /// Market timestamp
    pub timestamp: i64,
}

impl MarketData {
    /// Create new market data with standard 8-factor model
    pub fn new(symbol: String, price: f64, volume: f64, factors: [f64; 8]) -> Self {
        Self {
            symbol,
            price,
            volume,
            factors,
            volatility: factors[1], // Volatility factor
            spread: price * 0.001,  // Default 0.1% spread
            timestamp: Utc::now().timestamp_millis(),
        }
    }
}

/// Lattice state representing the quantum entanglement network
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LatticeState {
    /// Lattice dimensions
    pub dimensions: (usize, usize, usize),
    /// Entanglement strengths between agents
    pub entanglement_matrix: Vec<Vec<f64>>,
    /// Coherence levels across the lattice
    pub coherence_levels: Vec<f64>,
    /// Quantum field fluctuations
    pub field_fluctuations: Vec<f64>,
    /// Last update timestamp
    pub last_update: DateTime<Utc>,
}

impl LatticeState {
    /// Create new lattice state
    pub fn new(num_agents: usize) -> Self {
        Self {
            dimensions: (num_agents, num_agents, 1),
            entanglement_matrix: vec![vec![0.0; num_agents]; num_agents],
            coherence_levels: vec![1.0; num_agents],
            field_fluctuations: vec![0.0; num_agents],
            last_update: Utc::now(),
        }
    }
    
    /// Update entanglement between two agents
    pub fn update_entanglement(&mut self, agent1: usize, agent2: usize, strength: f64) {
        if agent1 < self.entanglement_matrix.len() && agent2 < self.entanglement_matrix[agent1].len() {
            self.entanglement_matrix[agent1][agent2] = strength;
            self.entanglement_matrix[agent2][agent1] = strength; // Symmetric
        }
    }
    
    /// Get entanglement strength between agents
    pub fn get_entanglement(&self, agent1: usize, agent2: usize) -> f64 {
        self.entanglement_matrix.get(agent1)
            .and_then(|row| row.get(agent2))
            .copied()
            .unwrap_or(0.0)
    }
}

/// Quantum signal generated by agents
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuantumSignal {
    /// Signal identifier
    pub id: String,
    /// Agent that generated the signal
    pub agent_id: String,
    /// Signal type
    pub signal_type: QuantumSignalType,
    /// Signal strength (0.0 to 1.0)
    pub strength: f64,
    /// Quantum amplitude
    pub amplitude: f64,
    /// Quantum phase
    pub phase: f64,
    /// Coherence metric
    pub coherence: f64,
    /// Entanglement information
    pub entanglement: HashMap<String, f64>,
    /// Classical signal data
    pub data: HashMap<String, f64>,
    /// Signal metadata
    pub metadata: HashMap<String, String>,
    /// Generation timestamp
    pub timestamp: DateTime<Utc>,
}

/// Types of quantum signals
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum QuantumSignalType {
    /// Trading action signal
    Trading,
    /// Risk management signal
    Risk,
    /// Market prediction signal
    Prediction,
    /// Arbitrage opportunity signal
    Arbitrage,
    /// Portfolio optimization signal
    Portfolio,
    /// Hedging signal
    Hedge,
    /// Prospect theory signal
    Prospect,
    /// Neural optimization signal
    Neural,
}

/// PADS signal for unified orchestration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PADSSignal {
    /// Original quantum signal
    pub quantum_signal: QuantumSignal,
    /// PADS action recommendation
    pub action: PADSAction,
    /// Confidence level
    pub confidence: f64,
    /// Risk assessment
    pub risk_level: f64,
    /// Expected return
    pub expected_return: f64,
    /// Position sizing recommendation
    pub position_size: f64,
    /// PADS metadata
    pub metadata: HashMap<String, String>,
}

/// PADS action types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PADSAction {
    Buy,
    Sell,
    Hold,
    Increase(u8),
    Decrease(u8),
    Close,
    Hedge,
    Rebalance,
}

/// Quantum state configuration for agents
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuantumConfig {
    /// Number of qubits
    pub num_qubits: usize,
    /// Circuit depth
    pub circuit_depth: usize,
    /// Error correction enabled
    pub error_correction: bool,
    /// Coherence time in microseconds
    pub coherence_time_us: f64,
    /// Decoherence rate
    pub decoherence_rate: f64,
    /// Agent-specific parameters
    pub parameters: HashMap<String, f64>,
}

impl Default for QuantumConfig {
    fn default() -> Self {
        Self {
            num_qubits: 8,
            circuit_depth: 6,
            error_correction: true,
            coherence_time_us: 100.0,
            decoherence_rate: 0.001,
            parameters: HashMap::new(),
        }
    }
}

/// Core trait that all quantum agents must implement
#[async_trait]
pub trait QuantumAgent: Send + Sync {
    /// Agent's quantum signal type (uses concrete QuantumSignal struct)
    type Signal: Send + Sync + Clone;
    
    /// Agent's quantum state type (uses concrete QuantumState struct)  
    type State: Send + Sync + Clone;
    
    /// Agent's configuration type
    type Config: Send + Sync + Clone;

    /// Get unique agent identifier
    fn agent_id(&self) -> &str;
    
    /// Get agent type/name
    fn agent_type(&self) -> &str;
    
    /// Get agent version
    fn version(&self) -> &str;
    
    /// Process market data and generate quantum signal
    async fn process(
        &mut self,
        market_data: &MarketData,
        lattice_state: &LatticeState,
    ) -> QuantumResult<Self::Signal>;
    
    /// Convert quantum signal to PADS signal
    fn to_pads_signal(&self, signal: Self::Signal) -> PADSSignal;
    
    /// Measure quantum coherence of the agent
    fn coherence_metric(&self) -> f64;
    
    /// Calculate entanglement entropy with other agents
    fn entanglement_entropy(&self, other_agents: &[&dyn DynQuantumAgent]) -> f64;
    
    /// Detect decoherence events
    fn detect_decoherence(&self) -> Option<DecoherenceEvent>;
    
    /// Perform emergency shutdown
    async fn emergency_shutdown(&mut self) -> QuantumResult<()>;
    
    /// Get agent configuration
    fn config(&self) -> &Self::Config;
    
    /// Update configuration
    async fn update_config(&mut self, config: Self::Config) -> QuantumResult<()>;
    
    /// Health check
    async fn health_check(&self) -> QuantumResult<AgentHealth>;
    
    /// Performance metrics
    fn performance_metrics(&self) -> AgentMetrics;
    
    /// Classical fallback processing
    async fn classical_fallback(
        &mut self,
        market_data: &MarketData,
    ) -> QuantumResult<Self::Signal>;
}

/// Decoherence event information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecoherenceEvent {
    /// Event identifier
    pub id: String,
    /// Agent that detected the event
    pub agent_id: String,
    /// Event severity (0.0 to 1.0)
    pub severity: f64,
    /// Event type
    pub event_type: DecoherenceType,
    /// Event description
    pub description: String,
    /// Detection timestamp
    pub timestamp: DateTime<Utc>,
}

/// Types of decoherence events
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum DecoherenceType {
    /// Thermal decoherence
    Thermal,
    /// Dephasing
    Dephasing,
    /// Amplitude damping
    AmplitudeDamping,
    /// Gate error
    GateError,
    /// Measurement error
    MeasurementError,
    /// Environmental noise
    Environmental,
}

/// Agent health status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentHealth {
    /// Overall health status
    pub status: HealthStatus,
    /// Coherence level
    pub coherence: f64,
    /// Error rate
    pub error_rate: f64,
    /// Performance score
    pub performance: f64,
    /// Resource utilization
    pub resource_utilization: f64,
    /// Last health check
    pub last_check: DateTime<Utc>,
    /// Health issues
    pub issues: Vec<HealthIssue>,
}

/// Health status levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Warning,
    Critical,
    Failed,
}

/// Health issues
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthIssue {
    /// Issue type
    pub issue_type: String,
    /// Issue severity
    pub severity: HealthStatus,
    /// Issue description
    pub description: String,
    /// Issue timestamp
    pub timestamp: DateTime<Utc>,
}

/// Agent performance metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentMetrics {
    /// Total signals generated
    pub signals_generated: u64,
    /// Success rate
    pub success_rate: f64,
    /// Average processing time in milliseconds
    pub avg_processing_time_ms: f64,
    /// Quantum advantage ratio
    pub quantum_advantage: f64,
    /// Coherence maintenance score
    pub coherence_score: f64,
    /// Energy efficiency score
    pub energy_efficiency: f64,
    /// Error correction rate
    pub error_correction_rate: f64,
    /// Uptime percentage
    pub uptime_percentage: f64,
    /// Memory usage in MB
    pub memory_usage_mb: f64,
    /// CPU utilization percentage
    pub cpu_utilization: f64,
}

impl Default for AgentMetrics {
    fn default() -> Self {
        Self {
            signals_generated: 0,
            success_rate: 0.0,
            avg_processing_time_ms: 0.0,
            quantum_advantage: 1.0,
            coherence_score: 1.0,
            energy_efficiency: 1.0,
            error_correction_rate: 0.0,
            uptime_percentage: 100.0,
            memory_usage_mb: 0.0,
            cpu_utilization: 0.0,
        }
    }
}

/// Type-erased quantum agent for dynamic dispatch
#[async_trait]
pub trait DynQuantumAgent: Send + Sync {
    /// Get unique agent identifier
    fn agent_id(&self) -> &str;
    
    /// Get agent type/name
    fn agent_type(&self) -> &str;
    
    /// Get agent version
    fn version(&self) -> &str;
    
    /// Process market data and generate generic signal
    async fn process_market_data(
        &mut self,
        market_data: &MarketData,
        lattice_state: &LatticeState,
    ) -> QuantumResult<PADSSignal>;
    
    /// Measure quantum coherence of the agent
    fn coherence_metric(&self) -> f64;
    
    /// Calculate entanglement entropy with other agents  
    fn entanglement_entropy(&self, other_agents: &[&dyn DynQuantumAgent]) -> f64;
    
    /// Detect decoherence events
    fn detect_decoherence(&self) -> Option<DecoherenceEvent>;
    
    /// Perform emergency shutdown
    async fn emergency_shutdown(&mut self) -> QuantumResult<()>;
}

/// Quantum agent registry for managing all agents
pub struct QuantumAgentRegistry {
    agents: HashMap<String, Box<dyn DynQuantumAgent>>,
    lattice_state: LatticeState,
    metrics: RegistryMetrics,
}

impl QuantumAgentRegistry {
    /// Create new registry
    pub fn new() -> Self {
        Self {
            agents: HashMap::new(),
            lattice_state: LatticeState::new(0),
            metrics: RegistryMetrics::default(),
        }
    }
    
    /// Register a quantum agent
    pub fn register_agent(&mut self, agent: Box<dyn DynQuantumAgent>) -> QuantumResult<()> {
        let agent_id = agent.agent_id().to_string();
        
        // Update lattice state
        let new_size = self.agents.len() + 1;
        self.lattice_state = LatticeState::new(new_size);
        
        // Register agent
        self.agents.insert(agent_id.clone(), agent);
        
        tracing::info!("Registered quantum agent: {}", agent_id);
        Ok(())
    }
    
    /// Get agent by ID
    pub fn get_agent(&self, agent_id: &str) -> Option<&Box<dyn DynQuantumAgent>> {
        self.agents.get(agent_id)
    }
    
    /// List all registered agents
    pub fn list_agents(&self) -> Vec<&str> {
        self.agents.keys().map(|s| s.as_str()).collect()
    }
    
    /// Process market data across all agents
    pub async fn process_market_data(&mut self, market_data: &MarketData) -> QuantumResult<Vec<PADSSignal>> {
        let mut signals = Vec::new();
        
        for agent in self.agents.values_mut() {
            match agent.process_market_data(market_data, &self.lattice_state).await {
                Ok(pads_signal) => {
                    signals.push(pads_signal);
                }
                Err(e) => {
                    tracing::warn!("Agent {} failed to process market data: {:?}", agent.agent_id(), e);
                    // Continue with other agents on failure
                }
            }
        }
        
        self.update_lattice_state(&signals).await;
        Ok(signals)
    }
    
    /// Update lattice state based on agent interactions
    async fn update_lattice_state(&mut self, signals: &[PADSSignal]) {
        // Calculate entanglement between agents based on signal correlations
        for (i, signal1) in signals.iter().enumerate() {
            for (j, signal2) in signals.iter().enumerate() {
                if i != j {
                    let correlation = self.calculate_signal_correlation(signal1, signal2);
                    self.lattice_state.update_entanglement(i, j, correlation);
                }
            }
        }
        
        self.lattice_state.last_update = Utc::now();
    }
    
    /// Calculate correlation between two signals
    fn calculate_signal_correlation(&self, signal1: &PADSSignal, signal2: &PADSSignal) -> f64 {
        // Simplified correlation based on signal similarity
        let amplitude_diff = (signal1.quantum_signal.amplitude - signal2.quantum_signal.amplitude).abs();
        let phase_diff = (signal1.quantum_signal.phase - signal2.quantum_signal.phase).abs();
        let coherence_diff = (signal1.quantum_signal.coherence - signal2.quantum_signal.coherence).abs();
        
        let total_diff = amplitude_diff + phase_diff + coherence_diff;
        (1.0 - total_diff / 3.0).max(0.0)
    }
    
    /// Get overall system coherence
    pub fn system_coherence(&self) -> f64 {
        if self.agents.is_empty() {
            return 1.0;
        }
        
        let total_coherence: f64 = self.agents.values()
            .map(|agent| agent.coherence_metric())
            .sum();
            
        total_coherence / self.agents.len() as f64
    }
    
    /// Get registry metrics
    pub fn metrics(&self) -> &RegistryMetrics {
        &self.metrics
    }
}

/// Registry performance metrics
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct RegistryMetrics {
    /// Total agents registered
    pub total_agents: usize,
    /// Active agents
    pub active_agents: usize,
    /// Total signals processed
    pub total_signals: u64,
    /// Average system coherence
    pub avg_coherence: f64,
    /// System uptime
    pub uptime: std::time::Duration,
    /// Last metrics update
    pub last_update: Option<DateTime<Utc>>,
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_market_data_creation() {
        let factors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
        let market_data = MarketData::new("BTCUSD".to_string(), 50000.0, 1000.0, factors);
        
        assert_eq!(market_data.symbol, "BTCUSD");
        assert_eq!(market_data.price, 50000.0);
        assert_eq!(market_data.factors, factors);
    }
    
    #[test]
    fn test_lattice_state() {
        let mut lattice = LatticeState::new(3);
        lattice.update_entanglement(0, 1, 0.8);
        
        assert_eq!(lattice.get_entanglement(0, 1), 0.8);
        assert_eq!(lattice.get_entanglement(1, 0), 0.8); // Symmetric
    }
    
    #[test]
    fn test_quantum_config_default() {
        let config = QuantumConfig::default();
        assert_eq!(config.num_qubits, 8);
        assert_eq!(config.circuit_depth, 6);
        assert!(config.error_correction);
    }
}