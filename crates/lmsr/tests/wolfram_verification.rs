//! Formal verification tests for LMSR generated by Wolfram
//!
//! These test vectors verify the mathematical correctness of
//! the Logarithmic Market Scoring Rule implementation.
//!
//! Generated: 2025-12-06
//! Reference: Hanson (2003) "Combinatorial Information Market Design"

use lmsr_rs::lmsr::LMSRCalculator;

const EPSILON: f64 = 1e-10;

/// Wolfram-verified LMSR cost function
/// Formula: C(q) = b * log(sum(exp(q_i/b)))
#[test]
fn test_lmsr_cost_function_wolfram_verified() {
    let b = 100.0;
    let calc = LMSRCalculator::new(2, b).unwrap();

    // Test case 1: q = [0, 0], expected cost = b * ln(2) = 69.31471805599453
    let cost1 = calc.cost_function(&[0.0, 0.0]).unwrap();
    assert!(
        (cost1 - 69.31471805599453).abs() < 1e-8,
        "Cost for [0,0]: got {}, expected 69.31471805599453",
        cost1
    );

    // Test case 2: q = [50, 50], expected cost = 119.31471805599455
    let cost2 = calc.cost_function(&[50.0, 50.0]).unwrap();
    assert!(
        (cost2 - 119.31471805599455).abs() < 1e-8,
        "Cost for [50,50]: got {}, expected 119.31471805599455",
        cost2
    );

    // Test case 3: q = [100, 0], expected cost = 131.32616875182228
    let cost3 = calc.cost_function(&[100.0, 0.0]).unwrap();
    assert!(
        (cost3 - 131.32616875182228).abs() < 1e-8,
        "Cost for [100,0]: got {}, expected 131.32616875182228",
        cost3
    );
}

/// Wolfram-verified LMSR marginal prices
/// Formula: p_i = exp(q_i/b) / sum(exp(q_j/b))
#[test]
fn test_lmsr_prices_wolfram_verified() {
    let b = 100.0;
    let calc = LMSRCalculator::new(2, b).unwrap();

    // Test case 1: q = [0, 0] -> prices = [0.5, 0.5]
    let prices1 = calc.all_marginal_prices(&[0.0, 0.0]).unwrap();
    assert!((prices1[0] - 0.5).abs() < EPSILON);
    assert!((prices1[1] - 0.5).abs() < EPSILON);

    // Test case 2: q = [50, 50] -> prices = [0.5, 0.5]
    let prices2 = calc.all_marginal_prices(&[50.0, 50.0]).unwrap();
    assert!((prices2[0] - 0.5).abs() < EPSILON);
    assert!((prices2[1] - 0.5).abs() < EPSILON);

    // Test case 3: q = [100, 0] -> prices = [0.7310585786, 0.2689414214]
    let prices3 = calc.all_marginal_prices(&[100.0, 0.0]).unwrap();
    assert!(
        (prices3[0] - 0.7310585786300048).abs() < 1e-8,
        "Price[0] for [100,0]: got {}, expected 0.7310585786",
        prices3[0]
    );
    assert!(
        (prices3[1] - 0.2689414213699951).abs() < 1e-8,
        "Price[1] for [100,0]: got {}, expected 0.2689414214",
        prices3[1]
    );
}

/// Verify prices sum to 1.0 (probability constraint)
#[test]
fn test_lmsr_prices_sum_to_one() {
    let calc = LMSRCalculator::new(3, 100.0).unwrap();

    let test_cases = vec![
        vec![0.0, 0.0, 0.0],
        vec![10.0, 20.0, 30.0],
        vec![100.0, 50.0, 25.0],
        vec![-10.0, 0.0, 10.0],
    ];

    for q in test_cases {
        let prices = calc.all_marginal_prices(&q).unwrap();
        let sum: f64 = prices.iter().sum();
        assert!(
            (sum - 1.0).abs() < EPSILON,
            "Prices sum to {} for q={:?}, should be 1.0",
            sum,
            q
        );
    }
}

/// Verify trade cost equals difference in cost function
#[test]
fn test_lmsr_trade_cost_consistency() {
    let calc = LMSRCalculator::new(2, 100.0).unwrap();

    let q_before = vec![0.0, 0.0];
    let q_after = vec![10.0, 0.0];

    let cost_before = calc.cost_function(&q_before).unwrap();
    let cost_after = calc.cost_function(&q_after).unwrap();
    let trade_cost = calc.trade_cost(&q_before, &q_after).unwrap();

    assert!(
        (trade_cost - (cost_after - cost_before)).abs() < EPSILON,
        "Trade cost inconsistency: {} vs {}",
        trade_cost,
        cost_after - cost_before
    );
}
