//! Formal verification tests for Thermodynamics generated by Wolfram
//!
//! These test vectors verify the mathematical correctness of
//! thermodynamic computations including Landauer bound.
//!
//! Generated: 2025-12-06
//! Reference: Landauer (1961) "Irreversibility and Heat Generation"

const EPSILON: f64 = 1e-10;

/// Boltzmann constant in J/K
const K_BOLTZMANN: f64 = 1.380649e-23;

/// Wolfram-verified Landauer bound
/// E_min = k_B * T * ln(2) per bit erased
#[test]
fn test_landauer_bound_wolfram_verified() {
    // At room temperature (300K), 1 bit requires 2.870978885078724e-21 J
    let temp = 300.0;
    let expected_1bit = 2.870978885078724e-21;
    let computed_1bit = K_BOLTZMANN * temp * 2.0_f64.ln();

    assert!(
        (computed_1bit - expected_1bit).abs() / expected_1bit < 1e-10,
        "Landauer bound at 300K for 1 bit: {} J, expected {} J",
        computed_1bit,
        expected_1bit
    );

    // 1000 bits requires 2.8709788850787235e-18 J
    let expected_1000bits = 2.8709788850787235e-18;
    let computed_1000bits = K_BOLTZMANN * temp * 2.0_f64.ln() * 1000.0;

    assert!(
        (computed_1000bits - expected_1000bits).abs() / expected_1000bits < 1e-10,
        "Landauer bound at 300K for 1000 bits: {} J, expected {} J",
        computed_1000bits,
        expected_1000bits
    );
}

/// Wolfram-verified Boltzmann distribution
/// p_i = exp(-E_i / kT) / Z
#[test]
fn test_boltzmann_distribution_wolfram_verified() {
    // Test case 1: energies [0,1,2], T=1.0
    let energies1 = [0.0, 1.0, 2.0];
    let temp1 = 1.0;
    let probs1 = boltzmann_distribution(&energies1, temp1);

    let expected1 = [0.6652409557748218, 0.2447284710547976, 0.09003057317038045];
    for i in 0..3 {
        assert!(
            (probs1[i] - expected1[i]).abs() < 1e-8,
            "Boltzmann p[{}] at T=1: {}, expected {}",
            i,
            probs1[i],
            expected1[i]
        );
    }

    // Test case 2: same energies, lower T=0.5 (more peaked)
    let temp2 = 0.5;
    let probs2 = boltzmann_distribution(&energies1, temp2);

    let expected2 = [0.8668133321973347, 0.11731042782619835, 0.015876239976466762];
    for i in 0..3 {
        assert!(
            (probs2[i] - expected2[i]).abs() < 1e-8,
            "Boltzmann p[{}] at T=0.5: {}, expected {}",
            i,
            probs2[i],
            expected2[i]
        );
    }
}

/// Verify Boltzmann distribution properties
#[test]
fn test_boltzmann_properties() {
    let energies = [0.0, 1.0, 2.0, 3.0];
    let temp = 1.5;
    let probs = boltzmann_distribution(&energies, temp);

    // 1. Probabilities sum to 1
    let sum: f64 = probs.iter().sum();
    assert!(
        (sum - 1.0).abs() < EPSILON,
        "Boltzmann probs sum to {}, expected 1.0",
        sum
    );

    // 2. Lower energy states have higher probability
    for i in 0..probs.len() - 1 {
        assert!(
            probs[i] > probs[i + 1],
            "p[{}] = {} should be > p[{}] = {}",
            i,
            probs[i],
            i + 1,
            probs[i + 1]
        );
    }

    // 3. As T -> infinity, distribution becomes uniform
    let probs_high_t = boltzmann_distribution(&energies, 1000.0);
    for p in &probs_high_t {
        assert!(
            (p - 0.25).abs() < 0.01,
            "At high T, probs should be ~uniform"
        );
    }
}

/// Wolfram-verified sigmoid function
/// Ïƒ(x) = 1 / (1 + exp(-x))
#[test]
fn test_sigmoid_wolfram_verified() {
    let test_cases = [
        (-5.0, 0.006692850924284855),
        (-1.0, 0.2689414213699951),
        (0.0, 0.5),
        (1.0, 0.7310585786300049),
        (5.0, 0.9933071490757153),
    ];

    for (x, expected) in test_cases {
        let computed = sigmoid(x);
        assert!(
            (computed - expected).abs() < 1e-10,
            "sigmoid({}) = {}, expected {}",
            x,
            computed,
            expected
        );
    }
}

/// Wolfram-verified tanh function
#[test]
fn test_tanh_wolfram_verified() {
    let test_cases: [(f64, f64); 5] = [
        (-2.0, -0.9640275800758169),
        (-1.0, -0.7615941559557649),
        (0.0, 0.0),
        (1.0, 0.7615941559557649),
        (2.0, 0.9640275800758169),
    ];

    for (x, expected) in test_cases {
        let computed: f64 = x.tanh();
        assert!(
            (computed - expected).abs() < 1e-10,
            "tanh({}) = {}, expected {}",
            x,
            computed,
            expected
        );
    }
}

// Helper functions

fn boltzmann_distribution(energies: &[f64], temp: f64) -> Vec<f64> {
    let exp_neg_e: Vec<f64> = energies.iter().map(|&e| (-e / temp).exp()).collect();
    let z: f64 = exp_neg_e.iter().sum();
    exp_neg_e.iter().map(|&e| e / z).collect()
}

fn sigmoid(x: f64) -> f64 {
    1.0 / (1.0 + (-x).exp())
}
