//! JoltPhysics FFI backend
//!
//! High-performance AAA game physics via C++ FFI bindings.
//! Fork: https://github.com/fatih-erarslan/JoltPhysics
//!
//! ## Features
//! - Soft bodies, cloth simulation
//! - Character controller
//! - Vehicle dynamics
//! - Continuous collision detection
//! - Deterministic simulation
//! - Multi-threaded job system

use crate::backend::{BackendCapabilities, BackendError, BackendInfo, PhysicsBackend, SimulationStats};
use crate::body::BodyDesc;
use crate::collider::ColliderDesc;
use crate::constraint::ConstraintDesc;
use crate::query::{RayCast, RayHit, ShapeCast, ShapeHit};
use crate::{ContactManifold, PhysicsMaterial, Transform, AABB};
use nalgebra::{Point3, UnitQuaternion, Vector3};
use std::any::Any;
use std::collections::HashMap;
use std::sync::atomic::{AtomicU32, Ordering};

// Import real JoltPhysics adapter when feature is enabled
#[cfg(feature = "jolt")]
use jolt_hyperphysics::JoltHyperPhysicsAdapter;

// ============================================================================
// FFI Type Definitions (would be generated by bindgen in production)
// ============================================================================

/// Jolt body motion type
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum JoltMotionType {
    Static = 0,
    Kinematic = 1,
    Dynamic = 2,
}

/// Jolt shape types
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum JoltShapeType {
    Sphere = 0,
    Box = 1,
    Capsule = 2,
    TaperedCapsule = 3,
    Cylinder = 4,
    ConvexHull = 5,
    Mesh = 6,
    HeightField = 7,
    SoftBody = 8,
}

/// Jolt object layer (collision filtering)
#[repr(u16)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum JoltObjectLayer {
    NonMoving = 0,
    Moving = 1,
    Debris = 2,
    Sensor = 3,
}

/// Jolt broad phase layer
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum JoltBroadPhaseLayer {
    NonMoving = 0,
    Moving = 1,
}

// ============================================================================
// FFI Stubs (would link to jolt-sys crate in production)
// ============================================================================

mod ffi {
    //! FFI bindings to JoltPhysics C API
    //! In production, this would be generated by bindgen from jolt-c.h

    use std::ffi::c_void;

    pub type JoltPhysicsSystem = c_void;
    pub type JoltBodyInterface = c_void;
    pub type JoltBody = c_void;
    pub type JoltShape = c_void;
    pub type JoltConstraint = c_void;

    #[repr(C)]
    pub struct JoltVec3 {
        pub x: f32,
        pub y: f32,
        pub z: f32,
        pub _w: f32, // Padding for SIMD
    }

    #[repr(C)]
    pub struct JoltQuat {
        pub x: f32,
        pub y: f32,
        pub z: f32,
        pub w: f32,
    }

    #[repr(C)]
    pub struct JoltBodyCreationSettings {
        pub position: JoltVec3,
        pub rotation: JoltQuat,
        pub linear_velocity: JoltVec3,
        pub angular_velocity: JoltVec3,
        pub motion_type: u8,
        pub object_layer: u16,
        pub user_data: u64,
        pub allow_sleeping: bool,
        pub friction: f32,
        pub restitution: f32,
        pub linear_damping: f32,
        pub angular_damping: f32,
        pub gravity_factor: f32,
    }

    // FFI function declarations (stubs - would link to libjolt)
    #[allow(dead_code)]
    extern "C" {
        pub fn JoltInit() -> bool;
        pub fn JoltShutdown();
        pub fn JoltCreatePhysicsSystem(
            max_bodies: u32,
            num_body_mutexes: u32,
            max_body_pairs: u32,
            max_contact_constraints: u32,
        ) -> *mut JoltPhysicsSystem;
        pub fn JoltDestroyPhysicsSystem(system: *mut JoltPhysicsSystem);
        pub fn JoltUpdate(system: *mut JoltPhysicsSystem, delta_time: f32, collision_steps: i32);
        pub fn JoltGetBodyInterface(system: *mut JoltPhysicsSystem) -> *mut JoltBodyInterface;

        // Body operations
        pub fn JoltCreateBody(
            body_interface: *mut JoltBodyInterface,
            settings: *const JoltBodyCreationSettings,
            shape: *const JoltShape,
        ) -> u32;
        pub fn JoltDestroyBody(body_interface: *mut JoltBodyInterface, body_id: u32);
        pub fn JoltGetBodyPosition(body_interface: *const JoltBodyInterface, body_id: u32) -> JoltVec3;
        pub fn JoltGetBodyRotation(body_interface: *const JoltBodyInterface, body_id: u32) -> JoltQuat;
        pub fn JoltSetBodyPosition(body_interface: *mut JoltBodyInterface, body_id: u32, pos: JoltVec3);
        pub fn JoltSetBodyRotation(body_interface: *mut JoltBodyInterface, body_id: u32, rot: JoltQuat);
        pub fn JoltGetBodyLinearVelocity(body_interface: *const JoltBodyInterface, body_id: u32) -> JoltVec3;
        pub fn JoltSetBodyLinearVelocity(body_interface: *mut JoltBodyInterface, body_id: u32, vel: JoltVec3);
        pub fn JoltAddForce(body_interface: *mut JoltBodyInterface, body_id: u32, force: JoltVec3);
        pub fn JoltAddImpulse(body_interface: *mut JoltBodyInterface, body_id: u32, impulse: JoltVec3);

        // Shape creation
        pub fn JoltCreateSphereShape(radius: f32) -> *mut JoltShape;
        pub fn JoltCreateBoxShape(half_extent_x: f32, half_extent_y: f32, half_extent_z: f32) -> *mut JoltShape;
        pub fn JoltCreateCapsuleShape(half_height: f32, radius: f32) -> *mut JoltShape;
        pub fn JoltDestroyShape(shape: *mut JoltShape);

        // Raycasting
        pub fn JoltCastRay(
            system: *const JoltPhysicsSystem,
            origin: JoltVec3,
            direction: JoltVec3,
            max_distance: f32,
            out_hit_body: *mut u32,
            out_hit_fraction: *mut f32,
        ) -> bool;
    }
}

// ============================================================================
// Configuration
// ============================================================================

/// JoltPhysics configuration
#[derive(Debug, Clone)]
pub struct JoltConfig {
    /// Maximum number of rigid bodies
    pub max_bodies: u32,
    /// Number of body mutexes (0 = auto)
    pub num_body_mutexes: u32,
    /// Maximum body pairs for broadphase
    pub max_body_pairs: u32,
    /// Maximum contact constraints
    pub max_contact_constraints: u32,
    /// Temp allocator size in bytes
    pub temp_allocator_size: usize,
    /// Number of collision steps per update
    pub collision_steps: i32,
    /// Enable enhanced internal edge removal
    pub enhanced_internal_edge_removal: bool,
    /// Enable back face culling for mesh shapes
    pub back_face_culling: bool,
}

impl Default for JoltConfig {
    fn default() -> Self {
        Self {
            max_bodies: 65536,
            num_body_mutexes: 0, // Auto-determine
            max_body_pairs: 65536,
            max_contact_constraints: 10240,
            temp_allocator_size: 10 * 1024 * 1024, // 10MB
            collision_steps: 1,
            enhanced_internal_edge_removal: true,
            back_face_culling: true,
        }
    }
}

// ============================================================================
// Handle Types
// ============================================================================

/// Opaque handle to a Jolt body
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct JoltBodyHandle(pub u32);

/// Opaque handle to a Jolt collider (shape instance)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct JoltColliderHandle(pub u32);

/// Opaque handle to a Jolt constraint
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct JoltConstraintHandle(pub u32);

// ============================================================================
// Internal Body Storage (for when FFI is not available)
// ============================================================================

#[derive(Debug, Clone)]
struct InternalBody {
    transform: Transform,
    linear_velocity: Vector3<f32>,
    angular_velocity: Vector3<f32>,
    motion_type: JoltMotionType,
    mass: f32,
    friction: f32,
    restitution: f32,
    linear_damping: f32,
    angular_damping: f32,
    gravity_scale: f32,
    is_active: bool,
    user_data: u64,
}

// ============================================================================
// Backend Implementation
// ============================================================================

/// JoltPhysics backend
///
/// When linked with the actual JoltPhysics library, this backend provides:
/// - AAA-quality rigid body dynamics
/// - Soft body simulation
/// - Character controllers
/// - Vehicle physics
/// - Deterministic simulation
pub struct JoltBackend {
    gravity: Vector3<f32>,
    contacts: Vec<ContactManifold>,
    stats: SimulationStats,
    config: JoltConfig,

    // Internal simulation state (fallback when FFI not linked)
    bodies: HashMap<u32, InternalBody>,
    next_body_id: AtomicU32,

    // Real JoltPhysics adapter when feature enabled
    #[cfg(feature = "jolt")]
    adapter: Option<JoltHyperPhysicsAdapter>,
}

impl JoltBackend {
    /// Check if JoltPhysics FFI is available
    pub fn is_ffi_available() -> bool {
        #[cfg(feature = "jolt")]
        {
            true
        }
        #[cfg(not(feature = "jolt"))]
        {
            false
        }
    }

    /// Get Jolt-specific configuration
    pub fn config(&self) -> &JoltConfig {
        &self.config
    }

    /// Get access to the underlying JoltHyperPhysicsAdapter (if available)
    #[cfg(feature = "jolt")]
    pub fn adapter(&self) -> Option<&JoltHyperPhysicsAdapter> {
        self.adapter.as_ref()
    }

    /// Get mutable access to the underlying JoltHyperPhysicsAdapter (if available)
    #[cfg(feature = "jolt")]
    pub fn adapter_mut(&mut self) -> Option<&mut JoltHyperPhysicsAdapter> {
        self.adapter.as_mut()
    }

    /// Integrate a single body (fallback implementation)
    fn integrate_body(&mut self, id: u32, dt: f32) {
        if let Some(body) = self.bodies.get_mut(&id) {
            if body.motion_type != JoltMotionType::Dynamic || !body.is_active {
                return;
            }

            // Apply gravity
            let gravity_force = self.gravity * body.gravity_scale;
            body.linear_velocity += gravity_force * dt;

            // Apply damping
            body.linear_velocity *= 1.0 - body.linear_damping * dt;
            body.angular_velocity *= 1.0 - body.angular_damping * dt;

            // Integrate position
            body.transform.position += body.linear_velocity * dt;

            // Integrate rotation (simplified)
            if body.angular_velocity.norm() > 1e-6 {
                let angle = body.angular_velocity.norm() * dt;
                let axis = body.angular_velocity.normalize();
                let delta_rot = UnitQuaternion::from_axis_angle(
                    &nalgebra::Unit::new_normalize(axis),
                    angle,
                );
                body.transform.rotation = delta_rot * body.transform.rotation;
            }
        }
    }
}

impl PhysicsBackend for JoltBackend {
    type Config = JoltConfig;
    type BodyHandle = JoltBodyHandle;
    type ColliderHandle = JoltColliderHandle;
    type ConstraintHandle = JoltConstraintHandle;

    fn new(config: Self::Config) -> Result<Self, BackendError> {
        // Initialize real JoltPhysics adapter when feature is enabled
        #[cfg(feature = "jolt")]
        let adapter = {
            let jolt_config = jolt_hyperphysics::JoltConfiguration {
                max_bodies: config.max_bodies,
                num_body_mutexes: config.num_body_mutexes,
                max_body_pairs: config.max_body_pairs,
                max_contact_constraints: config.max_contact_constraints,
                collision_tolerance: 0.001,
                penetration_tolerance: 0.001,
                deterministic: true,
            };
            match JoltHyperPhysicsAdapter::with_config(jolt_config) {
                Ok(adapter) => Some(adapter),
                Err(e) => {
                    tracing::warn!("Failed to initialize JoltPhysics FFI: {:?}, using fallback", e);
                    None
                }
            }
        };

        Ok(Self {
            gravity: Vector3::new(0.0, -9.81, 0.0),
            contacts: Vec::new(),
            stats: SimulationStats::default(),
            config,
            bodies: HashMap::new(),
            next_body_id: AtomicU32::new(1),
            #[cfg(feature = "jolt")]
            adapter,
        })
    }

    fn info(&self) -> BackendInfo {
        BackendInfo {
            name: "JoltPhysics",
            version: "5.0",
            description: "AAA game physics engine with soft bodies, cloth, and vehicles",
            gpu_accelerated: false,
            differentiable: false,
        }
    }

    fn capabilities(&self) -> BackendCapabilities {
        BackendCapabilities {
            physics_3d: true,
            physics_2d: false,
            soft_bodies: true,
            cloth: true,
            fluids: false,
            articulated: true,
            ccd: true,
            deterministic: true,
            parallel: true,
            gpu: false,
            differentiable: false,
            max_bodies: self.config.max_bodies,
        }
    }

    fn step(&mut self, dt: f32) {
        let start = std::time::Instant::now();

        // Use real JoltPhysics adapter when available
        #[cfg(feature = "jolt")]
        if let Some(ref mut adapter) = self.adapter {
            let _ = adapter.step(dt, self.config.collision_steps);
            // Sync body transforms from Jolt to internal state
            for (&id, body) in self.bodies.iter_mut() {
                let pos = adapter.get_position(id);
                body.transform.position = pos;
                let vel = adapter.get_velocity(id);
                body.linear_velocity = vel;
            }
        } else {
            // Fallback: simple Euler integration
            let body_ids: Vec<u32> = self.bodies.keys().copied().collect();
            for id in body_ids {
                self.integrate_body(id, dt);
            }
        }

        #[cfg(not(feature = "jolt"))]
        {
            // Fallback: simple Euler integration
            let body_ids: Vec<u32> = self.bodies.keys().copied().collect();
            for id in body_ids {
                self.integrate_body(id, dt);
            }
        }

        self.stats.total_us = start.elapsed().as_micros() as u64;
        self.stats.active_bodies = self.bodies.values().filter(|b| b.is_active).count() as u32;
    }

    fn set_gravity(&mut self, gravity: Vector3<f32>) {
        self.gravity = gravity;
    }

    fn gravity(&self) -> Vector3<f32> {
        self.gravity
    }

    fn create_body(&mut self, desc: &BodyDesc) -> Result<Self::BodyHandle, BackendError> {
        let motion_type = match desc.body_type {
            crate::body::BodyType::Static => JoltMotionType::Static,
            crate::body::BodyType::Kinematic => JoltMotionType::Kinematic,
            crate::body::BodyType::Dynamic => JoltMotionType::Dynamic,
        };

        let is_static = motion_type == JoltMotionType::Static;

        // Use real JoltPhysics adapter when available
        #[cfg(feature = "jolt")]
        let id = if let Some(ref mut adapter) = self.adapter {
            // Create body in Jolt using default box shape (1x1x1)
            // Full shape support would be added when shape info is available
            let jolt_id = adapter.create_box(
                Vector3::new(0.5, 0.5, 0.5), // default half extents
                1.0, // density
                is_static,
            );
            adapter.set_position(jolt_id, desc.transform.position);
            adapter.set_velocity(jolt_id, desc.linear_velocity);
            jolt_id
        } else {
            self.next_body_id.fetch_add(1, Ordering::Relaxed)
        };

        #[cfg(not(feature = "jolt"))]
        let id = self.next_body_id.fetch_add(1, Ordering::Relaxed);

        let body = InternalBody {
            transform: desc.transform,
            linear_velocity: desc.linear_velocity,
            angular_velocity: desc.angular_velocity,
            motion_type,
            mass: 1.0, // Would be computed from shape
            friction: 0.5,
            restitution: 0.3,
            linear_damping: desc.linear_damping,
            angular_damping: desc.angular_damping,
            gravity_scale: desc.gravity_scale,
            is_active: motion_type == JoltMotionType::Dynamic,
            user_data: desc.user_data,
        };

        self.bodies.insert(id, body);
        Ok(JoltBodyHandle(id))
    }

    fn remove_body(&mut self, handle: Self::BodyHandle) -> Result<(), BackendError> {
        self.bodies.remove(&handle.0);
        Ok(())
    }

    fn body_transform(&self, handle: Self::BodyHandle) -> Option<Transform> {
        self.bodies.get(&handle.0).map(|b| b.transform)
    }

    fn set_body_transform(&mut self, handle: Self::BodyHandle, transform: Transform) {
        if let Some(body) = self.bodies.get_mut(&handle.0) {
            body.transform = transform;
        }
    }

    fn body_linear_velocity(&self, handle: Self::BodyHandle) -> Option<Vector3<f32>> {
        self.bodies.get(&handle.0).map(|b| b.linear_velocity)
    }

    fn set_body_linear_velocity(&mut self, handle: Self::BodyHandle, velocity: Vector3<f32>) {
        if let Some(body) = self.bodies.get_mut(&handle.0) {
            body.linear_velocity = velocity;
            body.is_active = true;
        }
    }

    fn body_angular_velocity(&self, handle: Self::BodyHandle) -> Option<Vector3<f32>> {
        self.bodies.get(&handle.0).map(|b| b.angular_velocity)
    }

    fn set_body_angular_velocity(&mut self, handle: Self::BodyHandle, velocity: Vector3<f32>) {
        if let Some(body) = self.bodies.get_mut(&handle.0) {
            body.angular_velocity = velocity;
            body.is_active = true;
        }
    }

    fn apply_force(&mut self, handle: Self::BodyHandle, force: Vector3<f32>) {
        if let Some(body) = self.bodies.get_mut(&handle.0) {
            if body.motion_type == JoltMotionType::Dynamic && body.mass > 0.0 {
                // F = ma, so a = F/m, integrate: dv = a * dt (handled in step)
                body.linear_velocity += force / body.mass * (1.0 / 60.0); // Approximate
                body.is_active = true;
            }
        }
    }

    fn apply_force_at_point(&mut self, handle: Self::BodyHandle, force: Vector3<f32>, _point: Point3<f32>) {
        // Simplified: apply as central force (would compute torque in full impl)
        self.apply_force(handle, force);
    }

    fn apply_impulse(&mut self, handle: Self::BodyHandle, impulse: Vector3<f32>) {
        if let Some(body) = self.bodies.get_mut(&handle.0) {
            if body.motion_type == JoltMotionType::Dynamic && body.mass > 0.0 {
                body.linear_velocity += impulse / body.mass;
                body.is_active = true;
            }
        }
    }

    fn apply_torque(&mut self, handle: Self::BodyHandle, torque: Vector3<f32>) {
        if let Some(body) = self.bodies.get_mut(&handle.0) {
            if body.motion_type == JoltMotionType::Dynamic {
                // Simplified: directly modify angular velocity
                body.angular_velocity += torque * (1.0 / 60.0);
                body.is_active = true;
            }
        }
    }

    fn body_count(&self) -> usize {
        self.bodies.len()
    }

    fn create_collider(&mut self, _body: Self::BodyHandle, _desc: &ColliderDesc) -> Result<Self::ColliderHandle, BackendError> {
        // In Jolt, shapes are set during body creation
        // This would create a compound shape or modify body shape
        Err(BackendError::Unsupported("Jolt uses shapes during body creation".into()))
    }

    fn remove_collider(&mut self, _handle: Self::ColliderHandle) -> Result<(), BackendError> {
        Ok(())
    }

    fn set_collider_material(&mut self, _handle: Self::ColliderHandle, _material: PhysicsMaterial) {}

    fn set_collider_enabled(&mut self, _handle: Self::ColliderHandle, _enabled: bool) {}

    fn collider_aabb(&self, _handle: Self::ColliderHandle) -> Option<AABB> {
        None
    }

    fn create_constraint(&mut self, _desc: &ConstraintDesc) -> Result<Self::ConstraintHandle, BackendError> {
        Err(BackendError::Unsupported("Constraint creation requires FFI".into()))
    }

    fn remove_constraint(&mut self, _handle: Self::ConstraintHandle) -> Result<(), BackendError> {
        Ok(())
    }

    fn ray_cast(&self, ray: &RayCast) -> Option<RayHit<Self::BodyHandle>> {
        // Simple ray-AABB test against all bodies (proper impl would use BVH)
        let mut closest: Option<(u32, f32, Point3<f32>)> = None;

        for (&id, body) in &self.bodies {
            // Create approximate AABB for body
            let half_size = Vector3::new(0.5, 0.5, 0.5); // Would come from shape
            let aabb = AABB::from_center_half_extents(
                Point3::from(body.transform.position),
                half_size,
            );

            // Ray-AABB intersection
            if let Some(t) = ray_aabb_intersection(ray, &aabb) {
                if t < ray.max_distance {
                    if closest.is_none() || t < closest.unwrap().1 {
                        closest = Some((id, t, ray.origin + ray.direction.into_inner() * t));
                    }
                }
            }
        }

        closest.map(|(id, t, point)| RayHit {
            body: JoltBodyHandle(id),
            point,
            normal: Vector3::y(), // Would compute actual normal
            distance: t,
        })
    }

    fn ray_cast_all(&self, ray: &RayCast) -> Vec<RayHit<Self::BodyHandle>> {
        let mut hits = Vec::new();

        for (&id, body) in &self.bodies {
            let half_size = Vector3::new(0.5, 0.5, 0.5);
            let aabb = AABB::from_center_half_extents(
                Point3::from(body.transform.position),
                half_size,
            );

            if let Some(t) = ray_aabb_intersection(ray, &aabb) {
                if t < ray.max_distance {
                    hits.push(RayHit {
                        body: JoltBodyHandle(id),
                        point: ray.origin + ray.direction.into_inner() * t,
                        normal: Vector3::y(),
                        distance: t,
                    });
                }
            }
        }

        hits.sort_by(|a, b| a.distance.partial_cmp(&b.distance).unwrap());
        hits
    }

    fn shape_cast(&self, _cast: &ShapeCast) -> Option<ShapeHit<Self::BodyHandle>> {
        None
    }

    fn query_aabb(&self, aabb: &AABB) -> Vec<Self::BodyHandle> {
        self.bodies
            .iter()
            .filter_map(|(&id, body)| {
                let body_aabb = AABB::from_center_half_extents(
                    Point3::from(body.transform.position),
                    Vector3::new(0.5, 0.5, 0.5),
                );
                if aabb.intersects(&body_aabb) {
                    Some(JoltBodyHandle(id))
                } else {
                    None
                }
            })
            .collect()
    }

    fn contacts(&self) -> &[ContactManifold] {
        &self.contacts
    }

    fn serialize_state(&self) -> Result<Vec<u8>, BackendError> {
        // Would serialize all body states
        Err(BackendError::Unsupported("Serialization requires implementation".into()))
    }

    fn deserialize_state(&mut self, _data: &[u8]) -> Result<(), BackendError> {
        Err(BackendError::Unsupported("Deserialization requires implementation".into()))
    }

    fn reset(&mut self) {
        self.bodies.clear();
        self.contacts.clear();
        self.next_body_id.store(1, Ordering::Relaxed);
    }

    fn stats(&self) -> SimulationStats {
        self.stats.clone()
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Ray-AABB intersection test
fn ray_aabb_intersection(ray: &RayCast, aabb: &AABB) -> Option<f32> {
    let inv_dir = Vector3::new(
        1.0 / ray.direction.x,
        1.0 / ray.direction.y,
        1.0 / ray.direction.z,
    );

    let t1 = (aabb.min.x - ray.origin.x) * inv_dir.x;
    let t2 = (aabb.max.x - ray.origin.x) * inv_dir.x;
    let t3 = (aabb.min.y - ray.origin.y) * inv_dir.y;
    let t4 = (aabb.max.y - ray.origin.y) * inv_dir.y;
    let t5 = (aabb.min.z - ray.origin.z) * inv_dir.z;
    let t6 = (aabb.max.z - ray.origin.z) * inv_dir.z;

    let tmin = t1.min(t2).max(t3.min(t4)).max(t5.min(t6));
    let tmax = t1.max(t2).min(t3.max(t4)).min(t5.max(t6));

    if tmax >= tmin && tmax >= 0.0 {
        Some(if tmin >= 0.0 { tmin } else { tmax })
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::body::BodyDesc;

    #[test]
    fn test_jolt_backend_creation() {
        let backend = JoltBackend::new(JoltConfig::default()).unwrap();
        assert_eq!(backend.info().name, "JoltPhysics");
        assert!(backend.capabilities().physics_3d);
        assert!(backend.capabilities().soft_bodies);
    }

    #[test]
    fn test_jolt_body_lifecycle() {
        let mut backend = JoltBackend::new(JoltConfig::default()).unwrap();

        let handle = backend.create_body(&BodyDesc::dynamic()
            .with_position(Vector3::new(0.0, 10.0, 0.0)))
            .unwrap();

        assert_eq!(backend.body_count(), 1);

        let transform = backend.body_transform(handle).unwrap();
        assert!((transform.position.y - 10.0).abs() < 1e-6);

        backend.remove_body(handle).unwrap();
        assert_eq!(backend.body_count(), 0);
    }

    #[test]
    fn test_jolt_gravity_integration() {
        let mut backend = JoltBackend::new(JoltConfig::default()).unwrap();
        backend.set_gravity(Vector3::new(0.0, -10.0, 0.0));

        let handle = backend.create_body(&BodyDesc::dynamic()
            .with_position(Vector3::new(0.0, 10.0, 0.0)))
            .unwrap();

        // Step simulation
        for _ in 0..60 {
            backend.step(1.0 / 60.0);
        }

        // Body should have fallen
        let transform = backend.body_transform(handle).unwrap();
        assert!(transform.position.y < 10.0);
    }
}
