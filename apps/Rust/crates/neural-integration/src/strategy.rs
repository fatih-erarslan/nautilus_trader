/*!
Trading strategy integration with neural networks
===============================================
*/

use crate::{NeuralConfig, NeuralPrediction, core::{NeuralEngine, NeuralInput}};
use anyhow::{Context, Result};
use nautilus_model::data::{Bar, Quote, Trade};
use nautilus_model::enums::{OrderSide, TimeInForce};
use nautilus_model::identifiers::{InstrumentId, StrategyId};
use nautilus_model::orders::market::MarketOrder;
use nautilus_model::types::{Price, Quantity};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::sync::RwLock;
use tracing::{info, debug, warn, error};
use uuid::Uuid;

/// Neural-enhanced trading strategy
#[derive(Debug)]
pub struct NeuralTradingStrategy {
    /// Strategy identifier
    pub strategy_id: StrategyId,
    /// Neural engine for predictions
    neural_engine: NeuralEngine,
    /// Strategy configuration
    config: NeuralStrategyConfig,
    /// Current positions
    positions: RwLock<HashMap<InstrumentId, Position>>,
    /// Trading signals cache
    signals_cache: RwLock<HashMap<InstrumentId, TradingSignal>>,
    /// Performance tracking
    performance: RwLock<StrategyPerformance>,
}

/// Neural trading strategy configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NeuralStrategyConfig {
    /// Neural configuration
    pub neural_config: NeuralConfig,
    /// Risk management settings
    pub risk_config: RiskConfig,
    /// Signal generation settings
    pub signal_config: SignalConfig,
    /// Execution settings
    pub execution_config: ExecutionConfig,
}

/// Risk management configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskConfig {
    /// Maximum position size as percentage of portfolio
    pub max_position_size_pct: f64,
    /// Stop loss percentage
    pub stop_loss_pct: f64,
    /// Take profit percentage
    pub take_profit_pct: f64,
    /// Maximum daily drawdown percentage
    pub max_daily_drawdown_pct: f64,
    /// Minimum confidence threshold for trades
    pub min_confidence_threshold: f64,
    /// Maximum number of concurrent positions
    pub max_concurrent_positions: usize,
}

/// Signal generation configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignalConfig {
    /// Lookback period for features
    pub lookback_period: usize,
    /// Signal smoothing window
    pub smoothing_window: usize,
    /// Ensemble weight threshold
    pub ensemble_threshold: f64,
    /// Enable multi-timeframe analysis
    pub multi_timeframe: bool,
    /// Feature scaling method
    pub feature_scaling: FeatureScaling,
}

/// Execution configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionConfig {
    /// Order type preference
    pub order_type: OrderType,
    /// Time in force
    pub time_in_force: TimeInForce,
    /// Slippage tolerance in basis points
    pub slippage_tolerance_bps: u32,
    /// Minimum time between trades (seconds)
    pub min_trade_interval_secs: u64,
    /// Enable dynamic position sizing
    pub dynamic_position_sizing: bool,
}

/// Feature scaling methods
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FeatureScaling {
    /// No scaling
    None,
    /// Min-max normalization
    MinMax,
    /// Z-score standardization
    ZScore,
    /// Robust scaling
    Robust,
}

/// Order type preferences
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderType {
    /// Market orders
    Market,
    /// Limit orders
    Limit,
    /// Adaptive (choose based on conditions)
    Adaptive,
}

/// Trading position information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    /// Instrument identifier
    pub instrument_id: InstrumentId,
    /// Position side
    pub side: OrderSide,
    /// Position quantity
    pub quantity: Quantity,
    /// Entry price
    pub entry_price: Price,
    /// Current price
    pub current_price: Price,
    /// Unrealized PnL
    pub unrealized_pnl: f64,
    /// Entry timestamp
    pub entry_time: chrono::DateTime<chrono::Utc>,
    /// Stop loss price
    pub stop_loss: Option<Price>,
    /// Take profit price
    pub take_profit: Option<Price>,
}

/// Trading signal generated by neural networks
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingSignal {
    /// Signal identifier
    pub id: Uuid,
    /// Instrument identifier
    pub instrument_id: InstrumentId,
    /// Signal direction
    pub side: OrderSide,
    /// Signal strength (0.0 to 1.0)
    pub strength: f64,
    /// Confidence level (0.0 to 1.0)
    pub confidence: f64,
    /// Neural predictions that generated this signal
    pub predictions: Vec<NeuralPrediction>,
    /// Recommended position size
    pub position_size: f64,
    /// Signal generation timestamp
    pub timestamp: chrono::DateTime<chrono::Utc>,
    /// Signal metadata
    pub metadata: HashMap<String, serde_json::Value>,
}

/// Strategy performance metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyPerformance {
    /// Total number of trades
    pub total_trades: u64,
    /// Winning trades
    pub winning_trades: u64,
    /// Losing trades
    pub losing_trades: u64,
    /// Total PnL
    pub total_pnl: f64,
    /// Maximum drawdown
    pub max_drawdown: f64,
    /// Sharpe ratio
    pub sharpe_ratio: f64,
    /// Win rate percentage
    pub win_rate: f64,
    /// Average trade duration in seconds
    pub avg_trade_duration_secs: f64,
    /// Last updated timestamp
    pub last_updated: chrono::DateTime<chrono::Utc>,
}

impl Default for RiskConfig {
    fn default() -> Self {
        Self {
            max_position_size_pct: 10.0,
            stop_loss_pct: 2.0,
            take_profit_pct: 4.0,
            max_daily_drawdown_pct: 5.0,
            min_confidence_threshold: 0.7,
            max_concurrent_positions: 5,
        }
    }
}

impl Default for SignalConfig {
    fn default() -> Self {
        Self {
            lookback_period: 50,
            smoothing_window: 5,
            ensemble_threshold: 0.6,
            multi_timeframe: true,
            feature_scaling: FeatureScaling::ZScore,
        }
    }
}

impl Default for ExecutionConfig {
    fn default() -> Self {
        Self {
            order_type: OrderType::Adaptive,
            time_in_force: TimeInForce::Day,
            slippage_tolerance_bps: 10,
            min_trade_interval_secs: 60,
            dynamic_position_sizing: true,
        }
    }
}

impl Default for StrategyPerformance {
    fn default() -> Self {
        Self {
            total_trades: 0,
            winning_trades: 0,
            losing_trades: 0,
            total_pnl: 0.0,
            max_drawdown: 0.0,
            sharpe_ratio: 0.0,
            win_rate: 0.0,
            avg_trade_duration_secs: 0.0,
            last_updated: chrono::Utc::now(),
        }
    }
}

impl NeuralTradingStrategy {
    /// Create a new neural trading strategy
    pub fn new(
        strategy_id: StrategyId,
        config: NeuralStrategyConfig,
    ) -> Result<Self> {
        let neural_engine = NeuralEngine::new(config.neural_config.clone());
        
        Ok(Self {
            strategy_id,
            neural_engine,
            config,
            positions: RwLock::new(HashMap::new()),
            signals_cache: RwLock::new(HashMap::new()),
            performance: RwLock::new(StrategyPerformance::default()),
        })
    }
    
    /// Initialize the strategy
    pub async fn initialize(&self) -> Result<()> {
        info!("Initializing neural trading strategy: {}", self.strategy_id);
        
        // Initialize neural engine with predictors
        // This would register ruv-FANN and cognition-engine predictors
        
        info!("Neural trading strategy initialized successfully");
        Ok(())
    }
    
    /// Process a new bar and generate trading signals
    pub async fn on_bar(&self, bar: &Bar) -> Result<Option<TradingSignal>> {
        debug!("Processing bar for {}: price={}", bar.bar_type.instrument_id, bar.close);
        
        // Extract features from bar data
        let features = self.extract_features(bar).await?;
        
        // Create neural input
        let neural_input = NeuralInput {
            features,
            symbol: bar.bar_type.instrument_id.symbol.to_string(),
            timestamp: chrono::Utc::now(),
            metadata: {
                let mut meta = HashMap::new();
                meta.insert("bar_type".to_string(), serde_json::Value::from("price_bar"));
                meta.insert("volume".to_string(), serde_json::Value::from(bar.volume.as_f64()));
                meta
            },
        };
        
        // Get ensemble predictions
        let predictions = self.neural_engine.predict_ensemble(&neural_input).await
            .context("Failed to get neural predictions")?;
        
        // Generate trading signal from predictions
        let signal = self.generate_signal(&bar.bar_type.instrument_id, predictions).await?;
        
        // Cache the signal
        if let Some(ref signal) = signal {
            self.signals_cache.write().await.insert(
                bar.bar_type.instrument_id.clone(),
                signal.clone()
            );
        }
        
        Ok(signal)
    }
    
    /// Process a new quote
    pub async fn on_quote(&self, quote: &Quote) -> Result<()> {
        debug!("Processing quote for {}: bid={}, ask={}", 
               quote.instrument_id, quote.bid_price, quote.ask_price);
        
        // Update current positions with latest prices
        self.update_position_prices(&quote.instrument_id, quote.mid_price()).await?;
        
        Ok(())
    }
    
    /// Process a new trade
    pub async fn on_trade(&self, trade: &Trade) -> Result<()> {
        debug!("Processing trade for {}: price={}, size={}", 
               trade.instrument_id, trade.price, trade.size);
        
        // Update positions and performance metrics
        self.update_position_prices(&trade.instrument_id, trade.price).await?;
        
        Ok(())
    }
    
    /// Extract features from bar data
    async fn extract_features(&self, bar: &Bar) -> Result<Vec<f64>> {
        let mut features = Vec::new();
        
        // Price features
        features.push(bar.open.as_f64());
        features.push(bar.high.as_f64());
        features.push(bar.low.as_f64());
        features.push(bar.close.as_f64());
        
        // Volume features
        features.push(bar.volume.as_f64());
        
        // Technical indicators (simplified)
        let price_change = (bar.close.as_f64() - bar.open.as_f64()) / bar.open.as_f64();
        features.push(price_change);
        
        let price_range = (bar.high.as_f64() - bar.low.as_f64()) / bar.open.as_f64();
        features.push(price_range);
        
        // Volume-price features
        let vwap = (bar.high.as_f64() + bar.low.as_f64() + bar.close.as_f64()) / 3.0;
        features.push(vwap);
        
        // Scale features if configured
        let scaled_features = self.scale_features(features).await?;
        
        Ok(scaled_features)
    }
    
    /// Scale features according to configuration
    async fn scale_features(&self, features: Vec<f64>) -> Result<Vec<f64>> {
        match self.config.signal_config.feature_scaling {
            FeatureScaling::None => Ok(features),
            FeatureScaling::MinMax => {
                // Simple min-max scaling (0-1)
                let min_val = features.iter().fold(f64::INFINITY, |a, &b| a.min(b));
                let max_val = features.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b));
                
                if max_val != min_val {
                    Ok(features.iter()
                        .map(|&x| (x - min_val) / (max_val - min_val))
                        .collect())
                } else {
                    Ok(features)
                }
            },
            FeatureScaling::ZScore => {
                // Z-score standardization
                let mean = features.iter().sum::<f64>() / features.len() as f64;
                let variance = features.iter()
                    .map(|&x| (x - mean).powi(2))
                    .sum::<f64>() / features.len() as f64;
                let std_dev = variance.sqrt();
                
                if std_dev > 0.0 {
                    Ok(features.iter()
                        .map(|&x| (x - mean) / std_dev)
                        .collect())
                } else {
                    Ok(features)
                }
            },
            FeatureScaling::Robust => {
                // Robust scaling using median and IQR
                let mut sorted = features.clone();
                sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());
                
                let median = sorted[sorted.len() / 2];
                let q1 = sorted[sorted.len() / 4];
                let q3 = sorted[3 * sorted.len() / 4];
                let iqr = q3 - q1;
                
                if iqr > 0.0 {
                    Ok(features.iter()
                        .map(|&x| (x - median) / iqr)
                        .collect())
                } else {
                    Ok(features)
                }
            },
        }
    }
    
    /// Generate trading signal from neural predictions
    async fn generate_signal(
        &self,
        instrument_id: &InstrumentId,
        predictions: Vec<NeuralPrediction>,
    ) -> Result<Option<TradingSignal>> {
        if predictions.is_empty() {
            return Ok(None);
        }
        
        // Calculate ensemble statistics
        let avg_confidence = predictions.iter()
            .map(|p| p.confidence)
            .sum::<f64>() / predictions.len() as f64;
        
        let avg_value = predictions.iter()
            .map(|p| p.value)
            .sum::<f64>() / predictions.len() as f64;
        
        // Check if signal meets confidence threshold
        if avg_confidence < self.config.risk_config.min_confidence_threshold {
            debug!(
                "Signal confidence {:.3} below threshold {:.3} for {}",
                avg_confidence, 
                self.config.risk_config.min_confidence_threshold,
                instrument_id
            );
            return Ok(None);
        }
        
        // Determine signal direction
        let side = if avg_value > 0.0 {
            OrderSide::Buy
        } else if avg_value < 0.0 {
            OrderSide::Sell
        } else {
            return Ok(None); // No clear signal
        };
        
        // Calculate signal strength
        let strength = avg_value.abs().min(1.0);
        
        // Calculate position size
        let position_size = self.calculate_position_size(
            instrument_id,
            avg_confidence,
            strength
        ).await?;
        
        let signal = TradingSignal {
            id: Uuid::new_v4(),
            instrument_id: instrument_id.clone(),
            side,
            strength,
            confidence: avg_confidence,
            predictions,
            position_size,
            timestamp: chrono::Utc::now(),
            metadata: HashMap::new(),
        };
        
        info!(
            "Generated trading signal: {} {} confidence={:.3} strength={:.3} size={:.3}",
            instrument_id, side, avg_confidence, strength, position_size
        );
        
        Ok(Some(signal))
    }
    
    /// Calculate position size based on risk parameters
    async fn calculate_position_size(
        &self,
        _instrument_id: &InstrumentId,
        confidence: f64,
        strength: f64,
    ) -> Result<f64> {
        let base_size = self.config.risk_config.max_position_size_pct / 100.0;
        
        // Adjust size based on confidence and strength
        let size_multiplier = if self.config.execution_config.dynamic_position_sizing {
            confidence * strength
        } else {
            1.0
        };
        
        let position_size = base_size * size_multiplier;
        
        Ok(position_size.min(base_size))
    }
    
    /// Update position prices with latest market data
    async fn update_position_prices(&self, instrument_id: &InstrumentId, current_price: Price) -> Result<()> {
        let mut positions = self.positions.write().await;
        
        if let Some(position) = positions.get_mut(instrument_id) {
            position.current_price = current_price;
            
            // Calculate unrealized PnL
            let price_diff = current_price.as_f64() - position.entry_price.as_f64();
            let multiplier = match position.side {
                OrderSide::Buy => 1.0,
                OrderSide::Sell => -1.0,
                _ => 0.0,
            };
            
            position.unrealized_pnl = price_diff * multiplier * position.quantity.as_f64();
            
            debug!(
                "Updated position for {}: unrealized_pnl={:.2}",
                instrument_id, position.unrealized_pnl
            );
        }
        
        Ok(())
    }
    
    /// Get current strategy performance
    pub async fn get_performance(&self) -> StrategyPerformance {
        self.performance.read().await.clone()
    }
    
    /// Get current positions
    pub async fn get_positions(&self) -> HashMap<InstrumentId, Position> {
        self.positions.read().await.clone()
    }
    
    /// Get cached signals
    pub async fn get_signals(&self) -> HashMap<InstrumentId, TradingSignal> {
        self.signals_cache.read().await.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use nautilus_model::identifiers::Symbol;
    use nautilus_model::types::Price;
    
    #[tokio::test]
    async fn test_neural_strategy_creation() {
        let strategy_id = StrategyId::new("neural_strategy");
        let config = NeuralStrategyConfig {
            neural_config: NeuralConfig::default(),
            risk_config: RiskConfig::default(),
            signal_config: SignalConfig::default(),
            execution_config: ExecutionConfig::default(),
        };
        
        let strategy = NeuralTradingStrategy::new(strategy_id, config).unwrap();
        
        assert_eq!(strategy.strategy_id.to_string(), "neural_strategy");
        
        let performance = strategy.get_performance().await;
        assert_eq!(performance.total_trades, 0);
    }
    
    #[tokio::test]
    async fn test_feature_scaling() {
        let strategy_id = StrategyId::new("test_strategy");
        let mut config = NeuralStrategyConfig {
            neural_config: NeuralConfig::default(),
            risk_config: RiskConfig::default(),
            signal_config: SignalConfig::default(),
            execution_config: ExecutionConfig::default(),
        };
        
        config.signal_config.feature_scaling = FeatureScaling::MinMax;
        
        let strategy = NeuralTradingStrategy::new(strategy_id, config).unwrap();
        
        let features = vec![1.0, 2.0, 3.0, 4.0, 5.0];
        let scaled = strategy.scale_features(features).await.unwrap();
        
        // Min-max scaling should result in [0.0, 0.25, 0.5, 0.75, 1.0]
        assert!((scaled[0] - 0.0).abs() < 0.001);
        assert!((scaled[4] - 1.0).abs() < 0.001);
    }
}